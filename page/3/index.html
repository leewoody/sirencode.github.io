<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Diablo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Diablo">
<meta property="og:url" content="https://github.com/sirencode/page/3/index.html">
<meta property="og:site_name" content="Diablo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Diablo">
  
    <link rel="alternative" href="/atom.xml" title="Diablo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ShenYonghe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ShenYonghe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ShenYonghe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-ASNDK开发" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/07/ASNDK开发/" class="article-date">
  	<time datetime="2017-06-06T16:00:00.000Z" itemprop="datePublished">2017-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/07/ASNDK开发/">
        AS NDK开发
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="配置ndk"><a href="#配置ndk" class="headerlink" title="配置ndk"></a>配置ndk</h3><p>as -&gt; sdk -&gt; ndk下载</p>
<h3 id="配置External-Tools"><a href="#配置External-Tools" class="headerlink" title="配置External Tools"></a>配置External Tools</h3><h4 id="javah"><a href="#javah" class="headerlink" title="javah"></a>javah</h4><p>Program:$JDKPath$/bin/javah</p>
<p>Parameters:-classpath $Classpath$ -v -jni $FileClass$</p>
<p>Working directory:$SourcepathEntry$/../jni</p>
<h4 id="ndk-build"><a href="#ndk-build" class="headerlink" title="ndk-build"></a>ndk-build</h4><p>Program:/Users/Diablo/Library/Android/sdk/ndk-bundle/ndk-build</p>
<p>Parameters:~</p>
<p>Working directory:$ProjectFileDir$/app/src/main</p>
<h4 id="ndk-build-clean"><a href="#ndk-build-clean" class="headerlink" title="ndk-build-clean"></a>ndk-build-clean</h4><p>Program:/Users/Diablo/Library/Android/sdk/ndk-bundle/ndk-build</p>
<p>Parameters:clean</p>
<p>Working directory:$ProjectFileDir$/app/src/main</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>local.properties配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndk.dir=/Users/Diablo/Library/Android/sdk/ndk-bundle</span><br></pre></td></tr></table></figure>
<p>gradle.properties配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.useDeprecatedNdk=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>app/build配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            moduleName "TradeC"</span><br><span class="line">            stl "stlport_static"</span><br><span class="line">            ldLibs "log"</span><br><span class="line">        &#125;</span><br><span class="line">        sourceSets.main&#123;</span><br><span class="line">            jni.srcDirs = []</span><br><span class="line">            jniLibs.srcDir "src/main/libs"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>moduleName    模块名称，即编译出来的.so的名字</li>
<li>stl 默认情况下JNI中是无法使用STL标准库的，加入此字段表示使用STL标准库。</li>
<li>ldLibs (#include &lt;android/log.h&gt;)<br>就可以使用__android_log_print方法打印日志到logcat中。</li>
</ul>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="1-新建jni文件夹"><a href="#1-新建jni文件夹" class="headerlink" title="1 新建jni文件夹"></a>1 新建jni文件夹</h4><p>app右键 -&gt; new -&gt; folder -&gt; jni foider</p>
<h4 id="2-新建MyNdk-java"><a href="#2-新建MyNdk-java" class="headerlink" title="2 新建MyNdk.java"></a>2 新建MyNdk.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNdk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"MyLibrary"</span>);    </span><br><span class="line">&#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：声明jni的方法必须带有native关键字，否则将视为一般的方法。设置native的方法允许为静态/非静态方法（即加或不加static关键字）。</li>
</ul>
<h4 id="3-右键MyNdk-gt-External-Tools-gt-javah"><a href="#3-右键MyNdk-gt-External-Tools-gt-javah" class="headerlink" title="3 右键MyNdk -&gt; External Tools -&gt; javah"></a>3 右键MyNdk -&gt; External Tools -&gt; javah</h4><p>执行后在jni文件夹会自动生成一个包名_MyNdk.h文件，包含了MyNdk.java里面生成的native方法。</p>
<ul>
<li>在右键之前先要build一下项目，才可以右键生成.h文件。</li>
</ul>
<h4 id="4-然后我们在jni目录下编写-MyLibrary-cpp、Android-mk、Application-mk这三个文件"><a href="#4-然后我们在jni目录下编写-MyLibrary-cpp、Android-mk、Application-mk这三个文件" class="headerlink" title="4 然后我们在jni目录下编写 MyLibrary.cpp、Android.mk、Application.mk这三个文件"></a>4 然后我们在jni目录下编写 MyLibrary.cpp、Android.mk、Application.mk这三个文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">包名_MyNdk.h</span><br><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"><span class="comment">/* Header for class com_zhangyp_higo_myndk_MyNdk */</span></span><br><span class="line"></span><br><span class="line">#ifndef _Included_com_zhangyp_higo_myndk_MyNdk</span><br><span class="line">#define _Included_com_zhangyp_higo_myndk_MyNdk</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern <span class="string">"C"</span> &#123;</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_zhangyp_higo_myndk_MyNdk</span></span><br><span class="line"><span class="comment"> * Method:    getString</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_zhangyp_higo_myndk_MyNdk_getString</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">MyLibrary.cpp</span><br><span class="line"></span><br><span class="line">#include "com_zhangyp_higo_myndk_MyNdk.h"</span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_zhangyp_higo_myndk_MyNdk_getString</span><br><span class="line">  (JNIEnv * env, jobject obj)&#123;</span><br><span class="line">   <span class="keyword">return</span> (*env).NewStringUTF(<span class="string">"This is mylibrary !!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">Android.mk</span><br><span class="line"></span><br><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := MyLibrary</span><br><span class="line">LOCAL_SRC_FILES =: MyLibrary.cpp</span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br><span class="line"></span><br><span class="line">Application.mk</span><br><span class="line"></span><br><span class="line">APP_MODULES := MyLibrary</span><br><span class="line">APP_ABI := all</span><br></pre></td></tr></table></figure>
<h4 id="5-生成-so文件，在jni文件夹右键执行ndk-build"><a href="#5-生成-so文件，在jni文件夹右键执行ndk-build" class="headerlink" title="5 生成.so文件，在jni文件夹右键执行ndk-build"></a>5 生成.so文件，在jni文件夹右键执行ndk-build</h4><h4 id="6-使用"><a href="#6-使用" class="headerlink" title="6 使用"></a>6 使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyNdk().getString()</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-积极心理学-瑜伽篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/05/积极心理学-瑜伽篇/" class="article-date">
  	<time datetime="2017-06-04T16:00:00.000Z" itemprop="datePublished">2017-06-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/05/积极心理学-瑜伽篇/">
        积极心理学-瑜伽篇(晨读)
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第一章-理解疼痛，消灭它"><a href="#第一章-理解疼痛，消灭它" class="headerlink" title="第一章 理解疼痛，消灭它"></a>第一章 理解疼痛，消灭它</h2><p>瑜伽不仅能帮你缓解慢性疼痛，减轻痛苦，还能帮你把”慢性疼痛反应”变成”慢性愈合反应”，为你带来巨大的能量和喜悦。</p>
<h3 id="疼痛"><a href="#疼痛" class="headerlink" title="疼痛"></a>疼痛</h3><p>疼痛是一种身心相连的过程。疼痛不仅受到身体损伤和疾病的影响，也受想法，情绪，压力的影响。当疼痛变成慢性疼痛的时候，患者的反应就不是健康时的反应了。</p>
<h4 id="疼痛是一种自我保护的反应"><a href="#疼痛是一种自我保护的反应" class="headerlink" title="疼痛是一种自我保护的反应"></a>疼痛是一种自我保护的反应</h4><p><img src="http://oc4zuck5v.bkt.clouddn.com/tengtong.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-期货" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/01/期货/" class="article-date">
  	<time datetime="2017-05-31T16:00:00.000Z" itemprop="datePublished">2017-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/01/期货/">
        期货
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="结算公式"><a href="#结算公式" class="headerlink" title="结算公式"></a>结算公式</h2><h3 id="结算价"><a href="#结算价" class="headerlink" title="结算价"></a>结算价</h3><p>指当天交易结束后，对未平仓合约进行当日交易保证金及当日盈亏结算的基准价。</p>
<h3 id="开仓"><a href="#开仓" class="headerlink" title="开仓"></a>开仓</h3><p>开仓也称建仓，是指期货交易者新建期货头寸的行为。</p>
<h3 id="结算"><a href="#结算" class="headerlink" title="结算"></a>结算</h3><ul>
<li>若是股指期货，则算式中的价格改为”点数”；”交易单位”改为”合约乘数”</li>
</ul>
<h4 id="结算准备金余额的计算公式"><a href="#结算准备金余额的计算公式" class="headerlink" title="结算准备金余额的计算公式"></a>结算准备金余额的计算公式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日结算准备金余额 = 上一交易日结算准备金余额 + 上一交易日交易保证金 - 当日交易保证金 + 当日盈亏 + 入金 - 出金 - 手续分</span><br></pre></td></tr></table></figure>
<h4 id="当日盈亏的计算公式"><a href="#当日盈亏的计算公式" class="headerlink" title="当日盈亏的计算公式"></a>当日盈亏的计算公式</h4><h5 id="商品期货当日盈亏计算"><a href="#商品期货当日盈亏计算" class="headerlink" title="商品期货当日盈亏计算"></a>商品期货当日盈亏计算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日盈亏 = ∑[(卖出成交价 - 当日结算价) * 卖出量] + ∑[(当日结算价价 - 买入成交价) * 买入量] + (上一交易日结算价 - 当日结算价) * (上一交易日卖出持仓量 - 上一交易日买入持仓量)</span><br></pre></td></tr></table></figure>
<h5 id="股票指数期货交易当日盈亏计算"><a href="#股票指数期货交易当日盈亏计算" class="headerlink" title="股票指数期货交易当日盈亏计算"></a>股票指数期货交易当日盈亏计算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日盈亏 = ∑[(卖出成交价 - 当日结算价) * 卖出手数 * 合约乘数] +∑[(当日结算价 - 买入成交价) * 买入手数 * 合约乘数] + (上一交易日结算价 - 当日结算价) * (上一交易日卖出持仓手数 - 上一交易日买入持仓手数) * 合约乘数</span><br></pre></td></tr></table></figure>
<h4 id="当日交易保证金计算公式"><a href="#当日交易保证金计算公式" class="headerlink" title="当日交易保证金计算公式"></a>当日交易保证金计算公式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日交易保证金 = 当日结算价 * 当日交易结束后的持仓总量 * 交易保证金比例</span><br></pre></td></tr></table></figure>
<h5 id="股票当日交易保证金计算公式"><a href="#股票当日交易保证金计算公式" class="headerlink" title="股票当日交易保证金计算公式"></a>股票当日交易保证金计算公式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日交易保证金 = 当日结算价 * 当日交易结束后的持仓总量 * 交易保证金比例 * 合约乘数</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：股票期货交易计算中，”成交价”与”结算价”均以”点数”表示。</li>
</ul>
<h3 id="期货结算"><a href="#期货结算" class="headerlink" title="期货结算"></a>期货结算</h3><p>分为逐日盯市和逐笔对冲两种结算方式</p>
<h4 id="平仓盈亏"><a href="#平仓盈亏" class="headerlink" title="平仓盈亏"></a>平仓盈亏</h4><h5 id="逐日盯市"><a href="#逐日盯市" class="headerlink" title="逐日盯市"></a>逐日盯市</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">平仓盈亏 = 平当日仓盈亏 + 平历史仓盈亏</span><br><span class="line"></span><br><span class="line">平当日仓盈亏 = ∑[(卖出成交价 - 买入成交价) * 交易单位 * 平仓手数]</span><br><span class="line"></span><br><span class="line">平历史仓盈亏 = ∑[(卖出成交价 - 上日结算价) * 交易单位 * 平仓手数] + ∑[(上日结算价 - 买入成交价) * 交易单位 * 平仓手数]</span><br></pre></td></tr></table></figure>
<h5 id="逐笔对冲"><a href="#逐笔对冲" class="headerlink" title="逐笔对冲"></a>逐笔对冲</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平当日仓盈亏 = ∑[(卖出成交价 - 买入成交价) * 交易单位 * 平仓手数]</span><br></pre></td></tr></table></figure>
<h4 id="持仓盯市盈亏-逐日盯市"><a href="#持仓盯市盈亏-逐日盯市" class="headerlink" title="持仓盯市盈亏(逐日盯市)"></a>持仓盯市盈亏(逐日盯市)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">持仓当日盈亏 = 当日持仓盈亏 + 历史持仓盈亏</span><br><span class="line"></span><br><span class="line">当日持仓盈亏 = ∑[(卖出成交价 - 当日结算价) * 交易单位 * 卖出手数] + ∑[(当日结算价 - 买入成交价) * 交易单位 * 买入手数]</span><br><span class="line"></span><br><span class="line">历史持仓盈亏 = ∑[(上次结算价 - 当日结算价) * 交易单位 * 卖出手数] + ∑[(当日结算价 - 上日结算价) * 交易单位 * 买入手数]</span><br></pre></td></tr></table></figure>
<h4 id="浮动盈亏"><a href="#浮动盈亏" class="headerlink" title="浮动盈亏"></a>浮动盈亏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮动盈亏 = ∑[(卖出成交价 - 当日结算价) * 交易单位 * 卖出手数] + ∑[(当日结算价 - 买入成交价) * 交易单位 * 买入手数]</span><br></pre></td></tr></table></figure>
<h4 id="当日盈亏"><a href="#当日盈亏" class="headerlink" title="当日盈亏"></a>当日盈亏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日盈亏 = 平仓盈亏(逐日盯市) + 持仓盯市盈利(逐日盯市)</span><br></pre></td></tr></table></figure>
<h4 id="当日结存"><a href="#当日结存" class="headerlink" title="当日结存"></a>当日结存</h4><h5 id="逐日盯市-1"><a href="#逐日盯市-1" class="headerlink" title="逐日盯市"></a>逐日盯市</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日结存 = 上日结存(逐日盯市) + 当日盈亏 + 入金 - 出金 - 手续费(等)</span><br></pre></td></tr></table></figure>
<h5 id="逐笔对冲-1"><a href="#逐笔对冲-1" class="headerlink" title="逐笔对冲"></a>逐笔对冲</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当日结存 = 上日结存(逐笔对冲) + 平仓盈亏(逐笔对冲) + 入金 - 出金 - 手续费(等)</span><br></pre></td></tr></table></figure>
<h4 id="客户权益"><a href="#客户权益" class="headerlink" title="客户权益"></a>客户权益</h4><h5 id="逐日盯市-2"><a href="#逐日盯市-2" class="headerlink" title="逐日盯市"></a>逐日盯市</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户权益 = 当日结存(逐日盯市)</span><br></pre></td></tr></table></figure>
<h5 id="逐笔对冲-2"><a href="#逐笔对冲-2" class="headerlink" title="逐笔对冲"></a>逐笔对冲</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户权益 = 当日结存(逐笔对冲) + 浮动盈亏</span><br></pre></td></tr></table></figure>
<h3 id="期货及其衍生品"><a href="#期货及其衍生品" class="headerlink" title="期货及其衍生品"></a>期货及其衍生品</h3><h4 id="期货"><a href="#期货" class="headerlink" title="期货"></a>期货</h4><p>期货：通常是指以某种大宗商品或金融资产为标的可交易的标准化合约。<br>根据标的物种类分为商品期货和金融期货，其他期货。</p>
<p>商品期货：标的物为实物商品的期货合约，主要包括农产品期货，金属期货和能源化工期货。<br>金融期货：标的物金融产品，外汇期货，利率期货，股指期货，股票期货。</p>
<h4 id="远期-远期合同-远期合约"><a href="#远期-远期合同-远期合约" class="headerlink" title="远期/远期合同/远期合约"></a>远期/远期合同/远期合约</h4><p>远期：指交易双方约定在未来的某一确定时间，以确定的价格买卖一定数量的某种标的资产合约。</p>
<h4 id="互换"><a href="#互换" class="headerlink" title="互换"></a>互换</h4><p>指两个或两个以上当事人按照商定条件，在约定的时间内交换一系列现金流的合约。</p>
<h4 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h4><p>期权是一种选择的权利，即买方能够在未来的特定事件或者一段时间内按照事先约定的价格买入或者卖出某种约定标的物的权利。</p>
<h3 id="期货及衍生品的主要特征"><a href="#期货及衍生品的主要特征" class="headerlink" title="期货及衍生品的主要特征"></a>期货及衍生品的主要特征</h3><h4 id="合约标准化"><a href="#合约标准化" class="headerlink" title="合约标准化"></a>合约标准化</h4><p>期货合约是由交易所统一制定的标准化合约。</p>
<h4 id="场内集中竞价交易"><a href="#场内集中竞价交易" class="headerlink" title="场内集中竞价交易"></a>场内集中竞价交易</h4><p>期货交易实行场内交易，所有买卖指令必须在交易所内进行集中竞价成交。只有交易所的会员方能进场交易，其他交易者只能委托交易所代理进行期货交易。</p>
<h4 id="保证金交易"><a href="#保证金交易" class="headerlink" title="保证金交易"></a>保证金交易</h4><p>期货交易实行保证金制度。交易者在买卖期货合约时按合约价值的一定比率缴纳保证金(一般为5% - 15%)作为履约保证，即可进行数倍于保证金的交易。这种以大博小的保证金交易，也被称为”杠杆交易”。保证金比率越低，杠杆效应就越大，高收益和高风险的特点就越明显。</p>
<h4 id="双向交易"><a href="#双向交易" class="headerlink" title="双向交易"></a>双向交易</h4><p>交易者既可以买入建仓，即通过买入期货合约开始交易，也可以卖出建仓，即通过卖出期货合约开始交易。双向投资机会，在价格上升时，可通过低买高卖来获利，在货价下降时，可以通过高卖低买来获利。</p>
<h4 id="对冲了解"><a href="#对冲了解" class="headerlink" title="对冲了解"></a>对冲了解</h4><p>交易者在期货市场建仓后，大多并不是通过交割(即交收现货)来结束交易，而是通过对冲了解。通过卖出/买入同一期货合约来解除履约责任。</p>
<h4 id="当日无负债结算-逐日盯市"><a href="#当日无负债结算-逐日盯市" class="headerlink" title="当日无负债结算(逐日盯市)"></a>当日无负债结算(逐日盯市)</h4><p>按当日结算价对交易者结算所有合约的盈亏，交易保证金及手续费，税金等费用，确保无负债。</p>
<h3 id="期货交易"><a href="#期货交易" class="headerlink" title="期货交易"></a>期货交易</h3><h4 id="合约主要条款"><a href="#合约主要条款" class="headerlink" title="合约主要条款"></a>合约主要条款</h4><h5 id="合约名称"><a href="#合约名称" class="headerlink" title="合约名称"></a>合约名称</h5><p>合约品种名称及上市交易所名称。</p>
<h5 id="交易单位-合约价值"><a href="#交易单位-合约价值" class="headerlink" title="交易单位/合约价值"></a>交易单位/合约价值</h5><p>交易单位指交易所交易每手期货合约代表的标的物的数量，”10吨/手”。合约价格指每手期货合约代表的标的物的价值，只能以合约价格整数倍交易，””。</p>
<h5 id="最小变动价位"><a href="#最小变动价位" class="headerlink" title="最小变动价位"></a>最小变动价位</h5><p>交易所公开竞价过程中，对合约 每计量单位报价的最小变动数值。每次报价的变动值必须是最小变动价的整数倍。</p>
<h5 id="报价单位"><a href="#报价单位" class="headerlink" title="报价单位"></a>报价单位</h5><p>指在公开竞价过程中对期货合约报价所使用的单位，即每计量单位的货币价格，”100元/吨”。</p>
<h5 id="每日价格最大波动限制"><a href="#每日价格最大波动限制" class="headerlink" title="每日价格最大波动限制"></a>每日价格最大波动限制</h5><p>每日价格最大波动限制规定了期货合约在一个交易日中的交易价格波动不得高于或者低于规定的涨跌幅度。</p>
<h5 id="合约交割月份"><a href="#合约交割月份" class="headerlink" title="合约交割月份"></a>合约交割月份</h5><p>指某种期货合约到期交割的月份</p>
<h5 id="交易时间"><a href="#交易时间" class="headerlink" title="交易时间"></a>交易时间</h5><p>只能在规定的交易时间内进行交易</p>
<h5 id="最后交易日"><a href="#最后交易日" class="headerlink" title="最后交易日"></a>最后交易日</h5><p>在交割月份中进行交易的最后一个交易日，过了期限必须按规定进行实物交割或现金交割。</p>
<h5 id="交割日期"><a href="#交割日期" class="headerlink" title="交割日期"></a>交割日期</h5><p>指合约标的物所有权进行转移，以实物交割或现金交割方式了结未平仓合约的时间。</p>
<h4 id="交割等级"><a href="#交割等级" class="headerlink" title="交割等级"></a>交割等级</h4><p>合约标的物质量等级</p>
<h5 id="交割地点"><a href="#交割地点" class="headerlink" title="交割地点"></a>交割地点</h5><p>实物交割指定地点</p>
<h5 id="交易手续费"><a href="#交易手续费" class="headerlink" title="交易手续费"></a>交易手续费</h5><p>成交合约金额的一定比例或按成交手数收取费用</p>
<h5 id="交割方式"><a href="#交割方式" class="headerlink" title="交割方式"></a>交割方式</h5><p>实物交割和现金交割。</p>
<h5 id="交易代码"><a href="#交易代码" class="headerlink" title="交易代码"></a>交易代码</h5><p>交易所对每一期货品种都规定了交易代码。</p>
<h4 id="期货市场基本制度"><a href="#期货市场基本制度" class="headerlink" title="期货市场基本制度"></a>期货市场基本制度</h4><h4 id="1-保障金制度"><a href="#1-保障金制度" class="headerlink" title="1 保障金制度"></a>1 保障金制度</h4><h4 id="2-保障金制度一般特点"><a href="#2-保障金制度一般特点" class="headerlink" title="2 保障金制度一般特点"></a>2 保障金制度一般特点</h4><ul>
<li>保障金要求与其面临的风险相对应，风险越大，保障金越高。</li>
<li>交易所根据合约特点设定最低保障金标准。</li>
<li>交易所或结算机构只向其会员收取保证金，会员期货公司向其客户收取保证金。</li>
</ul>
<h4 id="3-当日无负债结算制度"><a href="#3-当日无负债结算制度" class="headerlink" title="3 当日无负债结算制度"></a>3 当日无负债结算制度</h4><p>当天的盈亏进行结算，并进行资金划转。</p>
<h4 id="4-涨跌停板制度"><a href="#4-涨跌停板制度" class="headerlink" title="4 涨跌停板制度"></a>4 涨跌停板制度</h4><h4 id="5-持仓限额及大户报告制度"><a href="#5-持仓限额及大户报告制度" class="headerlink" title="5 持仓限额及大户报告制度"></a>5 持仓限额及大户报告制度</h4><p>持仓额度指交易所规定会员或客户可以持有的，按单位计算的某一合约投机头寸的最大数额。</p>
<p>大户报告制度指当交易所会员或客户某品种某合约持仓达到交易所规定的持仓报告标准时，会员或客户应向交易所报告。</p>
<h4 id="6-强行平仓制度"><a href="#6-强行平仓制度" class="headerlink" title="6 强行平仓制度"></a>6 强行平仓制度</h4><ul>
<li>1 交易保证金不足而强行平仓</li>
<li>2 违反持仓限额制度而实行强行平仓</li>
</ul>
<h4 id="7-信息披露制度"><a href="#7-信息披露制度" class="headerlink" title="7 信息披露制度"></a>7 信息披露制度</h4><ul>
<li>即时行情</li>
<li>持仓量，成交量排名情况</li>
<li>期货交易所交易规则及其实施细规定的其他信息</li>
</ul>
<h3 id="期货交易流程"><a href="#期货交易流程" class="headerlink" title="期货交易流程"></a>期货交易流程</h3><h4 id="开户"><a href="#开户" class="headerlink" title="开户"></a>开户</h4><p>申请开户 -&gt; 阅读”期货交易风险说明书”并签字确认 -&gt; 签署”期货经纪合同书” -&gt; 申请交易编码并确认资金账号</p>
<h4 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h4><p>下单，是指客户在每笔交易前向期货公司业务人员下达交易指令，说明拟买卖合约的种类，数量价格</p>
<h5 id="1市价指令"><a href="#1市价指令" class="headerlink" title="1市价指令"></a>1市价指令</h5><p>按当时市场价格即刻成交的指令，以当时市场上可执行的最好交个达成交易。</p>
<h5 id="2限价指令"><a href="#2限价指令" class="headerlink" title="2限价指令"></a>2限价指令</h5><p>客户必须指明具体的价位，必须按限定的价格或更好的价格成交的指令。</p>
<h5 id="3止损指令"><a href="#3止损指令" class="headerlink" title="3止损指令"></a>3止损指令</h5><p>降到这一价位，出手，防止配的更多。</p>
<h5 id="4停止限价指令"><a href="#4停止限价指令" class="headerlink" title="4停止限价指令"></a>4停止限价指令</h5><p>当价格达到客户预设的触发价时，变为限价指令。</p>
<h5 id="5-触价指令"><a href="#5-触价指令" class="headerlink" title="5 触价指令"></a>5 触价指令</h5><h5 id="6-限时指令"><a href="#6-限时指令" class="headerlink" title="6 限时指令"></a>6 限时指令</h5><h5 id="7-长效指令"><a href="#7-长效指令" class="headerlink" title="7 长效指令"></a>7 长效指令</h5><h5 id="8-套利指令"><a href="#8-套利指令" class="headerlink" title="8 套利指令"></a>8 套利指令</h5><h5 id="9-取消指令"><a href="#9-取消指令" class="headerlink" title="9 取消指令"></a>9 取消指令</h5><h4 id="竞价"><a href="#竞价" class="headerlink" title="竞价"></a>竞价</h4><p>竞价方式主要有公开喊价方式和计算机撮合成交两种方式。</p>
<h3 id="期权-1"><a href="#期权-1" class="headerlink" title="期权"></a>期权</h3><p>期权也称选择权，是指期权的买方有权在约定的期限内。按照事先确定的价格，买入或卖出一定数量某种特定商品或金融指标的权利。</p>
<h4 id="期权基本要素"><a href="#期权基本要素" class="headerlink" title="期权基本要素"></a>期权基本要素</h4><ul>
<li>期权的价格又称权利金，期权费和保险费。</li>
<li>标的资产又称标的物(买入卖出的资产)。</li>
<li>行权方向，买入和卖出两种。</li>
<li>行权方式，指期权合约规定的期权多头可以执行期权的时间，到期日才执行的期权和在期权有效期内的任何时间都可以执行的期权。</li>
<li>执行价格又称履约价格，行权价格。</li>
<li>最后交易日是期权合约能在交易所交易的最后日期。</li>
<li>期权到期日，指期权买方可以执行期权的最后日期。</li>
</ul>
<h4 id="期权交易"><a href="#期权交易" class="headerlink" title="期权交易"></a>期权交易</h4><p>期权交易或买卖的对象是期权合约，买方支付期权费获得期权。在规定的行权期限内，买方可以行使权力买进或卖出标的资产。</p>
<h4 id="建仓和头寸了结"><a href="#建仓和头寸了结" class="headerlink" title="建仓和头寸了结"></a>建仓和头寸了结</h4><p>建仓方向和头寸类型：</p>
<ul>
<li>开仓买入期权，也称建立期权多头头寸，称交易者为期权多头。</li>
<li>开仓卖出期权，也称建立期权空头头寸，称交易者为期权空头。</li>
</ul>
<p>了结期权头寸的方式，期权多头可以通过对冲平仓，行权等方式将期权头寸了结，也可以持有期权至合约到期。当期权多头行权时，空头必须履约，即以履约的方式了结期权头寸。如果多头没有行权，则空头也可以通过对冲平仓了结期权头寸，或持有期权至合约到期。</p>
<h4 id="期权的特点"><a href="#期权的特点" class="headerlink" title="期权的特点"></a>期权的特点</h4><h5 id="买卖双方的权利义务不同"><a href="#买卖双方的权利义务不同" class="headerlink" title="买卖双方的权利义务不同"></a>买卖双方的权利义务不同</h5><p>期权交易是权力的买卖，期权买方支付期权费获得权力，卖方将权力出售给买方从而拥有了履约的义务。</p>
<h5 id="买卖双方的收益和损失特征不同"><a href="#买卖双方的收益和损失特征不同" class="headerlink" title="买卖双方的收益和损失特征不同"></a>买卖双方的收益和损失特征不同</h5><p>买方损失有限，最多为支付的期权费，收益可能很大。卖方最大收益为获得的期权费，损失可能超大。</p>
<h5 id="对买卖双方保证金缴纳的规定不同"><a href="#对买卖双方保证金缴纳的规定不同" class="headerlink" title="对买卖双方保证金缴纳的规定不同"></a>对买卖双方保证金缴纳的规定不同</h5><p>卖方损失巨大，必须缴纳保证金作为履约担保。</p>
<h5 id="独特的非线性损益结构"><a href="#独特的非线性损益结构" class="headerlink" title="独特的非线性损益结构"></a>独特的非线性损益结构</h5><h4 id="期权的基本类型"><a href="#期权的基本类型" class="headerlink" title="期权的基本类型"></a>期权的基本类型</h4><p>按行权时间区分：</p>
<h5 id="美式期权"><a href="#美式期权" class="headerlink" title="美式期权"></a>美式期权</h5><p>指期权买方在期权到期日前的人合计一日都可以形式权力的期权。</p>
<h5 id="欧式期权"><a href="#欧式期权" class="headerlink" title="欧式期权"></a>欧式期权</h5><p>指期权买方只能在期权到期日行使权力的期权。</p>
<p>按行权方向区分：</p>
<h5 id="看涨期权-买权-认购期权"><a href="#看涨期权-买权-认购期权" class="headerlink" title="看涨期权(买权/认购期权)"></a>看涨期权(买权/认购期权)</h5><p>指买方支付合约费从而拥有在合约期限内或特定时间内，安特定价格向期权卖方买入一定数量标的资产的权力。</p>
<h5 id="看跌期权-卖权-认沽期权"><a href="#看跌期权-卖权-认沽期权" class="headerlink" title="看跌期权(卖权/认沽期权)"></a>看跌期权(卖权/认沽期权)</h5><p>按标的资产类型区分：</p>
<h5 id="商品期权"><a href="#商品期权" class="headerlink" title="商品期权"></a>商品期权</h5><h5 id="金融期权"><a href="#金融期权" class="headerlink" title="金融期权"></a>金融期权</h5><p>按市场类型区分：<br>在交易所上市交易的期权成为场内期权也称为交易所期权；在交易所之外交易的期权成为场外期权。</p>
<h5 id="场内期权"><a href="#场内期权" class="headerlink" title="场内期权"></a>场内期权</h5><h5 id="场外期权"><a href="#场外期权" class="headerlink" title="场外期权"></a>场外期权</h5><h4 id="期权价格及影响因素"><a href="#期权价格及影响因素" class="headerlink" title="期权价格及影响因素"></a>期权价格及影响因素</h4><h4 id="期权内涵-内在-价值"><a href="#期权内涵-内在-价值" class="headerlink" title="期权内涵(内在)价值"></a>期权内涵(内在)价值</h4><p>期权内涵价值有无及大小取决于标的物的资产价格与执行价格的关系。</p>
<p>看涨期权的内涵价值 = 标的资产价格 - 执行价格</p>
<p>看跌期权的内涵价值 = 执行价格 - 标的资产价格</p>
<p>根据内涵价值计算结果的不同，可以将期权分为实值期权，虚值期权和平值期权；</p>
<h4 id="实值，平值与虚值期权的关系"><a href="#实值，平值与虚值期权的关系" class="headerlink" title="实值，平值与虚值期权的关系"></a>实值，平值与虚值期权的关系</h4><p><img src="http://oc4zuck5v.bkt.clouddn.com/%E6%9C%9F%E8%B4%A7-%E5%AE%9E%E5%80%BC.png" alt=""></p>
<h4 id="期货的时间价值"><a href="#期货的时间价值" class="headerlink" title="期货的时间价值"></a>期货的时间价值</h4><p>标的资产价格波动率越高，期权的时间价值应该越大。</p>
<p>时间价值 = 权利金 - 内涵价值</p>
<ul>
<li>平值期权和虚值期权的时间价值总是大于等于0.</li>
<li>美式期权的时间价值总是大于等于0.</li>
<li>实值欧式看跌期权的时间价值可能小于0.</li>
</ul>
<h3 id="交易期权的基本策略"><a href="#交易期权的基本策略" class="headerlink" title="交易期权的基本策略"></a>交易期权的基本策略</h3><p>期权交易的最基本策略有买进看涨期权，买进看跌期权，卖出看涨期权，卖出看跌期权四种。</p>
<h4 id="买进看涨期权"><a href="#买进看涨期权" class="headerlink" title="买进看涨期权"></a>买进看涨期权</h4><p>目的：预期价格上涨而买进。</p>
<h5 id="损益分析"><a href="#损益分析" class="headerlink" title="损益分析"></a>损益分析</h5><p>注：C为期权的价格，X为执行价格，S为标的资产价格。</p>
<p>损益平衡点 = X + C </p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="期权头寸"><a href="#期权头寸" class="headerlink" title="期权头寸"></a>期权头寸</h4><p>买方：期权的多头。</p>
<p>买方：期权的空头。</p>
<h4 id="期权四种头寸"><a href="#期权四种头寸" class="headerlink" title="期权四种头寸"></a>期权四种头寸</h4><ul>
<li>看跌期权多头</li>
<li>看涨期权多头</li>
<li>看跌期权空头</li>
<li>看涨期权空头</li>
</ul>
<h4 id="标的资产"><a href="#标的资产" class="headerlink" title="标的资产"></a>标的资产</h4><p>股票/货币/指数/期货期权</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-独立思考" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/26/独立思考/" class="article-date">
  	<time datetime="2017-05-25T16:00:00.000Z" itemprop="datePublished">2017-05-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/26/独立思考/">
        独立思考
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习批判性思维，会使你认清很多常人无法辨识的陷阱，也可以加强你的辩论能力。但是要切记，学习批判性思维不是为了赢，而是为了更好接近真理或者追求真理。</p>
<h4 id="SWOT分析"><a href="#SWOT分析" class="headerlink" title="SWOT分析"></a>SWOT分析</h4><ul>
<li>Strength （优势）—— 内部的有利因素</li>
<li>Weakness （劣势）—— 内部的不利因素</li>
<li>Opportunity（机会）—— 外部的有利因素</li>
<li>Threat （威胁）—— 外部的不利因素</li>
</ul>
<p>图片来自网络</p>
<p><img src="http://photocdn.sohu.com/20150708/mp21797287_1436323836502_5.jpeg" alt=""></p>
<h4 id="问题策略"><a href="#问题策略" class="headerlink" title="问题策略"></a>问题策略</h4><p>问题 : 想跳槽，找不到满意的工作。<br>对策 : 找心仪的公司的朋友内推，将简历发送到招聘网站，准备好面试复习。</p>
<h4 id="大部分人思考模式成长的四个过程"><a href="#大部分人思考模式成长的四个过程" class="headerlink" title="大部分人思考模式成长的四个过程"></a>大部分人思考模式成长的四个过程</h4><ul>
<li>1 轻信思维(依赖)</li>
<li>2 盲从思维(从众)</li>
<li>3 愤青思维(逆反)</li>
<li>4 理性思维(成熟)</li>
</ul>
<h4 id="抬杠，辩论不是批判性思维是偏激。一个人的辩论如果不是为了达到某个目的或者真相，只是为了赢，那无论赢多少次也不会成为一个理性的批判性思考者"><a href="#抬杠，辩论不是批判性思维是偏激。一个人的辩论如果不是为了达到某个目的或者真相，只是为了赢，那无论赢多少次也不会成为一个理性的批判性思考者" class="headerlink" title="抬杠，辩论不是批判性思维是偏激。一个人的辩论如果不是为了达到某个目的或者真相，只是为了赢，那无论赢多少次也不会成为一个理性的批判性思考者"></a>抬杠，辩论不是批判性思维是偏激。一个人的辩论如果不是为了达到某个目的或者真相，只是为了赢，那无论赢多少次也不会成为一个理性的批判性思考者</h4><h4 id="自己各阶段事件表"><a href="#自己各阶段事件表" class="headerlink" title="自己各阶段事件表"></a>自己各阶段事件表</h4><p>轻信阶段：18岁之前<br>盲从阶段：22岁之前<br>愤青阶段：26岁之前<br>理性阶段：正在修炼中</p>
<h4 id="思考动作流"><a href="#思考动作流" class="headerlink" title="思考动作流"></a>思考动作流</h4><ul>
<li>1 现在发生了什么，这是真的吗？(记录事实)</li>
<li>2 这真的是与我相关的事吗?(确定影响范围)</li>
<li>3 说服自己与某件事有关或无关是否自欺欺人?(摆脱情感判断)</li>
<li>4 我需要集中尽力来完成这件事吗?(判断事情的紧急度)</li>
<li>5 失败的后果严重吗?(判断事情的重要度)</li>
<li>6 我该如何准备?(构思具体对策，可展开多种不同方法)</li>
<li>7 我如何做才能做得更好?(对自己的对策进行评估)</li>
</ul>
<h4 id="优质思考者特征"><a href="#优质思考者特征" class="headerlink" title="优质思考者特征"></a>优质思考者特征</h4><ul>
<li>1 能找到关进问题和困难，并能清晰准确的表达这些问题。</li>
<li>2 能快速收集大量信息，并用简练的语言表达这些信息。</li>
<li>3 能提出有效的解决方案，并有标准检验是否有效。</li>
<li>4 能在遇到复杂问题时，和他人有效的交换信息。</li>
<li>5 能在遇到阻碍的时候，找到可替代的解决方案，放弃现有选择。</li>
</ul>
<h4 id="搜索能力"><a href="#搜索能力" class="headerlink" title="搜索能力"></a>搜索能力</h4><ul>
<li>1 能够利用互联网快速筛选出自己需要的信息的能力。</li>
<li>2 利用互联网快速辨别信息真伪。</li>
<li>3 保护自己隐私的能力。</li>
</ul>
<h4 id="表达问题"><a href="#表达问题" class="headerlink" title="表达问题"></a>表达问题</h4><ul>
<li>1 我要表达的观点是什么？</li>
<li>2 有哪些资料，数据可以支撑我的观点？</li>
<li>3 这些资料和数据有足够的说服力吗？</li>
<li>4 有哪些资料和数据可以削弱我的观点？</li>
<li>5 有哪些概念和定义需要澄清？</li>
<li>6 我该用什么样的呈现方式表达自己？</li>
<li>7 我呈现的逻辑有误吗？</li>
<li>8 什么样的语气更加合适？会不会太绝对？</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-自控力" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/自控力/" class="article-date">
  	<time datetime="2017-05-22T16:00:00.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/自控力/">
        自控力
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-我要做，我不要，我想要-什么事意志力？为什么意志力至关重要？"><a href="#第一章-我要做，我不要，我想要-什么事意志力？为什么意志力至关重要？" class="headerlink" title="第一章 我要做，我不要，我想要:什么事意志力？为什么意志力至关重要？"></a>第一章 我要做，我不要，我想要:什么事意志力？为什么意志力至关重要？</h3><p>意志力就是驾驭”我要做，我不要，我想要”这三种力量。</p>
<h4 id="认清两个自我"><a href="#认清两个自我" class="headerlink" title="认清两个自我"></a>认清两个自我</h4><p>冲动的自己和控制的自己的竞争。</p>
<h4 id="训练大脑，增强意志力"><a href="#训练大脑，增强意志力" class="headerlink" title="训练大脑，增强意志力"></a>训练大脑，增强意志力</h4><h4 id="冥想：专心呼吸法"><a href="#冥想：专心呼吸法" class="headerlink" title="冥想：专心呼吸法"></a>冥想：专心呼吸法</h4><ul>
<li>1 原地不动，安静坐好。(冥想时一定不能烦躁)</li>
<li>2 注意你的呼吸。(吸气时在脑海里默念吸，呼气时在脑海里默念呼，走神时，及时调整)</li>
<li>3 感受呼吸，弄清楚自己是怎么走神的。(几分钟后不在默念，去感受空气从鼻子进入在呼出，感觉胸部的起伏)</li>
<li>4 开始时每天坚持5分钟，熟练后可增至10-15分钟。</li>
<li>5 冥想不是让你什么都不想，而是让你不要太分心。</li>
</ul>
<h3 id="第二章-意志力的本能-人生来就能抵制奶酪和蛋糕的诱惑"><a href="#第二章-意志力的本能-人生来就能抵制奶酪和蛋糕的诱惑" class="headerlink" title="第二章 意志力的本能:人生来就能抵制奶酪和蛋糕的诱惑"></a>第二章 意志力的本能:人生来就能抵制奶酪和蛋糕的诱惑</h3><h4 id="通过呼吸实现自控"><a href="#通过呼吸实现自控" class="headerlink" title="通过呼吸实现自控"></a>通过呼吸实现自控</h4><p>将呼吸频率降到每分钟4-6次，也就是每次呼吸用10-15秒。每天20分钟锻炼。</p>
<h4 id="锻炼提高生理上的意志力储备"><a href="#锻炼提高生理上的意志力储备" class="headerlink" title="锻炼提高生理上的意志力储备"></a>锻炼提高生理上的意志力储备</h4><h4 id="足够睡眠"><a href="#足够睡眠" class="headerlink" title="足够睡眠"></a>足够睡眠</h4><h4 id="自控力太强的代价"><a href="#自控力太强的代价" class="headerlink" title="自控力太强的代价"></a>自控力太强的代价</h4><p>长时间的自控就像压力一样，会削弱免疫系统。</p>
<h4 id="恢复意志力"><a href="#恢复意志力" class="headerlink" title="恢复意志力"></a>恢复意志力</h4><ul>
<li>放松：躺下，枕头垫着膝盖，腿稍微抬起。</li>
</ul>
<h3 id="第三章累到无力抵抗-为什么自控力和肌肉一样有极限？"><a href="#第三章累到无力抵抗-为什么自控力和肌肉一样有极限？" class="headerlink" title="第三章累到无力抵抗:为什么自控力和肌肉一样有极限？"></a>第三章累到无力抵抗:为什么自控力和肌肉一样有极限？</h3><p>自控力的消失，24小时没吸烟的人可能大吃一顿冰淇淋，节食的人可能背着配偶偷情。我们只有一定量的意志力，一旦你将它消耗殆尽，你在诱惑面前就会毫无防备力。</p>
<h4 id="自控力就像肌肉一样有极限"><a href="#自控力就像肌肉一样有极限" class="headerlink" title="自控力就像肌肉一样有极限"></a>自控力就像肌肉一样有极限</h4><p>它被使用后会渐渐疲惫，需要时间来恢复。很多你认为不需要意志力的事情，都要依靠这种有限的能量甚至要消耗能量。</p>
<h4 id="意志力波动"><a href="#意志力波动" class="headerlink" title="意志力波动"></a>意志力波动</h4><p>自控力从早上到晚上会逐渐减弱。</p>
<ul>
<li>把重要的事情放在第一位(最早处理)。</li>
</ul>
<h4 id="意志力实验-锻炼意志力"><a href="#意志力实验-锻炼意志力" class="headerlink" title="意志力实验:锻炼意志力"></a>意志力实验:锻炼意志力</h4><ul>
<li>增强”我不要”的力量：不要随便发誓，坐下的时候不要翘脚，用不常用的手进行日常活动，比如吃饭和开门。</li>
<li>增强”我想要”的力量：每天都做一些平时不常做的事。</li>
<li>增强自我监控的能力:认真记录一件你平常不关注的事。</li>
</ul>
<p>发现你的”我想要”的力量，发现自己最重要的”我想要”的力量，也就是你脆弱的时候给你动力的东西。</p>
<h4 id="只要你愿意，你就有意志力"><a href="#只要你愿意，你就有意志力" class="headerlink" title="只要你愿意，你就有意志力"></a>只要你愿意，你就有意志力</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>自控力就像肌肉一样有极限，自控力用得太多会疲倦，但坚持训练能增强自控力。</p>
<h3 id="第四章-容忍罪恶-为何善行之后会有恶性？"><a href="#第四章-容忍罪恶-为何善行之后会有恶性？" class="headerlink" title="第四章 容忍罪恶:为何善行之后会有恶性？"></a>第四章 容忍罪恶:为何善行之后会有恶性？</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Kotlin" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/19/Kotlin/" class="article-date">
  	<time datetime="2017-05-18T16:00:00.000Z" itemprop="datePublished">2017-05-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/19/Kotlin/">
        Kotlin
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。<br>Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。</p>
<h3 id="使用-Kotlin-进行-Android-开发"><a href="#使用-Kotlin-进行-Android-开发" class="headerlink" title="使用 Kotlin 进行 Android 开发"></a>使用 Kotlin 进行 Android 开发</h3><ul>
<li>兼容性：Kotlin 与 JDK 6 完全兼容，保障了 Kotlin 应用程序可以在较旧的 Android 设备上运行而无任何问题。Kotlin 工具在 Android Studio 中会完全支持，并且兼容 Android 构建系统。</li>
<li>性能：由于非常相似的字节码结构，Kotlin 应用程序的运行速度与 Java 类似。 随着 Kotlin 对内联函数的支持，使用 lambda 表达式的代码通常比用 Java 写的代码运行得更快。</li>
<li>互操作性：Kotlin 可与 Java 进行 100％ 的互操作，允许在 Kotlin 应用程序中使用所有现有的 Android 库 。这包括注解处理，所以数据绑定和 Dagger 也是一样。</li>
<li>占用：Kotlin 具有非常紧凑的运行时库，可以通过使用 ProGuard 进一步减少。 在实际应用程序中，Kotlin 运行时 只增加几百个方法以及 .apk 文件不到 100K 大小。</li>
</ul>
<h3 id="AS中使用"><a href="#AS中使用" class="headerlink" title="AS中使用"></a>AS中使用</h3><h4 id="在主模块中配置-AS3-0中默认支持kotlin语法-："><a href="#在主模块中配置-AS3-0中默认支持kotlin语法-：" class="headerlink" title="在主模块中配置(AS3.0中默认支持kotlin语法)："></a>在主模块中配置(AS3.0中默认支持kotlin语法)：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'kotlin-android'</span><br><span class="line">apply plugin: 'kotlin-android-extensions'</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">compile "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"</span><br></pre></td></tr></table></figure>
<p>kotlin-android-extensions：是一个编译器扩展， 可以让你摆脱代码中的 findViewById() 调用，并将其替换为合成的编译器生成的 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"><span class="comment">//直接id访问</span></span><br><span class="line">tv_title.text = <span class="string">"hello kotlin"</span></span><br></pre></td></tr></table></figure>
<h4 id="java-转换为kotlin文件"><a href="#java-转换为kotlin文件" class="headerlink" title="java 转换为kotlin文件"></a>java 转换为kotlin文件</h4><p>Main menu -&gt; Code -&gt; Convert Java File to Kotlin File</p>
<p>快捷键：command + alt + shift + K </p>
<h3 id="kotlin-语法"><a href="#kotlin-语法" class="headerlink" title="kotlin 语法"></a>kotlin 语法</h3><h4 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h4><p>类声明由类名、类头（指定其类型参数、主 构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类继承使用关键字 ':'</span></span><br><span class="line"><span class="comment">//类上的 open 标注与 Java 中 final 相反，它允许其他类 从这个类继承。默认情况下，在 Kotlin 中所有的类都是 final</span></span><br><span class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    open val x: Int get &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar1 : Foo() &#123;</span><br><span class="line">    override val x: Int = ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person constructor(firstName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="新建类对象"><a href="#新建类对象" class="headerlink" title="新建类对象"></a>新建类对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意 Kotlin 并没有 new 关键字。</span></span><br><span class="line">val invoice = Invoice()</span><br></pre></td></tr></table></figure>
<h5 id="覆盖方法-属性"><a href="#覆盖方法-属性" class="headerlink" title="覆盖方法/属性"></a>覆盖方法/属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function">open fun <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">fun <span class="title">nv</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived() : Base() &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    open val x: Int get &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar1 : Foo() &#123;</span><br><span class="line">    override val x: Int = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用data 关键字自动生成get/set和toString()方法</span></span><br><span class="line"><span class="function">data class <span class="title">UserDto</span><span class="params">(var name: String, var sex: String, var age: Int)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>Kotlin 中的函数使用 fun 关键字声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">double</span><span class="params">(x: Int)</span>: Int </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h4><p><img src="http://oc4zuck5v.bkt.clouddn.com/kotlin.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-gradle 配置信息详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/09/gradle 配置信息详解/" class="article-date">
  	<time datetime="2017-05-08T16:00:00.000Z" itemprop="datePublished">2017-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/09/gradle 配置信息详解/">
        gradle 配置信息详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>一个项目有一个setting.gradle、包括一个顶层的 build.gradle文件、每个Module 都有自己的一个build.gradle文件。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20160902/20160902211134_505.png?_=5855774" alt=""></p>
<h4 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h4><p>这个setting文件定义了哪些module 应该被加入到编译过程，对于单个module 的项目可以不用需要这个文件，但是对于 multimodule 的项目我们就需要这个文件，否则gradle 不知道要加载哪些项目。这个文件的代码在初始化阶段就会被执行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include(':app',</span><br><span class="line">    ':Provider',</span><br><span class="line">    ':data',</span><br><span class="line">    ':Quotation',</span><br><span class="line">    ':Tools',</span><br><span class="line">    ':Notification',</span><br><span class="line">    ':gdt',</span><br><span class="line">    ':im',</span><br><span class="line">    ':BloomplusTradeV3',</span><br><span class="line">    ':easechat',</span><br><span class="line">    ':reddot',</span><br><span class="line">    ':trade')</span><br></pre></td></tr></table></figure>
<h4 id="顶层的build-gradle"><a href="#顶层的build-gradle" class="headerlink" title="顶层的build.gradle"></a>顶层的build.gradle</h4><p>顶层的build.gradle文件的配置最终会被应用到所有项目中。它典型的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath 'com.android.tools.build:gradle:1.2.3'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects&#123;</span><br><span class="line">    repositories&#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Repositories:epositories 就是代码仓库，这个相信大家都知道，我们平时的添加的一些 dependency 就是从这里下载的，Gradle 支持三种类型的仓库：Maven,Ivy和一些静态文件或者文件夹。在编译的执行阶段，gradle 将会从仓库中取出对应需要的依赖文件，当然，gradle 本地也会有自己的缓存，不会每次都去取这些依赖。</li>
<li>buildscript：定义了 Android 编译工具的类路径。repositories中,jCenter是一个著名的 Maven 仓库。</li>
<li>allprojects:中定义的属性会被应用到所有 moudle 中，但是为了保证每个项目的独立性，我们一般不会在这里面操作太多共有的东西。</li>
</ul>
<h4 id="每个项目单独的-build-gradle"><a href="#每个项目单独的-build-gradle" class="headerlink" title="每个项目单独的 build.gradle"></a>每个项目单独的 build.gradle</h4><p>针对每个moudle 的配置，如果这里的定义的选项和顶层build.gradle定义的相同，后者会被覆盖。典型的 配置内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion globalConfiguration.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion globalConfiguration.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId globalConfiguration.android.applicationId</span><br><span class="line">        minSdkVersion globalConfiguration.android.minSdkVersion</span><br><span class="line">        targetSdkVersion globalConfiguration.android.targetSdkVersion</span><br><span class="line">        versionCode APP_VERSION_CODE</span><br><span class="line">        versionName APP_VERSION</span><br><span class="line">        manifestPlaceholders = [</span><br><span class="line">                PACKAGE_NAME: globalConfiguration.android.applicationId</span><br><span class="line">        ]</span><br><span class="line">        multiDexEnabled true</span><br><span class="line">        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"</span><br><span class="line">    &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias "YtxAegis"</span><br><span class="line">            keyPassword "ytxaegis"</span><br><span class="line">            storeFile file("../key_store.jks")</span><br><span class="line">            storePassword "ytxaegis"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        def BOOLEAN = "boolean"</span><br><span class="line">        def TRUE = "true"</span><br><span class="line">        def FALSE = "false"</span><br><span class="line">        def ENV_DEBUG = "ENV_DEBUG"</span><br><span class="line">        def ENABLE_LOG = "ENABLE_LOG"</span><br><span class="line">        def PERFORMANCE_DEBUG = "PERFORMANCE_DEBUG"</span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField BOOLEAN, ENV_DEBUG, FALSE</span><br><span class="line">            buildConfigField BOOLEAN, ENABLE_LOG, FALSE</span><br><span class="line">            buildConfigField BOOLEAN, PERFORMANCE_DEBUG, FALSE</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'</span><br><span class="line">            signingConfig signingConfigs.config</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            buildConfigField BOOLEAN, ENV_DEBUG, TRUE</span><br><span class="line">            buildConfigField BOOLEAN, ENABLE_LOG, TRUE</span><br><span class="line">            buildConfigField BOOLEAN, PERFORMANCE_DEBUG, TRUE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError false</span><br><span class="line">    &#125;</span><br><span class="line">    packagingOptions &#123;</span><br><span class="line">        exclude 'lib/arm64-v8a/librealm-jni.so'</span><br><span class="line">        exclude 'lib/mips/librealm-jni.so'</span><br><span class="line">        exclude 'lib/x86_64/librealm-jni.so'</span><br><span class="line">        exclude 'lib/x86/librealm-jni.so'</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line"></span><br><span class="line">        def NORMAL_TYPE = "\"normal_type\""</span><br><span class="line">        def QIHUO_TYPE = "\"qihuo_type\""</span><br><span class="line">        def PRODUCT_TYPE = "PRODUCT_TYPE"</span><br><span class="line">        def STRING = "String"</span><br><span class="line">        normal &#123;</span><br><span class="line">            buildConfigField STRING, PRODUCT_TYPE, NORMAL_TYPE</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qihuo &#123;</span><br><span class="line">            buildConfigField STRING, PRODUCT_TYPE, QIHUO_TYPE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(include: ['*.jar'], dir: 'libs')</span><br><span class="line"></span><br><span class="line">    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123;</span><br><span class="line">        exclude group: 'com.android.support', module: 'support-annotations'</span><br><span class="line">    &#125;)</span><br><span class="line">    testCompile 'junit:junit:4.12'</span><br><span class="line">    testCompile 'org.mockito:mockito-core:1.10.19'</span><br><span class="line"></span><br><span class="line">    rootProject.dependenciesMethod rootProject.ext.appDps, &#123; type, library, key -&gt;</span><br><span class="line">        if (type == 'compile') &#123;</span><br><span class="line">            compile library</span><br><span class="line">        &#125; else if (type == 'debugCompile') &#123;</span><br><span class="line">            debugCompile library</span><br><span class="line">        &#125; else if (type == 'testCompile') &#123;</span><br><span class="line">            testCompile library</span><br><span class="line">        &#125; else if (type == 'apt') &#123;</span><br><span class="line">            apt library</span><br><span class="line">        &#125; else if (type == 'debuggableReleaseCompile') &#123;</span><br><span class="line">            debuggableReleaseCompile library</span><br><span class="line">        &#125; else if (type == 'debugProCompile') &#123;</span><br><span class="line">            debugProCompile library</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="apply-plugin"><a href="#apply-plugin" class="headerlink" title="apply plugin"></a>apply plugin</h5><p>第一行代码应用了Android 程序的gradle插件，作为Android 的应用程序，这一步是必须的，因为plugin中提供了Android 编译、测试、打包等等的所有task。</p>
<h5 id="android"><a href="#android" class="headerlink" title="android"></a>android</h5><p>这是编译文件中最大的代码块，关于android 的所有特殊配置都在这里，这就是又我们前面的声明的 plugin 提供的。</p>
<ul>
<li>productFlavors:做差异化打包，包括包名，资源等信息的差异化处理。</li>
<li>signingConfigs:签名信息</li>
</ul>
<h5 id="defaultConfig"><a href="#defaultConfig" class="headerlink" title="defaultConfig"></a>defaultConfig</h5><p>就是程序的默认配置，注意，如果在AndroidMainfest.xml里面定义了与这里相同的属性，会以这里的为主。这里最有必要要说明的是applicationId的选项：在我们曾经定义的AndroidManifest.xml中，那里定义的包名有两个用途：一个是作为程序的唯一识别ID,防止在同一手机装两个一样的程序；另一个就是作为我们R资源类的包名。在以前我们修改这个ID会导致所有用引用R资源类的地方都要修改。但是现在我们如果修改applicationId只会修改当前程序的ID,而不会去修改源码中资源文件的引用。</p>
<h5 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h5><p>定义了编译类型，针对每个类型我们可以有不同的编译配置，不同的编译配置对应的有不同的编译命令。默认的有debug、release 的类型。</p>
<h5 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h5><p>是属于gradle 的依赖配置。它定义了当前项目需要依赖的其他库。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-android 图形显示" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/08/android 图形显示/" class="article-date">
  	<time datetime="2017-05-07T16:00:00.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/android 图形显示/">
        图形显示
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自：<a href="https://juejin.im/post/590a91ceac502e0058258293" target="_blank" rel="noopener">博客</a></p>
<h3 id="绘制中的角色"><a href="#绘制中的角色" class="headerlink" title="绘制中的角色"></a>绘制中的角色</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><ul>
<li>CPU：Measure，Layout，纹理和多边形生成，发送纹理和多边形到GPU</li>
<li>GPU：将CPU生成的纹理和多边形进行栅格化以及合成</li>
</ul>
<p>Android 4.1 加入的VSync信号同步到上层以及三缓冲</p>
<h4 id="SurfaceFlinger-图形合成者"><a href="#SurfaceFlinger-图形合成者" class="headerlink" title="SurfaceFlinger-图形合成者"></a>SurfaceFlinger-图形合成者</h4><p>作为上层应用的消费者，硬件层的生产者。负责图形的合成，和ActivityManagerService一样，是一个系统服务。</p>
<p>生产者将自己的内容绘制在对应的Surface内，接着，SufaceFlinger需要将所有上层对应的Surface内的图形进行合成。</p>
<h5 id="Surface："><a href="#Surface：" class="headerlink" title="Surface："></a>Surface：</h5><ul>
<li>对应上层的一个Window（对话框、Activity、状态栏）</li>
<li>作为上层图形绘制的画板</li>
<li>Canvas是画笔，上层通过调用Canvas的API向Surface上绘制图形</li>
<li>Surface内部存在多个缓冲区，形成一个BufferQueue</li>
</ul>
<p><img src="https://dn-mhke0kuv.qbox.me/08d0142d954b365dd8f0.png" alt="surface"></p>
<p>Surface内部提供一个BufferQueue，与上层和SurfaceFlinger形成一个生产者消费者模型，上层对应Producer，SurfaceFlinger对应Consumer。三者通过Buffer产生联系，每个Buffer都有四种状态：</p>
<ul>
<li>Free：可被上层使用</li>
<li>Dequeued：出列，正在被上层使用</li>
<li>Queued：入列，已完成上层绘制，等待SurfaceFlinger合成</li>
<li>Acquired：被获取，SurfaceFlinger正持有该Buffer进行合成</li>
</ul>
<p>Buffer的一次转移过程大致为：</p>
<ul>
<li>1 从BufferQueue转移到上层</li>
<li>2 上层绘制完成再放回BufferQueue</li>
<li>3 接着SurfaceFlinger再拿去合成</li>
<li>4 最后又放回BufferQueue</li>
</ul>
<p>如此循环，形成一个Buffer被循环使用的过程。</p>
<h4 id="显示屏"><a href="#显示屏" class="headerlink" title="显示屏"></a>显示屏</h4><p>显示屏上的内容，是从硬件帧缓冲区读取的，大致读取过程为：从Buffer的起始地址开始，从上往下，从左往右扫描整个Buffer，将内容映射到显示屏上。</p>
<p>当然，屏幕上的内容需要需要不断的更新，如果在同一个Buffer进行读取和写入（合成）操作，将会导致屏幕显示多帧内容。所以硬件层除了提供一个Buffer用于屏幕显示，还提供了一个Buffer用于后台的图形合成，也就是我们常说的双缓冲。</p>
<p><img src="https://dn-mhke0kuv.qbox.me/62bd216a289d49f6eb7d.png" alt=""></p>
<p>前缓冲区：用来显示内容到屏幕的帧缓冲区</p>
<p>后缓冲区：用于后台合成下一帧图形的帧缓冲区</p>
<p>屏幕刷新率（HZ）：代表屏幕在一秒内刷新屏幕的次数，Android手机一般为60HZ（也就是1秒刷新60帧，大约16.67毫秒刷新1帧）</p>
<p>系统帧速率（FPS）：代表了系统在一秒内合成的帧数，该值的大小由系统算法和硬件决定。</p>
<p>垂直同步（VSync）：当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，发出的一个同步信号，该信号用来切换前缓冲区和后缓冲区。</p>
<h3 id="Android绘制的主要流程"><a href="#Android绘制的主要流程" class="headerlink" title="Android绘制的主要流程"></a>Android绘制的主要流程</h3><p>生产者 -&gt; 中间处理 -&gt; 显示器</p>
<p>图形的传递是通过Buffer作为载体</p>
<ul>
<li>1 生产者负责生成surface对象并交付给SurfaceFlinger进行合成。</li>
<li>2 SurfaceFlinger将合成好的内容提交到屏幕的后缓冲区，等待屏幕的下一个垂直同步信号的到来，再显示到屏幕上。</li>
</ul>
<p>未加入的VSync信号同步到上层以及三缓冲的处理流程：</p>
<p><img src="https://dn-mhke0kuv.qbox.me/78c6579ffd792d84e129.jpg" alt=""></p>
<ul>
<li>1 CPU和GPU代表上层的绘制执行者</li>
<li>2 Composite代表的是SurfaceFlinger对多个Surface的合成</li>
<li>3 Background Buffer和Front Buffer分别代表的是硬件帧缓冲区中的前缓冲和后缓冲</li>
<li>4 显示屏扫描完一帧之后，会发出VSync信号来切换并显示下一帧</li>
</ul>
<p>上面的流程中，存在一个问题，屏幕的VSync信号只是用来控制帧缓冲区的切换，并未控制上层的绘制节奏，也就是说上层的生产节奏和屏幕的显示节奏是脱离的.</p>
<p>google在Android 4.1系统中加入了上层接收垂直同步信号的逻辑，大致流程如下：</p>
<p><img src="https://dn-mhke0kuv.qbox.me/60c10f0847f270b5c10b.png" alt=""></p>
<p>屏幕在显示完一帧后，发出的垂直同步除了通知帧缓冲区的切换之外，该消息还会发送到上层，通知上层开始绘制下一帧。</p>
<p>只有等到第二个VSync信号来了之后，CPU才开始在绘制下一帧。如果CPU和GPU需要合成的图形太多，将会导致连续性的卡顿，如果CPU和GPU大部分时候都无法在16.6ms完成一帧的绘制，将会导致连续的卡顿现象。</p>
<h5 id="parallel-processing-and-triple-buffering"><a href="#parallel-processing-and-triple-buffering" class="headerlink" title="parallel processing and triple buffering"></a>parallel processing and triple buffering</h5><p>加入第三个Buffer，CPU和GPU还有SurfaceFlinger各占一个Buffer，并行处理图形：</p>
<p><img src="https://dn-mhke0kuv.qbox.me/47a962b7b7e477e031f2.png" alt=""></p>
<p>从上图可以看出，在第一个VSync到来时，尽管SurfaceFlinger占了一个Buffer，GPU又占了一个Buffer，CPU仍然可以在第三个Buffer中开始下一帧的计算，整个显示过程就开始时卡顿了一帧，之后都是流畅的。</p>
<p>当然系统并非一直开启三个Buffer，因为Buffer是需要消耗资源的，并且，我们会发现，上图中，GPU处理好的图形，需要跨越两个VSync信号，才能显示。这样的话，给用户的影响是一个延迟的现象。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-lambda 语法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/05/lambda 语法/" class="article-date">
  	<time datetime="2017-05-04T16:00:00.000Z" itemprop="datePublished">2017-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/05/lambda 语法/">
        lambda 语法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java8之前，我们实现一个简单的、仅有一个方法的接口或者将一个简单的功能作为方法参数时，需要实例化一个匿名类对象，但是它看起来臃肿且不直观。现在，Java8提供了Lambda表达式简化了上述操作。Lambda可以将方法或者代码片段作为数据进行参数传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;&#125;                <span class="comment">// No parameters; result is void</span></span><br><span class="line">() -&gt; <span class="number">42</span>                <span class="comment">// No parameters, expression body</span></span><br><span class="line">() -&gt; <span class="keyword">null</span>              <span class="comment">// No parameters, expression body</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;    <span class="comment">// No parameters, block body with return</span></span><br><span class="line">() -&gt; &#123; System.gc(); &#125;  <span class="comment">// No parameters, void block body</span></span><br><span class="line"></span><br><span class="line">() -&gt; &#123;                 <span class="comment">// Complex block body with returns</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">true</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      result *= i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          </span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> x) -&gt; x+<span class="number">1</span>              <span class="comment">// Single declared-type parameter</span></span><br><span class="line">(<span class="keyword">int</span> x) -&gt; &#123; <span class="keyword">return</span> x+<span class="number">1</span>; &#125;  <span class="comment">// Single declared-type parameter</span></span><br><span class="line">(x) -&gt; x+<span class="number">1</span>                  <span class="comment">// Single inferred-type parameter</span></span><br><span class="line">x -&gt; x+<span class="number">1</span>                    <span class="comment">// Parentheses optional for</span></span><br><span class="line">                            <span class="comment">// single inferred-type parameter</span></span><br><span class="line"></span><br><span class="line">(String s) -&gt; s.length()      <span class="comment">// Single declared-type parameter</span></span><br><span class="line">(Thread t) -&gt; &#123; t.start(); &#125;  <span class="comment">// Single declared-type parameter</span></span><br><span class="line">s -&gt; s.length()               <span class="comment">// Single inferred-type parameter</span></span><br><span class="line">t -&gt; &#123; t.start(); &#125;           <span class="comment">// Single inferred-type parameter</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x+y  <span class="comment">// Multiple declared-type parameters</span></span><br><span class="line">(x, y) -&gt; x+y          <span class="comment">// Multiple inferred-type parameters</span></span><br><span class="line">(x, <span class="keyword">int</span> y) -&gt; x+y    <span class="comment">// Illegal: can't mix inferred and declared types</span></span><br><span class="line">(x, <span class="keyword">final</span> y) -&gt; x+y  <span class="comment">// Illegal: no modifiers with inferred types</span></span><br></pre></td></tr></table></figure>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(e -&gt; &#123; aList.add(e); &#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-javascript 学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/19/javascript 学习/" class="article-date">
  	<time datetime="2017-04-18T16:00:00.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/javascript 学习/">
        javascript 学习笔记
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>JavaScript 有七种内置类型:</p>
<ul>
<li>空值(null)</li>
<li>未定义(undefined)</li>
<li>布尔值( boolean)</li>
<li>数字(number)</li>
<li>字符串(string)</li>
<li>对象(object)</li>
<li>符号(symbol，ES6 中新增)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          === <span class="string">"boolean"</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>            === <span class="string">"number"</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"42"</span>          === <span class="string">"string"</span>;</span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">life</span>: <span class="number">42</span> &#125;  === <span class="string">"object"</span>;</span><br><span class="line"><span class="comment">// ES6中新加入的类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">"symbol"</span>;  </span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">"object"</span>; <span class="comment">// true  </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* .. */</span> &#125; === <span class="string">"function"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h4><p>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。</p>
<h5 id="undefined-和-undeclared"><a href="#undefined-和-undeclared" class="headerlink" title="undefined 和 undeclared"></a>undefined 和 undeclared</h5><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明 过的变量，是 undeclared 的。</p>
<p>对于 undeclared(或者 not defined)变量，typeof 照样返回 “undefined”。这是因为typeof有一个特殊的安全防范机制。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">1</span>, <span class="string">"2"</span>, [<span class="number">3</span>] ];a.length;              <span class="comment">// 3</span>a[<span class="number">0</span>] === <span class="number">1</span>;           <span class="comment">// true</span>a[<span class="number">2</span>][<span class="number">0</span>] === <span class="number">3</span>;        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在创建“稀疏”数组(sparse array，即含有空白或空缺单元的数组)时要特别注意:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="number">0</span>] = <span class="number">1</span>;a[<span class="number">1</span>];       <span class="comment">// undefined</span>a.length;   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="string">"foobar"</span>] = <span class="number">2</span>;a.length; /<span class="number">2</span></span><br><span class="line">a[<span class="string">"foobar"</span>]; /<span class="number">2</span>a.foobar; /<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里有个问题需要特别注意，如果字符串键值能够被强制类型转换为十进制数字的话，它 就会被当作数字索引来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="string">"13"</span>] = <span class="number">42</span>;a.length; <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>
<h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><p>有时需要将类数组(一组通过数字索引的值)转换为真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from( <span class="built_in">arguments</span> );</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但<br>JavaScript 中的字符串和字符数组并不是一回事，最多只是看上去相似而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"foo"</span>;<span class="keyword">var</span> b = [<span class="string">"f"</span>,<span class="string">"o"</span>,<span class="string">"o"</span>];</span><br><span class="line"></span><br><span class="line">a.length;                           <span class="comment">// 3</span>b.length;                           <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a.indexOf( <span class="string">"o"</span> );                   <span class="comment">//1</span>b.indexOf( <span class="string">"o"</span> );                   <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.concat( <span class="string">"bar"</span> );</span><br><span class="line"><span class="keyword">var</span> d = b.concat( [<span class="string">"b"</span>,<span class="string">"a"</span>,<span class="string">"r"</span>] );  <span class="comment">// ["f","o","o","b","a","r"]</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>JavaScript 只有一种数值类型:number(数字)，包括“整数”和带小数的十进制数。</p>
<h5 id="数字的语法"><a href="#数字的语法" class="headerlink" title="数字的语法"></a>数字的语法</h5><p>数字前面的 0 可以省略: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 0.42;var b = .42;</span><br></pre></td></tr></table></figure>
<p>特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a * a;b;                  <span class="comment">// 2.5e+21</span><span class="keyword">var</span> c = <span class="number">1</span> / a;c;                  <span class="comment">// 2e-11</span></span><br></pre></td></tr></table></figure>
<h5 id="较小的数值"><a href="#较小的数值" class="headerlink" title="较小的数值"></a>较小的数值</h5><p>二进制浮点数最大的问题(不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此)，是 会出现如下情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>最常见的方法是设置一个误差范围值，通常称为“机器精度”(machine epsilon)，对<br>JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。</p>
<p>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前<br>的版本写 polyfill:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br></pre></td></tr></table></figure>
<h5 id="整数的安全范围"><a href="#整数的安全范围" class="headerlink" title="整数的安全范围"></a>整数的安全范围</h5><p>能够被“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为 Number.MAX_SAFE_INTEGER。 最 小 整 数 是 -9007199254740991， 在 ES6 中 被 定 义 为 Number. MIN_SAFE_INTEGER。</p>
<h5 id="整数检查"><a href="#整数检查" class="headerlink" title="整数检查"></a>整数检查</h5><p>要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42</span> );     <span class="comment">// true</span><span class="built_in">Number</span>.isInteger( <span class="number">42.000</span> ); <span class="comment">// true</span><span class="built_in">Number</span>.isInteger( <span class="number">42.3</span> );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Number</span>.MAX_SAFE_INTEGER );  <span class="comment">// true</span><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) ); <span class="comment">// false</span><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) - <span class="number">1</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="32-位有符号整数"><a href="#32-位有符号整数" class="headerlink" title="32 位有符号整数"></a>32 位有符号整数</h5><p>虽然整数最大能够达到 53 位，但是有些数字操作(如数位操作)只适用于 32 位数字， 所以这些操作中数字的安全范围就要小很多，变成从 Math.pow(-2,31)(-2147483648， 约-21 亿)到 Math.pow(2,31) - 1(2147483647，约 21 亿)。</p>
<h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><h5 id="不是值的值"><a href="#不是值的值" class="headerlink" title="不是值的值"></a>不是值的值</h5><p>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名<br>称既是类型也是值。</p>
<ul>
<li>null 指空值(empty value)</li>
<li>undefined 指没有值(missing value)</li>
</ul>
<p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而<br>undefined 却是一个标识符，可以被当作变量来使用和赋值。</p>
<h5 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h5><p>表达式void ___没有返回值，因此返回结果是undefined。void并不改变表达式的结果， 只是让表达式不返回值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="keyword">void</span> a, a ); <span class="comment">// undefined 42</span></span><br></pre></td></tr></table></figure>
<p>void 0来获得undefined(这主要源自C语言，当然使用void true或其他 void 表达式也是可以的)。void 0、void 1 和 undefined 之间并没有实质上的区别。</p>
<h5 id="特殊的数字NaN"><a href="#特殊的数字NaN" class="headerlink" title="特殊的数字NaN"></a>特殊的数字NaN</h5><p>如果数学运算的操作数不是数字类型(或者无法解析为常规的十进制或十六进制数字)， 就无法返回一个有效的数字，这种情况下返回值为 NaN。不是数字的数字”仍然是数字类型。NaN 是一个“警戒值”(sentinel value，有特殊用途的常规值)，用于指出数字类型中的错误 情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">"foo"</span>;       <span class="comment">// NaN</span><span class="keyword">typeof</span> a === <span class="string">"number"</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="无穷数"><a href="#无穷数" class="headerlink" title="无穷数"></a>无穷数</h5><p>计算结果一旦溢出为无穷数(infinity)就无法再得到有穷数。换句话说，就是你可以从有 穷走向无穷，但无法从无穷回到有穷。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span>;  <span class="comment">// Infinity</span><span class="keyword">var</span> b = <span class="number">-1</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<h5 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h5><p>JavaScript 有一个常规的 0(也叫作 +0)和一个 -0。在解释为什么会有 -0 之前，我们先来看看 JavaScript 是如何来处理它的。加法和减法运算不会得到负零(negative zero)。</p>
<p>有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度)，数字的符号位 (sign)用来代表其他信息(比如移动的方向)。此时如果一个值为 0 的变量失去了它的符<br>号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。</p>
<h5 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h5><p>ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等，可以用来处理 上述所有的特殊情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">"foo"</span>;<span class="keyword">var</span> b = <span class="number">-3</span> * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( a, <span class="literal">NaN</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">-0</span> ); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">0</span> );  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>能使用 == 和 ===时就尽量不要使用 Object.is(..)，因为前者效率更高、<br>更为通用。Object.is(..) 主要用来处理那些特殊的相等比较。</p>
<h4 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h4><p>JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用 / 指向关系。</p>
<p>JavaScript 对值和引用的赋值 / 传递在语法上没有区别，完全根据值的类型来决定。</p>
<h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><h4 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性 [[Class]]"></a>内部属性 [[Class]]</h4><p>所有 typeof 返回值为 “object” 的对象(如数组)都包含一个内部属性 <a href="我们可 以把它看作一个内部的分类，而非传统的面向对象意义上的类">[Class]</a>。这个属性无法直接访问， 一般通过 Object.prototype.toString(..) 来查看。例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ); <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>
<h4 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h4><p>封装对象(object wrapper)扮演着十分重要的角色。由于基本类型值没有 .length 和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为 基本类型值包装(box 或者 wrap)一个封装对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"abc"</span>;a.length; <span class="comment">// 3</span>a.toUpperCase(); <span class="comment">// "ABC"</span></span><br></pre></td></tr></table></figure>
<p>如果需要经常用到这些字符串属性和方法，比如在for循环中使用i &lt; a.length，那么从 一开始就创建一个封装对象也许更为方便，这样 JavaScript 引擎就不用每次都自动创建了。<br>但实际证明这并不是一个好办法，因为浏览器已经为 .length 这样的常见情况做了性能优 化，直接使用封装对象来“提前优化”代码反而会降低执行效率。</p>
<p>如果想要自行封装基本类型值，可以使用 Object(..) 函数(不带 new 关键字):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"abc"</span>;var b = <span class="keyword">new</span> String( a );var c = Object( a );typeof a; <span class="comment">// "string"</span>typeof b; <span class="comment">// "object"</span>typeof c; <span class="comment">// "object"</span>b <span class="keyword">instanceof</span> String; <span class="comment">// true</span>c <span class="keyword">instanceof</span> String; <span class="comment">// true</span>Object.prototype.toString.call( b ); <span class="comment">// "[object String]"</span>Object.prototype.toString.call( c ); <span class="comment">// "[object String]"</span></span><br></pre></td></tr></table></figure>
<h4 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h4><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> String( <span class="string">"abc"</span> );var b = <span class="keyword">new</span> Number( <span class="number">42</span> );var c = <span class="keyword">new</span> Boolean( <span class="keyword">true</span> );a.valueOf(); <span class="comment">// "abc"</span>b.valueOf(); <span class="comment">// 42</span>c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> String( <span class="string">"abc"</span> ); </span><br><span class="line">var b = a + <span class="string">""</span>; <span class="comment">// b的值为"abc"</span>typeof a;       <span class="comment">// "object"</span>typeof b;       <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure>
<h4 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h4><p>关于数组(array)、对象(object)、函数(function)和正则表达式，我们通常喜欢以常 量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的(创建的值都是 通过封装对象来包装)。应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的 结果。</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">a; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">var b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的。</p>
<p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度(length)，而 非只充当数组中的一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> Array(<span class="number">3</span>);</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h5 id="Object-、Function-和-RegExp"><a href="#Object-、Function-和-RegExp" class="headerlink" title="Object(..)、Function(..) 和 RegExp(..)"></a>Object(..)、Function(..) 和 RegExp(..)</h5><p>同样，除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var c = <span class="keyword">new</span> Object();</span><br><span class="line">c.foo = <span class="string">"bar"</span>;</span><br><span class="line">c; <span class="comment">// &#123; foo: "bar" &#125;</span></span><br><span class="line"></span><br><span class="line">var d = &#123;</span><br><span class="line">  foo: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line">d; <span class="comment">// &#123; foo: "bar" &#125;</span></span><br><span class="line"></span><br><span class="line">var e = <span class="keyword">new</span> Function(<span class="string">"a"</span>, <span class="string">"return a * 2;"</span>);</span><br><span class="line">var f = function (a) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">g</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var h = <span class="keyword">new</span> RegExp(<span class="string">"^a*b+"</span>, <span class="string">"g"</span>);</span><br><span class="line">var i = /^a*b+/g;</span><br></pre></td></tr></table></figure>
<h5 id="Date-和Error"><a href="#Date-和Error" class="headerlink" title="Date()和Error()"></a>Date()和Error()</h5><p>创建日期对象必须使用new Date()。Date(..)可以带参数，用来指定日期和时间，而不带 参数的话则使用当前的日期和时间。</p>
<p>构造函数 Error(..)(与前面的 Array() 类似)带不带 new 关键字都可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"x wasn’t provided"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>符号并非对象，而是一种简单标量基本类型。</p>
<p>符号是具有唯一性的特殊值(并 非绝对)，用它来命名对象属性不容易导致重名。该类型的引入主要源于 ES6 的一些特殊 构造，此外符号也可以自行定义。</p>
<p>我们可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会出错:</p>
<h5 id="原生原型"><a href="#原生原型" class="headerlink" title="原生原型"></a>原生原型</h5><p>原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。<br>根 据 文 档 约 定， 我 们 将 String.prototype.XYZ 简 写 为 String#XYZ， 对 其 他 .prototypes 也同样如此。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">" abc "</span>;</span><br><span class="line">a.indexOf( <span class="string">"c"</span> ); <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase();  <span class="comment">// " ABC "</span></span><br><span class="line">a.trim();         <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 为基本数据类型值提供了封装对象，称为原生函数(如 String、Number、Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如:String#trim() 和 Array#concat(..))。</p>
<p>对于简单标量基本类型值，比如 “abc”，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实 现对这些属性和方法的访问。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h4><p>将值从一种类型转换为另一种类型通常称为类型转换(type casting)，这是显式的情况;隐式的情况称为强制类型转换(coercion)。</p>
<p>JavaScript 中的强制类型转换总是返回标量基本类型值(参见第 2 章)，如字 符串、数字和布尔值，不会返回对象和函数。在第 3 章中，我们介绍过“封 装”，就是为标量基本类型值封装一个相应类型的对象，但这并非严格意义 上的强制类型转换。</p>
<p>也可以这样来区分:类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时(runtime)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = a + <span class="string">""</span>; <span class="comment">// 隐式强制类型转换 </span></span><br><span class="line">var c = String( a ); <span class="comment">// 显式强制类型转换</span></span><br></pre></td></tr></table></figure>
<h4 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h4><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>它负责处理非字符串到字符串的强制类型转换。</p>
<p>基本类型值的字符串化规则为:null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。</p>
<p>对普通对象来说，除非自行定义，否则 toString()(Object.prototype.toString())返回 内部属性 [[Class]] 的值(参见第 3 章)，如 “[object Object]”。</p>
<p>数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接起 来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.toString(); <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure>
<h5 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h5><p>工具函数 JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(<span class="number">42</span>); <span class="comment">// "42"</span></span><br><span class="line">JSON.stringify(<span class="string">"42"</span>); <span class="comment">// ""42""(含有双引号的字符串) JSON.stringify( null ); // "null"</span></span><br><span class="line">JSON.stringify(<span class="keyword">true</span>); <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure>
<p>所有安全的 JSON 值(JSON-safe)都可以使用 JSON.stringify(..) 字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。</p>
<p>undefined、function、symbol (ES6+)和包含循环引用(对象之间相互引用，形成一个无限循环)的对象都不符合 JSON<br>结构标准，支持 JSON 的语言无法处理它们。</p>
<p>JSON.stringify(..) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在<br>数组中则会返回 null(以保证单元位置不变)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(undefined);  <span class="comment">//undefined</span></span><br><span class="line">JSON.stringify(function () &#123;&#125;);  <span class="comment">//undefined</span></span><br><span class="line">JSON.stringify(</span><br><span class="line">  [<span class="number">1</span>, undefined, function () &#123;&#125;, <span class="number">4</span>] <span class="comment">//"[1,null,null,4]"</span></span><br><span class="line">);</span><br><span class="line">JSON.stringify(&#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: function () &#123;&#125;</span><br><span class="line">&#125;);   <span class="comment">//"&#123;"a":2&#125;"</span></span><br></pre></td></tr></table></figure>
<p>我们可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用 来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  b: <span class="number">42</span>,</span><br><span class="line">  c: <span class="string">"42"</span>,</span><br><span class="line">  d: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line">JSON.stringify(a, [<span class="string">"b"</span>, <span class="string">"c"</span>]); <span class="comment">// "&#123;"b":42,"c":"42"&#125;"</span></span><br><span class="line">JSON.stringify(a, function (k, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (k !== <span class="string">"c"</span>) <span class="keyword">return</span> v;</span><br><span class="line">&#125;);<span class="comment">// "&#123;"b":42,"d":[1,2,3]&#125;"</span></span><br></pre></td></tr></table></figure>
<p>JSON.stringify(..) 并不是强制类型转换。在这里介绍是因为它涉及 ToString 强制类型转换，具体表现在以下两点。</p>
<ul>
<li>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。</li>
<li>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</li>
</ul>
<h5 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h5><p>其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>
<p>ToNumber 对字符串的处理基本遵循数字常量的相关规则 / 语法。处理失败 时返回 NaN(处理数字常量失败时会产生语法错误)。不同之处是 ToNumber 对以 0 开头的 十六进制数并不按十六进制处理(而是按十进制)。</p>
<p>对象(包括数组)会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型 值，则再遵循以上规则将其强制转换为数字。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p>
<h5 id="toBoolean"><a href="#toBoolean" class="headerlink" title="toBoolean"></a>toBoolean</h5><p>JavaScript 中的值可以分为以下两类:</p>
<ul>
<li>(1) 可以被强制类型转换为 false 的值</li>
<li>(2) 其他(被强制类型转换为 true 的值)</li>
</ul>
<p>以下这些是假值:</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0 和 NaN</li>
<li>“”</li>
<li>var a = new Boolean( false );</li>
<li>var b = new Number( 0 );</li>
<li>var c = new String( “” );</li>
</ul>
<h4 id="显示强制类型转化"><a href="#显示强制类型转化" class="headerlink" title="显示强制类型转化"></a>显示强制类型转化</h4><p>对显式强制类型转换几乎不存在非议，它类似于静态语言中的类型转换，已被广泛接受， 不会有什么坑。</p>
<h5 id="字符串和数字之间的显式转换"><a href="#字符串和数字之间的显式转换" class="headerlink" title="字符串和数字之间的显式转换"></a>字符串和数字之间的显式转换</h5><p>字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数(原生构造函 数，参见第 3 章)来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。<br>在 JavaScript 开源社区中，一元运算 + 被普遍认为是显式强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = String(a);</span><br><span class="line">var c = <span class="string">"3.14"</span>;</span><br><span class="line">var d = Number(c);</span><br><span class="line"></span><br><span class="line">var c = <span class="string">"3.14"</span>;</span><br><span class="line">var d = <span class="number">5</span> + +c; <span class="comment">//8.14</span></span><br><span class="line">var d = <span class="keyword">new</span> Date(<span class="string">"Mon, 18 Aug 2014 08:53:06 CDT"</span>); +</span><br><span class="line">d; <span class="comment">// 1408369986000</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带 ()。</p>
<h5 id="奇特的-运算符"><a href="#奇特的-运算符" class="headerlink" title="奇特的 ~ 运算符"></a>奇特的 ~ 运算符</h5><p>它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”(对每一个字 位进行反转)。~x 大致等同于 -(x+1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">42</span>; <span class="comment">// -(42+1) ==&gt; -43</span></span><br></pre></td></tr></table></figure>
<h5 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h5><p>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停 止。而转换不允许出现非数字字符，否则会失败并返回 NaN。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"42"</span>;</span><br><span class="line">var b = <span class="string">"42px"</span>;</span><br><span class="line">Number(a); <span class="comment">// 42</span></span><br><span class="line">parseInt(a); <span class="comment">// 42</span></span><br><span class="line">Number(b); <span class="comment">// NaN</span></span><br><span class="line">parseInt(b); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h5 id="显式转换为布尔值"><a href="#显式转换为布尔值" class="headerlink" title="显式转换为布尔值"></a>显式转换为布尔值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"0"</span>;</span><br><span class="line">var b = [];</span><br><span class="line">var c = &#123;&#125;;</span><br><span class="line">var d = <span class="string">""</span>;</span><br><span class="line">var e = <span class="number">0</span>;</span><br><span class="line">var f = <span class="keyword">null</span>;</span><br><span class="line">var g;</span><br><span class="line">Boolean(a); <span class="comment">// true</span></span><br><span class="line">Boolean(b); <span class="comment">// true</span></span><br><span class="line">Boolean(c); <span class="comment">// true</span></span><br><span class="line">Boolean(d); <span class="comment">// false</span></span><br><span class="line">Boolean(e); <span class="comment">// false</span></span><br><span class="line">Boolean(f); <span class="comment">// false</span></span><br><span class="line">Boolean(g); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!a; <span class="comment">// true</span></span><br><span class="line">!!b; <span class="comment">// true</span></span><br><span class="line">!!c; <span class="comment">// true</span></span><br><span class="line">!!d; <span class="comment">// false</span></span><br><span class="line">!!e; <span class="comment">// false</span></span><br><span class="line">!!f; <span class="comment">// false</span></span><br><span class="line">!!g; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>虽然 Boolean(..) 是显式的，但并不常用。所以显式强制类型转换为布尔值最常用的方法是 !!，因为第二个 ! 会将结果反转回原值:</p>
<h4 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h4><h5 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h5><p>&amp;&amp; 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = <span class="string">"abc"</span>;</span><br><span class="line">var c = <span class="keyword">null</span>;</span><br><span class="line">a || b;<span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b;<span class="comment">// "abc"</span></span><br><span class="line">c || b;<span class="comment">// "abc"</span></span><br><span class="line">c &amp;&amp; b;<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">a || b;</span><br><span class="line"><span class="comment">// 大致相当于(roughly equivalent to): a ? a : b;</span></span><br><span class="line">a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 大致相当于(roughly equivalent to): a ? b : a;</span></span><br></pre></td></tr></table></figure>
<h4 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h4><p>宽松相等(loose equals)== 和严格相等(strict equals)=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。</p>
<p>正确的解释是:“== 允许在相等比较中进行强制类型转换，而 === 不允许。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = <span class="string">"42"</span>;</span><br><span class="line">a === b; <span class="comment">// false</span></span><br><span class="line">a == b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="其他类型和布尔类型之间的相等比较"><a href="#其他类型和布尔类型之间的相等比较" class="headerlink" title="其他类型和布尔类型之间的相等比较"></a>其他类型和布尔类型之间的相等比较</h5><p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果;</p>
<p>(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"42"</span>;</span><br><span class="line">var b = <span class="keyword">true</span>;</span><br><span class="line">a == b; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="null-和-undefined-之间的相等比较"><a href="#null-和-undefined-之间的相等比较" class="headerlink" title="null 和 undefined 之间的相等比较"></a>null 和 undefined 之间的相等比较</h5><p>在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换:</p>
<h5 id="对象和非对象之间的相等比较"><a href="#对象和非对象之间的相等比较" class="headerlink" title="对象和非对象之间的相等比较"></a>对象和非对象之间的相等比较</h5><p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果; </p>
<p>(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = [<span class="number">42</span>];</span><br><span class="line">a == b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h4><p>句子”(sentence)是完整表达某个意思的一组词，由一个或多个“短语”(phrase)组成， 它们之间由标点符号或连接词(and 和 or 等)连接起来。短语可以由更小的短语组成。有 些短语是不完整的，不能独立表达意思;有些短语则相对完整，并且能够独立表达某个意 思。这些规则就是英语的语法。JavaScript 的语法也是如此。语句相当于句子，表达式相当于短语，运算符则相当于标点 符号和连接词。</p>
<h5 id="语句的结果值"><a href="#语句的结果值" class="headerlink" title="语句的结果值"></a>语句的结果值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面方法获取不到值</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a =</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    b = <span class="number">4</span> + <span class="number">38</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a = <span class="built_in">eval</span>(<span class="string">"if (true) &#123; b = 4 + 38; &#125;"</span>);</span><br><span class="line">a; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h5 id="表达式的副作用"><a href="#表达式的副作用" class="headerlink" title="表达式的副作用"></a>表达式的副作用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// 结果值:undefined。副作用:a的值被改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a++;</span><br><span class="line"><span class="comment">//a 43,b 42</span></span><br></pre></td></tr></table></figure>
<h5 id="上下文规则"><a href="#上下文规则" class="headerlink" title="上下文规则"></a>上下文规则</h5><h5 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h5><p>下面两种情况会用到大括号 { .. }</p>
<p>对象常量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  foo: bar()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>标签</p>
<h5 id="else-if-和可选代码块"><a href="#else-if-和可选代码块" class="headerlink" title="else if 和可选代码块"></a>else if 和可选代码块</h5><p>javascript没有elseif，但 if 和 else 只包含单条语句的时候可以省略代码块的 { }。</p>
<p>else if实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123; <span class="comment">// ..</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (b) &#123; <span class="comment">// ..</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// .. &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><h5 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h5><p>对 &amp;&amp; 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数。我们将 这种现象称为“短路”(即执行最短路径)。</p>
<p>以a &amp;&amp; b为例，如果a是一个假值，足以决定&amp;&amp;的结果，就没有必要再判断b的值。同 样对于 a || b，如果 a 是一个真值，也足以决定 || 的结果，也就没有必要再判断 b 的值。</p>
<ul>
<li>&amp;&amp; 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。</li>
</ul>
<h4 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h4><p>因为如果缺失了必要的 ;，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的 ;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>,b</span><br><span class="line">c;<span class="comment">//c会被作为var语句的一部分来处理</span></span><br></pre></td></tr></table></figure>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>JavaScript 不仅有各种类型的运行时错误(TypeError、ReferenceError、SyntaxError 等)，它的语法中也定义了一些编译时错误。</p>
<h4 id="提前使用变量"><a href="#提前使用变量" class="headerlink" title="提前使用变量"></a>提前使用变量</h4><p>ES6 规范定义了一个新概念，叫作 TDZ(Temporal Dead Zone，暂时性死区)。 TDZ 指的是由于代码中的变量还没有初始化而不能被引用的情况。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>在 ES6 中，如果参数被省略或者值为 undefined，则取该参数的默认值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a = <span class="number">42</span>, b = a + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">// 42 43</span></span><br><span class="line">foo(<span class="literal">undefined</span>);<span class="comment">// 42 43</span></span><br><span class="line">foo(<span class="number">5</span>);<span class="comment">// 5 6</span></span><br><span class="line">foo(<span class="keyword">void</span> <span class="number">0</span>, <span class="number">7</span>);<span class="comment">// 42 7</span></span><br><span class="line">foo(<span class="literal">null</span>);<span class="comment">// null 1</span></span><br></pre></td></tr></table></figure>
<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try..finally"></a>try..finally</h4><p>finally 中的代码总是会在 try 之后执行，如果有 catch 的话则在 catch 之后执行。也可以将 finally 中的代码看作一个回调函数，即无论出现什么情况最后一定会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"never runs"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> (a || b == <span class="number">10</span>):</span><br><span class="line">    <span class="comment">// 永远执行不到这里</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 的决议:一种在异步任务中作为两个或更多步骤的流程控制机制，时序上的 this- then-that。</p>
<p>Promise 至多只能有一个决议值(完成或拒绝)。</p>
<p>两个 Promise 固有行为特性:</p>
<ul>
<li>每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来;</li>
<li>不管从then(..) 调用的完成回调(第一个参数)返回的值是什么，它都会被自动设置 为被链接 Promise(第一点中的)的完成。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"B"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = p.then(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="comment">// 用值42填充p2</span></span><br><span class="line">  <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 连接p2</span></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="术语-决议、完成以及拒绝"><a href="#术语-决议、完成以及拒绝" class="headerlink" title="术语:决议、完成以及拒绝"></a>术语:决议、完成以及拒绝</h5><p>对于术语决议(resolve)、完成(fulfill)和拒绝(reject)，在更深入学习 Promise 之前，我们还有一些模糊之处需要澄清。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">X, Y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// X()用于完成</span></span><br><span class="line">  <span class="comment">// Y()用于拒绝 </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数字没有string函数，所以会抛出错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line">).catch(handleErrors);</span><br></pre></td></tr></table></figure>
<p>因为我们没有为 then(..) 传入拒绝处理函数，所以默认的处理函数被替换掉了，而这仅仅是把错误传递给了链中的下一个 promise。因此，进入 p 的错误以及 p 之后进入其决议 (就像 msg.toLowerCase())的错误都会传递到最后的handleErrors(..)。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([ .. ])"></a>Promise.all([ .. ])</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = request(<span class="string">"http://some.url.1/"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = request(<span class="string">"http://some.url.2/"</span>);</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">msgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里，p1和p2完成并把它们的消息传入 return request(</span></span><br><span class="line">    <span class="string">"http://some.url.3/?v="</span> + msgs.join(<span class="string">","</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>从Promise.all([ .. ])返回的主promise在且仅在所有的成员promise都完成后才会完 成。如果这些promise中有任何一个被拒绝的话，主Promise.all([ .. ])promise就会立 即被拒绝，并丢弃来自其他所有 promise 的全部结果。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([ .. ])"></a>Promise.race([ .. ])</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = request(<span class="string">"http://some.url.1/"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = request(<span class="string">"http://some.url.2/"</span>);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p1或者p2将赢得这场竞赛 return request(</span></span><br><span class="line">    <span class="string">"http://some.url.3/?v="</span> + msg</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>因为只有一个 promise 能够取胜，所以完成值是单个消息，而不是像对 Promise.all([ 那样的是一个数组。<br>.. ])</p>
<p>与Promise.all([ .. ])类似，一旦有任何一个Promise决议为完成，Promise.race([ .. ]) 就会完成;一旦有任何一个 Promise 决议为拒绝，它就会拒绝。</p>
<h4 id="Promise-API-概述"><a href="#Promise-API-概述" class="headerlink" title="Promise API 概述"></a>Promise API 概述</h4><h5 id="new-Promise-构造器"><a href="#new-Promise-构造器" class="headerlink" title="new Promise(..) 构造器"></a>new Promise(..) 构造器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve(..)用于决议/完成这个promise</span></span><br><span class="line">  <span class="comment">// reject(..)用于拒绝这个promise</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>reject(..) 就是拒绝这个 promise;但 resolve(..) 既可能完成 promise，也可能拒绝，要 根据传入参数而定。如果传给 resolve(..) 的是一个非 Promise、非 thenable 的立即值，这 个 promise 就会用这个值完成。</p>
<p>但是，如果传给 resolve(..) 的是一个真正的 Promise 或 thenable 值，这个值就会被递归展 开，并且(要构造的)promise 将取用其最终决议值或状态。</p>
<h5 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve(..) 和 Promise.reject(..)"></a>Promise.resolve(..) 和 Promise.reject(..)</h5><p>创建一个已被拒绝的 Promise 的快捷方式是使用 Promise.reject(..)，所以以下两个promise 是等价的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="string">"Oops"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">"Oops"</span>);</span><br></pre></td></tr></table></figure>
<p>Promise.resolve(..) 常用于创建一个已完成的 Promise,但是，Promise.resolve(..) 也会展开 thenable 值在这种情况 下，返回的 Promise 采用传入的这个 thenable 的最终决议值，可能是完成，也可能是拒绝:</p>
<h5 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then(..) 和 catch(..)"></a>then(..) 和 catch(..)</h5><p>每个 Promise 实例(不是 Promise API 命名空间)都有 then(..) 和 catch(..) 方法，通过 这两个方法可以为这个 Promise 注册完成和拒绝处理函数。Promise 决议之后，立即会调用 这两个处理函数之一，但不会两个都调用，而且总是异步调用.</p>
<h5 id="then-接受一个或两个参数"><a href="#then-接受一个或两个参数" class="headerlink" title="then(..) 接受一个或两个参数"></a>then(..) 接受一个或两个参数</h5><p>then(..) 接受一个或两个参数:第一个用于完成回调，第二个用于拒绝回调。如果两者中 的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回 调只是把消息传递下去，而默认拒绝回调则只是重新抛出(传播)其接收到的出错原因。</p>
<p>就像刚刚讨论过的一样，catch(..) 只接受一个拒绝回调作为参数，并自动替换默认完成 回调。换句话说，它等价于 then(null,..):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.then(fulfilled);</span><br><span class="line">p.then(fulfilled, rejected);</span><br><span class="line">p.catch(rejected); <span class="comment">// 或者p.then( null, rejected )</span></span><br></pre></td></tr></table></figure>
<p>then(..) 和 catch(..) 也会创建并返回一个新的 promise，这个 promise 可以用于实现 Promise 链式流程控制。如果完成或拒绝回调中抛出异常，返回的 promise 是被拒绝的。如 果任意一个回调返回非 Promise、非 thenable 的立即值，这个值会被用作返回 promise 的完 成值。如果完成处理函数返回一个 promise 或 thenable，那么这个值会被展开，并作为返回 promise 的决议值。</p>
<h4 id="Promise-局限性"><a href="#Promise-局限性" class="headerlink" title="Promise 局限性"></a>Promise 局限性</h4><h5 id="顺序错误处理"><a href="#顺序错误处理" class="headerlink" title="顺序错误处理"></a>顺序错误处理</h5><p>Promise 的设计局限性(具体来说，就 是它们链接的方式)造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被 无意中默默忽略掉。</p>
<h5 id="单一值"><a href="#单一值" class="headerlink" title="单一值"></a>单一值</h5><p>Promise 只能有一个完成值或一个拒绝理由。</p>
<h5 id="单决议"><a href="#单决议" class="headerlink" title="单决议"></a>单决议</h5><p>Promise 最本质的一个特征是:Promise 只能被决议一次(完成或拒绝)。</p>
<h5 id="无法取消的Promise"><a href="#无法取消的Promise" class="headerlink" title="无法取消的Promise"></a>无法取消的Promise</h5><p>一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。</p>
<h5 id="Promise-性能"><a href="#Promise-性能" class="headerlink" title="Promise 性能"></a>Promise 性能</h5><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="打破完整运行"><a href="#打破完整运行" class="headerlink" title="打破完整运行"></a>打破完整运行</h4><p>下面是实现这样的合作式并发的 ES6 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// 暂停!</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x:"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个迭代器it来控制这个生成器</span></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"><span class="comment">// 这里启动foo()! </span></span><br><span class="line">it.next();</span><br><span class="line">x; <span class="comment">// 2 </span></span><br><span class="line">bar();</span><br><span class="line">x; <span class="comment">// 3 </span></span><br><span class="line">it.next(); <span class="comment">// x: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>it = foo()运算并没有执行生成器*foo()，而只是构造了一个迭代器(iterator)，这个 迭代器会控制它的执行。后面会介绍迭代器。</li>
<li>第一个 it.next() 启动了生成器 <em>foo()，并运行了 </em>foo() 第一行的 x++。</li>
<li><em>foo() 在 yield 语句处暂停，在这一点上第一个 it.next() 调用结束。此时 </em>foo() 仍在运行并且是活跃的，但处于暂停状态。</li>
<li>我们查看 x 的值，此时为 2。</li>
<li>我们调用 bar()，它通过 x++ 再次递增 x。</li>
<li>我们再次查看 x 的值，此时为 3。</li>
<li>最后的 it.next() 调用从暂停处恢复了生成器 *foo() 的执行，并运行 console.log(..)语句，这条语句使用当前 x 的值 3。</li>
</ul>
<h5 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h5><p>生成器函数是一个特殊的函数，具有前面我们展示的新的执行模式。但是，它仍然是一个 函数，这意味着它仍然有一些基本的特性没有改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line">res.value; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>yield .. 和 next(..) 这一对组合起来，在生成器的执行过程中构成了一个双向消息传递系统。</p>
<h5 id="多个迭代器"><a href="#多个迭代器" class="headerlink" title="多个迭代器"></a>多个迭代器</h5><p>同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  z++;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span>(x * z);</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> it1 = foo();</span><br><span class="line"><span class="keyword">var</span> it2 = foo();</span><br><span class="line"><span class="keyword">var</span> val1 = it1.next().value; <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line"><span class="keyword">var</span> val2 = it2.next().value; <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line">val1 = it1.next(val2 * <span class="number">10</span>).value; <span class="comment">// 40   &lt;-- x:20,  z:2</span></span><br><span class="line">val2 = it2.next(val1 * <span class="number">5</span>).value; <span class="comment">// 600  &lt;-- x:200, z:3</span></span><br><span class="line">it1.next(val2 / <span class="number">2</span>); <span class="comment">// y:300</span></span><br><span class="line">it2.next(val1 / <span class="number">4</span>); <span class="comment">// y:10</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 ShenYonghe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>