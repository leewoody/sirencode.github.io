<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Diablo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Diablo">
<meta property="og:url" content="https://github.com/sirencode/page/2/index.html">
<meta property="og:site_name" content="Diablo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Diablo">
  
    <link rel="alternative" href="/atom.xml" title="Diablo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ShenYonghe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ShenYonghe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ShenYonghe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Android 动画原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/27/Android 动画原理/" class="article-date">
  	<time datetime="2018-02-26T16:00:00.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/Android 动画原理/">
        Android 动画原理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-动画原理"><a href="#Android-动画原理" class="headerlink" title="Android 动画原理"></a>Android 动画原理</h1><h2 id="Animation-与-Transform"><a href="#Animation-与-Transform" class="headerlink" title="Animation 与 Transform"></a>Animation 与 Transform</h2><p>Animation：在给定了初始状态，结束状态，启动时间和持续时间后，Animation可以计算动画目标在任意时刻的变换（Transfirmation）,这是Animation唯一的用途。Animation考虑的是时间线效果的实现。</p>
<p>Transfirmation：描述了一个变换。它包含两个分量：透明度和一个二维的变换矩阵（可以在二维空间中对变换目标实现平移旋转缩放,矩阵相乘可以组合实现各自的变换）。</p>
<h2 id="动画的驱动器Choreographer"><a href="#动画的驱动器Choreographer" class="headerlink" title="动画的驱动器Choreographer"></a>动画的驱动器Choreographer</h2><p>在Animation start()的时候会创建一个Choreographer（线程唯一的）来实现动画的绘制工作。Choreographer发送一个runnable以处理一帧动画。在处理动画时，使用Animation getTransfirmation函数获取动画对象所需要进行的变换，然后根据变换对动画对象进行渲染。之后重复画下一帧直至动画结束。</p>
<h2 id="Tween动画-Animation"><a href="#Tween动画-Animation" class="headerlink" title="Tween动画 Animation"></a>Tween动画 Animation</h2><p>原理：在绘制的过程中，尝试获取动画在当前时刻的变换，然后应用到view的绘制中。</p>
<h3 id="1-startAnimation-animation"><a href="#1-startAnimation-animation" class="headerlink" title="1 startAnimation(animation);"></a>1 startAnimation(animation);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">    animation.setStartTime(Animation.START_ON_FIRST_FRAME);</span><br><span class="line">    setAnimation(animation);</span><br><span class="line">    invalidateParentCaches();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-invalidate请求View树进行重绘"><a href="#2-invalidate请求View树进行重绘" class="headerlink" title="2 invalidate请求View树进行重绘"></a>2 invalidate请求View树进行重绘</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的mLeft，mRight都是相当于父View来讲的。所以这里的参数就是当前View所在的区域。</span></span><br><span class="line">    invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不需要绘制的情况（View不可见&amp;&amp;没有动画等）</span></span><br><span class="line">    <span class="keyword">if</span> (skipInvalidate()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(condition<span class="comment">/*满足需要绘制的条件*/</span>)&#123;</span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">            damage.set(l, t, r, b);</span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-调用子view的draw方法"><a href="#3-调用子view的draw方法" class="headerlink" title="3 调用子view的draw方法"></a>3 调用子view的draw方法</h3><p>Animation 实现了下面方法设置Transformation动画信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数是 interpolatedTime 它代表插值后的时间，第二个参数是Transformation类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span></span></span><br></pre></td></tr></table></figure>
<p>view getAnimation()获取动画信息，getTransformation获取Transformation；</p>
<p>Transformation是一个实体类，它主要的内容是透明度和一个矩阵，动画的变化，就隐藏在Transformation之中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span></span></span><br></pre></td></tr></table></figure>
<p>draw中applyLegacyAnimation方法是用来获取变换的，其中有两个部分需要注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</span><br><span class="line">a.getInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, region,</span><br><span class="line">    invalidationTransform);</span><br></pre></td></tr></table></figure>
<p>第一个就是获取变换，第二个是获取绘制无效区域。<br>其实这个无效区域是绘制后的无效区域，因为很有可能需要下次绘制(保证动画连续性)。</p>
<p>动画的绘制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (transformToApply != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">            renderNode.setAnimationMatrix(transformToApply.getMatrix());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.translate(-transX, -transY);</span><br><span class="line">            canvas.concat(transformToApply.getMatrix());</span><br><span class="line">            canvas.translate(transX, transY);</span><br><span class="line">        &#125;</span><br><span class="line">        parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> transformAlpha = transformToApply.getAlpha();</span><br><span class="line">    <span class="keyword">if</span> (transformAlpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        alpha *= transformAlpha;</span><br><span class="line">        parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别从硬件加速和软件绘制上　对canvas进行矩阵变换．</p>
<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>原理：使用了Choreographer机制.</p>
<p>Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。收到VSync信号后，顺序执行3个操作，然后等待下一个信号，再次顺序执行3个操作。</p>
<p>AnimationDrawable继承了DrawableContainer，因为DrawableContainer是一个drawable的容器，可以保存多个图片<br>同时，实现了Runnable接口，重写了run方法,根据源码中的start方法，它调用了setFrame方法，方法内部最重要的调用就是调用了<br> scheduleSelf(this, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]);callback调用view的scheduleDrawable方法而这个方法最终会调用Choreographer.subtractFrameDelay(delay));</p>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>原理：使用了Choreographer机制</p>
<p>简单的说，Chreographer是组织上层进行处理绘制的控制类，它会在每次vsync信号来临时，执行与绘制相关的过程．</p>
<p>Animator的过程发生在绘制之前（甚至是布局之前）.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android 底层网络实现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/27/Android 底层网络实现/" class="article-date">
  	<time datetime="2018-02-26T16:00:00.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/Android 底层网络实现/">
        Android 底层网络实现
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-底层网络实现"><a href="#Android-底层网络实现" class="headerlink" title="Android 底层网络实现"></a>Android 底层网络实现</h1><h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>HttpURLConnection是一种多用途、轻量极的HTTP客户端，使用它来进行HTTP操作可以适用于大多数的应用程序。底层也是Socket实现。从Android4.4开始HttpURLConnection的底层实现采用的是okHttp。</p>
<p>但是HttpURLConnection再多线程请求存在不足，也没有做http缓存。</p>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>Apache HttpClient早就不推荐httpclient，5.0之后干脆废弃，后续会删除。6.0删除了HttpClient。Java开发用HttpClient，官方推荐Android开发用HttpUrlConnection。</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>OkHttp是一个精巧的网络请求库，支持http2，对一台机器的所有请求共享同一个socket ，内置连接池，支持连接复用，减少延迟 ，支持透明的gzip压缩响应体，通过缓存避免重复的请求，请求失败时自动重试主机的其他ip，自动重定向，简单易用的API实现。</p>
<p>OkHttp底层也是通过socket实现。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-子模块访问app模块" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/26/子模块访问app模块/" class="article-date">
  	<time datetime="2018-02-25T16:00:00.000Z" itemprop="datePublished">2018-02-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/26/子模块访问app模块/">
        子模块访问app模块
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="子模块访问app模块"><a href="#子模块访问app模块" class="headerlink" title="子模块访问app模块"></a>子模块访问app模块</h1><h2 id="第一步子模块定义接口"><a href="#第一步子模块定义接口" class="headerlink" title="第一步子模块定义接口"></a>第一步子模块定义接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TradeModuleBridge</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goOpenAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二步-接口管理类"><a href="#第二步-接口管理类" class="headerlink" title="第二步 接口管理类"></a>第二步 接口管理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeBridgeHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TradeModuleBridge <span class="title">getBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bridge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBridge</span><span class="params">(TradeModuleBridge bridge)</span> </span>&#123;</span><br><span class="line">        TradeBridgeHolder.bridge = bridge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TradeModuleBridge bridge;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三步-在app的application里面初始化"><a href="#第三步-在app的application里面初始化" class="headerlink" title="第三步 在app的application里面初始化"></a>第三步 在app的application里面初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTradeBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TradeBridgeHolder.setBridge(<span class="keyword">new</span> TradeModuleBridge() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOpenAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            startActivity(WebViewActivity.buildAccountIntent(FuturesApplication.from()));</span><br><span class="line">            StatisticsAgent.onEV(EventIDS.ME_OPEN_ACCOUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四步-使用"><a href="#第四步-使用" class="headerlink" title="第四步 使用"></a>第四步 使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TradeBridgeHolder.getBridge().goOpenAccount();</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-java 内存区域详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/24/java 内存区域详解/" class="article-date">
  	<time datetime="2018-02-23T16:00:00.000Z" itemprop="datePublished">2018-02-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/24/java 内存区域详解/">
        java 内存区域详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java-内存区域详解"><a href="#java-内存区域详解" class="headerlink" title="java 内存区域详解"></a>java 内存区域详解</h1><p><img src="http://oc4zuck5v.bkt.clouddn.com/java_memory.png" alt=""></p>
<h2 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h2><p>占内存最大的一块区域。大部分对象存储在这个区域。</p>
<p>Java Heap（Dalvik Heap），这部分的内存区域是由Dalvik虚拟机管理，通过Java中 new 关键字来申请一块新内存。这块区域的内存是由GC直接管理，能够自动回收内存。这块内存的大小会受到系统限制，当内存超过APP最大可用内存时会OOM</p>
<p>Native Heap，这部分内存区域是在C++中申请的，它不受限于APP的最大可用内存限制，而只是受限于设备的物理可用内存限制。它的缺点在于没有自动回收机制，只能通过C++语法来释放申请的内存</p>
<p>Ashmem（Android匿名共享内存），这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象</p>
<h2 id="方法区Meta-Area"><a href="#方法区Meta-Area" class="headerlink" title="方法区Meta-Area"></a>方法区Meta-Area</h2><p>这是堆中的一块区域，用来存储类信息，类变量，类常量，静态变量等等数据，即时编译器编译后的代码等数据。</p>
<p>运行时常量区：存放编译器生成的各种字面量和符号引用，这部分将在类加载后存放到方法区的运行时常量池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会涉及虚拟机栈，java堆，Meta-Area三个内存区域：test()-&gt;虚拟机栈,obj存放在局部变量表中，new Object()对象存储在java heap里。</p>
<h2 id="虚拟机栈，本地栈"><a href="#虚拟机栈，本地栈" class="headerlink" title="虚拟机栈，本地栈"></a>虚拟机栈，本地栈</h2><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈是Java方法执行的内存模型。每个方法执行都会创建一个栈帧的东西，用来存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。</p>
<h3 id="本地栈"><a href="#本地栈" class="headerlink" title="本地栈"></a>本地栈</h3><p>本地栈使用到的本地系统方法服务。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器(每个线程都有私有的程序计数器)是记录当前线程执行到什么地方了。多线程调度的时候，占用cup知道执行到哪里了。另外程序计数器是Java虚拟机规范中唯一一个没有规定任何内存错误的地方。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Protobuf" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/23/Protobuf/" class="article-date">
  	<time datetime="2018-02-22T16:00:00.000Z" itemprop="datePublished">2018-02-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/23/Protobuf/">
        Protobuf
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h1><p>Google Protocol Buffer(简称 Protobuf)是一种轻便高效的结构化数据存储格式，平台无关、语言无关、可扩展，可用于通讯协议和数据存储等领域。</p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>protobuf之所以小且快，就是因为使用变长的编码规则，只保存有用的信息，节省了大量空间。</p>
<p>1 Base-128变长编码：每个字节使用低7位表示数字，除了最后一个字节，其他字节的最高位都设置为1；采用Little-Endian字节序。</p>
<p>2 ZigZag编码：Base-128变长编码会去掉整数前面那些没用的0，只保留低位的有效位，然而负数的补码表示有很多的1，所以protobuf先用ZigZag编码将所有的数值映射为无符号数，然后使用Base-128编码，ZigZag的编码规则如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> (n &lt;&lt; <span class="number">1</span>) ^ (n &gt;&gt; <span class="number">31</span>) or (n &lt;&lt; <span class="number">1</span>) ^ (n &gt;&gt; <span class="number">63</span>)</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://github.com/google/protobuf">github</a></p>
<p>1 下载源码</p>
<p>2 cd到源码目录</p>
<p>3 执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make check</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filename: addressbook.proto</span></span><br><span class="line"></span><br><span class="line">syntax=<span class="string">"proto2"</span>;</span><br><span class="line"><span class="keyword">package</span> addressbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"src/help.proto"</span>;      <span class="comment">//举例用，编译时去掉</span></span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    required string name = <span class="number">1</span>;</span><br><span class="line">    required int32 id = <span class="number">2</span>;</span><br><span class="line">    optional string email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> PhoneType &#123;</span><br><span class="line">        MOBILE = <span class="number">0</span>;</span><br><span class="line">        HOME = <span class="number">1</span>;</span><br><span class="line">        WORK = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message PhoneNumber &#123;</span><br><span class="line">        required string number = <span class="number">1</span>;</span><br><span class="line">        optional PhoneType type = <span class="number">2</span> [<span class="keyword">default</span> = HOME];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeated PhoneNumber phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">    repeated Person person_info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>syntax=”proto2”; 表明使用protobuf的编译器版本为v2，目前最新的版本为v3 </li>
<li>package addressbook; 声明了一个包名，用来防止不同的消息类型命名冲突，类似于 namespace </li>
<li>message 是Protobuf中的结构化数据，类似于C++中的类，可以在其中定义需要处理的数据 </li>
</ul>
<h3 id="protobuf类型"><a href="#protobuf类型" class="headerlink" title="protobuf类型"></a>protobuf类型</h3><p><img src="http://oc4zuck5v.bkt.clouddn.com/pb.png" alt="pb图"></p>
<h3 id="protobuf字段修饰符"><a href="#protobuf字段修饰符" class="headerlink" title="protobuf字段修饰符"></a>protobuf字段修饰符</h3><p>required：该值是必须要设置的；<br>optional：该字段可以有0个或1个值（不超过1个）；<br>repeated：该字段可以重复任意多次（包括0次），类似于C++中的list；</p>
<h2 id="proto文件转换"><a href="#proto文件转换" class="headerlink" title="proto文件转换"></a>proto文件转换</h2><p>protoc是proto文件的编译器，目前可以将proto文件编译成C++、Java、Python三种代码文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//java</span><br><span class="line">$ protoc --java_out=./java/ ./proto/helloworld.proto</span><br><span class="line">//go</span><br><span class="line">$ protoc --go_out=./go/ ./proto/helloworld.proto</span><br><span class="line">//c++</span><br><span class="line">protoc -I=<span class="variable">$SRC_DIR</span> --cpp_out=<span class="variable">$DST_DIR</span> /path/to/file.proto</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-java基础整理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/06/java基础整理/" class="article-date">
  	<time datetime="2018-02-05T16:00:00.000Z" itemprop="datePublished">2018-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/06/java基础整理/">
        java基础整理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java基础整理"><a href="#java基础整理" class="headerlink" title="java基础整理"></a>java基础整理</h1><h2 id="java中equals，hashcode和-的区别"><a href="#java中equals，hashcode和-的区别" class="headerlink" title="java中equals，hashcode和==的区别"></a>java中equals，hashcode和==的区别</h2><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><p>== 比较的是基础数据类型也称原始数据类型(byte,char,short,int,long,float,double,boolean)的值。</p>
<p>引用类型(类、接口、数组)（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。</p>
<p>对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号进行比较的，所以比较后的结果跟双等号的结果相同。</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等）</p>
<h2 id="java基本类型所占字节数"><a href="#java基本类型所占字节数" class="headerlink" title="java基本类型所占字节数"></a>java基本类型所占字节数</h2><p>注：1字节(byte)=8位(bits)</p>
<ul>
<li>1字节： byte , boolean</li>
<li>2字节： short , char</li>
<li>4字节： int , float</li>
<li>8字节： long , double</li>
</ul>
<p>取值范围</p>
<ul>
<li>int 二进制位数：32 Integer.MIN_VALUE= -2147483648（-2的31次方）<br>Integer.MAX_VALUE= 2147483647（2的31次方-1）</li>
<li>short 二进制位数：16 Short.MIN_VALUE=-32768 （-2的15此方）<br>Short.MAX_VALUE=32767 （2的15次方-1）</li>
<li>long 二进制位数：64 Long.MIN_VALUE=-9223372036854775808 （-2的63次方）<br>Long.MAX_VALUE=9223372036854775807 （2的63次方-1）</li>
<li>float 二进制位数：32 Float.MIN_VALUE=1.4E-45 （2的-149次方）Float.MAX_VALUE=3.4028235E38 （2的128次方-1）</li>
<li>double 二进制位数：64 Double.MIN_VALUE=4.9E-324 （2的-1074次方）Double.MAX_VALUE=1.7976931348623157E308 （2的1024次方-1）</li>
</ul>
<p>实践：int和long只能写10个数字，short只能写5个数字，多了就会报错。float的小数点后6位，double的小数点后16位。</p>
<h2 id="java浮点运算"><a href="#java浮点运算" class="headerlink" title="java浮点运算"></a>java浮点运算</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为java的精度是小数点后18位的，而小数部分是需要转化为二进制形式的，而某些小数如0.22在转化为二进制的时候会出现除不尽的情况。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>其实解决方法也是很简单，虽然并不是精确的结果，但是相差甚微，我们只需要四舍五入保留我们需要的小数点位数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getExactValue</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(BigDecimalUtil.format(value, digits)).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//results 0商，1余数    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">divideAndRemainder</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> v1 * <span class="number">10</span> % <span class="number">10</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(BigDecimalUtil.format(v1, digits));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(BigDecimalUtil.format(v2, digits));</span><br><span class="line">        BigDecimal[] results = b1.divideAndRemainder(b2);</span><br><span class="line">        <span class="keyword">return</span> results[<span class="number">1</span>].doubleValue() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用BigDecimal进行转换是一件很费时的事，所以注意使用的场景，不要过度使用导致性能问题。</p>
<h2 id="int-Integer-区别"><a href="#int-Integer-区别" class="headerlink" title="int Integer 区别"></a>int Integer 区别</h2><p>int的初始化值是0 ，Integer初始化的值是null。 </p>
<p>原始类型: boolean，char，byte，short，int，long，float，double<br>封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<h3 id="拆箱封箱"><a href="#拆箱封箱" class="headerlink" title="拆箱封箱"></a>拆箱封箱</h3><p>封箱：原始类型-&gt;封装类型</p>
<p>拆箱：封装类型-&gt;原始类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱</span></span><br><span class="line">Integer num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="keyword">int</span> num1 = num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个Integer对象</span></span><br><span class="line">Integer num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//以上的声明就是用到了自动的装箱：解析为</span></span><br><span class="line">Integer num = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Integer num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//进行计算时隐含的有自动拆箱</span></span><br><span class="line">System.out.print(num--);</span><br></pre></td></tr></table></figure>
<p>很奇怪吧：这就归结于java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫享元模式（flyweight）</p>
<h2 id="String，StringBuffer，StringBuilder区别"><a href="#String，StringBuffer，StringBuilder区别" class="headerlink" title="String，StringBuffer，StringBuilder区别"></a>String，StringBuffer，StringBuilder区别</h2><p>String 字符串常量<br>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）</p>
<p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>
<h2 id="java-内部类"><a href="#java-内部类" class="headerlink" title="java 内部类"></a>java 内部类</h2><p>内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul>
<li>(1)内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。</li>
<li>(2)内部类不能用普通的方式访问。</li>
<li>(3)内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量 。</li>
<li>(4)外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>1.内部类可以很好的实现隐藏，一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</li>
<li>2．内部类拥有外围类的所有元素的访问权限</li>
<li>3.可是实现多重继承，外部类继承一个，内部再继承一个。</li>
<li>4.可以避免修改接口而实现同一个类中两种同名方法的调用。</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象方法：由abstract修饰的方法为抽象方法，抽象方法只有方法的定义，没有方法的实现。</p>
<p>抽象类：一个类中如果包含抽象方法，一个类应该用abstract关键字声明为抽象类。</p>
<p>抽象类不可以实例化，即使一个类中没有抽象方法，也可以将其定义为抽象类，同样，该类不可以实例化。</p>
<p>抽象类是否可以没有方法和属性？- 可以</p>
<h3 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h3><ul>
<li>1 为子类提供一个公共的类型；</li>
<li>2 封装子类中重复内容（成员变量和方法）；</li>
<li>3 定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。</li>
</ul>
<h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><ul>
<li>1.一个类可以实现多个接口 ，但却只能继承最多一个抽象类。</li>
<li>2.抽象类可以包含具体的方法 ， 接口的所有方法都是抽象的。</li>
<li>3.抽象类可以声明和使用字段 ，接口则不能，但接口可以创建静态的final常量。</li>
<li>4.接口的方法都是public的，抽象类的方法可以是public，protected，private或者默认的package；</li>
<li>5.抽象类可以定义构造函数，接口却不能。</li>
</ul>
<h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><ul>
<li>1 通过接口可以实现不相关类的相同行为，而不需要了解对象所对应的类。</li>
<li>2 通过接口可以指明多个类需要实现的方法。</li>
<li>3 通过接口可以了解对象的交互界面，而不需了解对象所对应的类。</li>
</ul>
<h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h2><p>经常发现有List&lt;? super T&gt;、Set&lt;? extends T&gt;的声明，是什么意思呢？&lt;? super T&gt;表示包括T在内的任何T的父类，&lt;? extends T&gt;表示包括T在内的任何T的子类，下面我们详细分析一下两种通配符具体的区别。</p>
<h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h2><p>父类的静态方法不能被子类继承，更谈不上重写，就算是子类中有一个和父类一模一样的静态方法，那也是子类本身的，和父类的那个静态方法不是一回事。方法加静态后就属于类不属于对象了。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>关系：一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>区别：进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>
<p>优缺点：线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>
<h2 id="final，finally，finalize的区别"><a href="#final，finally，finalize的区别" class="headerlink" title="final，finally，finalize的区别"></a>final，finally，finalize的区别</h2><p>Final用于修饰类、成员变量和成员方法</p>
<p>Finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中。</p>
<p>Finalize是object类中的一个方法，子类可以重写finalize()方法实现对资源的回收。</p>
<h2 id="finally-return顺序"><a href="#finally-return顺序" class="headerlink" title="finally return顺序"></a>finally return顺序</h2><ul>
<li>1 不管有木有出现异常，finally块中代码都会执行；</li>
<li>2 当try和catch中有return时，finally仍然会执行；</li>
<li>3 finally是在return语句执行之后，返回之前执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前就已经确定了；</li>
<li>4 finally中如果包含return，那么程序将在这里返回，而不是try或catch中的return返回，返回值就不是try或catch中保存的返回值了。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>对象的序列化就是将对象写入输出流中。<br>反序列化就是从输入流中将对象读取出来。</p>
<p>Serializable：一个对象想要被序列化，那么它的类就要实现 此接口，这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递。</p>
<p>Externalizable：他是Serializable接口的子类，有时我们不希望序列化那么多，可以使用这个接口，这个接口的writeExternal()和readExternal()方法可以指定序列化哪些属性;</p>
<h2 id="Serializable-和Parcelable-的区别"><a href="#Serializable-和Parcelable-的区别" class="headerlink" title="Serializable 和Parcelable 的区别"></a>Serializable 和Parcelable 的区别</h2><p>作用：Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。而Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。</p>
<p>效率及选择：Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。</p>
<h2 id="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h2><p>可以继承不可以重写，静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写。static修饰与对象无关只与类相关。重写的时候父类对应会隐藏。</p>
<h2 id="string-转换成-integer的方式及原理"><a href="#string-转换成-integer的方式及原理" class="headerlink" title="string 转换成 integer的方式及原理"></a>string 转换成 integer的方式及原理</h2><p>Integer.valueOf(str)或者str.parseInt()。前者需要拆箱操作，或者不需要。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="哪些情况下的对象会被垃圾回收机制处理掉？"><a href="#哪些情况下的对象会被垃圾回收机制处理掉？" class="headerlink" title="哪些情况下的对象会被垃圾回收机制处理掉？"></a>哪些情况下的对象会被垃圾回收机制处理掉？</h2><p>1 object = null,赋值为null后，就会标记为可回收状态。</p>
<p>2 对象引用超过其作用范围，则这个对象将被视为垃圾。</p>
<h2 id="java常见编码方式？"><a href="#java常见编码方式？" class="headerlink" title="java常见编码方式？"></a>java常见编码方式？</h2><p>编码原因：把我们日常生活中常用的字符转换成计算机可识别的二进制形式，八位一字符。要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码。</p>
<p>字符集的概念实际上包含两个方面，一个是字符的集合，一个是编码方案。通常来说，一个字符集不仅仅定义字符集合，它还为每个符号定义一个二进制编码。例如当我们提到GB2312或者ASCII的时候，它隐式地指明了编码方案是GB2312或者ASCII。</p>
<h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。</p>
<h3 id="ISO-8859-1（扩展ASCII编码）"><a href="#ISO-8859-1（扩展ASCII编码）" class="headerlink" title="ISO-8859-1（扩展ASCII编码）"></a>ISO-8859-1（扩展ASCII编码）</h3><p>128个字符显然是不够用的，于是ISO组织在ASCII码基础上又制定了一些列标准用来扩展ASCII编码，它们是 ISO-8859-1~ISO-8859-15，其中ISO-8859-1涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1仍然是单字节编码，它总共能表示256个字符。</p>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p>
<h3 id="GBK（扩展GB2312）"><a href="#GBK（扩展GB2312）" class="headerlink" title="GBK（扩展GB2312）"></a>GBK（扩展GB2312）</h3><p>全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p>
<h3 id="GB18030（兼容GB2312）"><a href="#GB18030（兼容GB2312）" class="headerlink" title="GB18030（兼容GB2312）"></a>GB18030（兼容GB2312）</h3><p>全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。</p>
<h3 id="Unicode编码集"><a href="#Unicode编码集" class="headerlink" title="Unicode编码集"></a>Unicode编码集</h3><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</p>
<p>编码规则</p>
<ul>
<li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。</li>
<li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li>
<li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 </li>
</ul>
<h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>采用4个字节进行编码，就空间而已，其效率最差；另外其不像UTF-16,可以很容易的判断出下一个字符的开始位置，因此并不如其它Unicode编码用得广泛；</p>
<h2 id="静态代理和动态代理的区别，什么场景使用？"><a href="#静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="静态代理和动态代理的区别，什么场景使用？"></a>静态代理和动态代理的区别，什么场景使用？</h2><p>代理模式: 是经常用到的设计模式，代理模式是给指定对象提供代理对象。由代理对象来控制具体对象的引用。</p>
<p>静态代理: 由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</p>
<p>动态代理: 在程序运行时，运用反射机制动态创建而成。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。</li>
<li>静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</li>
<li>动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。</li>
</ul>
<h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><p>Throwable类所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。</p>
<p>Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 </p>
<p>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。 </p>
<p>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 </p>
<p>非运行时异常：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h2 id="java解析与分派"><a href="#java解析与分派" class="headerlink" title="java解析与分派"></a>java解析与分派</h2><p>解析：Java中方法调用的目标方法在Class文件里面都是常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。这种解析的前提是：方法在程序真正运行之前就有一个可以确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，即“编译期可知，运行期不可变”，这类目标的方法的调用称为解析（Resolve）。</p>
<p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合条件的有静态方法（invokestatic指令）、私有方法、实例构造方法、父类方法（这3个是invokespecial指令），它们在类加载的的解析阶段就会将符号引用解析为该方法的直接引用。</p>
<p>分派：解析调用一定是个静态的过程，在编译期就完全确定，在类加载的解析阶段就将涉及的符号引用全部转变为可以确定的直接引用，不会延迟到运行期再去完成。而分派（Dispatch）调用则可能是静态的也可能是动态的。分派是多态性的体现，Java虚拟机底层提供了我们开发中“重载”(Overload)“和重写”(Override)的底层实现。其中重载属于静态分派，而重写则是动态分派的过程。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><ul>
<li>1 加载：通过类的全限定名来获取此类的二进制字节流，将这个字节流代表的静态储存结构转化成方法区运行时的数据结构，在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据访问入口。</li>
<li>2 验证：验证这个类的合法性，并且不会危害到虚拟机自身的安全。文件格式验证，元数据验证(符合类标准)，字节码验证，符号引用验证。</li>
<li>3 准备：这个阶段正式为类变量分配内存并设置初始值。这些变量都会在方法区中分配。因为在方法区中分配，所以这个阶段处理的都是一些static修饰的变量，不包括实例变量的。</li>
<li>4 解析：在这个阶段，主要是虚拟机将常量池中的符号引用代替为直接引用。解析动作主要针对类/接口，字段，类方法，接口方法四类符号引用进行。</li>
<li>5 初始化：准备的时候赋值为0，那么我们在程序中是显示为a初始化为10的，所以现在，我们得把这个a初始化为10了。</li>
<li>6 使用</li>
<li>7 卸载：虚拟机会在代码中当代表类的Class对象不再被引用时，即不可达时，Class对象就会结束生命周期，此类在方法区内的数据也会被卸载，从而结束此类的生命周期。</li>
</ul>
<h2 id="Java中实现多态的机制是什么？"><a href="#Java中实现多态的机制是什么？" class="headerlink" title="Java中实现多态的机制是什么？"></a>Java中实现多态的机制是什么？</h2><p>编译多态-又称静态多态：主要是体现在重载，系统在编译时就能确定调用重载函数的哪个版本。<br>运行多态-又称动态多态：主要体现在OO设计的继承性上，子类的对象也是父类的对象，即上溯造型，所以子类对象可以作为父类对象使用，父类的对象变量可以指向子类对象。因此通过一个父类发出的方法调用可能执行的是方法在父类中的实现，也可能是某个子类中的实现，它是由运行时刻具体的对象类型决定的。</p>
<h2 id="如何将一个Java对象序列化到文件里？"><a href="#如何将一个Java对象序列化到文件里？" class="headerlink" title="如何将一个Java对象序列化到文件里？"></a>如何将一个Java对象序列化到文件里？</h2><p>Java中要实现将对象保存起来持久化，需要让对象实现Serializable接口。写入序列化数据到文件中，主要是两个对象，一个对象是FileOutputStream 对象，一个是ObjectOutputStream 对象，ObjectOutputStream 负责向指定的流中写入序列化的对象。当从文件中读取序列化数据时，主要需要两个对象，一个是FileInputStream ，一个是ObjectInputStream 对象，ObjectInputStream 负责从指定流中读取序列化数据并还原成序列化前得对象。</p>
<h2 id="编译——–静态-运行———动态"><a href="#编译——–静态-运行———动态" class="headerlink" title="编译——–静态      运行———动态"></a>编译——–静态      运行———动态</h2><h2 id="java-反射"><a href="#java-反射" class="headerlink" title="java 反射"></a>java 反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。动态机制。</p>
<p>功能：在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。</p>
<p>反射获得信息： 类中有什么信息，它就可以获得什么信息，不过前提是得知道类的名字。</p>
<p>动态语言：程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。</p>
<h2 id="java-注解"><a href="#java-注解" class="headerlink" title="java 注解"></a>java 注解</h2><p>注解（Annotation）：是JDK1.5引入的新特性，包含在java.lang.annotation包中，它是附加在代码中的一些元信息，将一个类的外部信息与内部成员联系起来，在编译、运行时进行解析和使用。因为本质上，Annotion是一种特殊的接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。</p>
<p>元数据(metadata)：所谓元数据就是数据的数据。也就是说，元数据是描述数据的。就象数据表中的字段一样，每个字段描述了这个字段<br>下的数据的含义。</p>
<p>1.5四种元注解，专门注解其他的注解：</p>
<ul>
<li>@Documented–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。</li>
<li><p>@Retention– 定义该注解的生命周期。</p>
<p> RetentionPolicy.SOURCE – 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</p>
<p> RetentionPolicy.CLASS – 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。</p>
<p> RetentionPolicy.RUNTIME– 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p>
</li>
<li><p>@Target – 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。以下是一些可用的参数。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。</p>
</li>
<li>@Inherited – 定义该注释和子类的关系</li>
</ul>
<h2 id="java依赖注入"><a href="#java依赖注入" class="headerlink" title="java依赖注入"></a>java依赖注入</h2><p>依赖：如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。</p>
<p>依赖注入：非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Father father;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.father = father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="java-泛型"><a href="#java-泛型" class="headerlink" title="java 泛型"></a>java 泛型</h2><p>原理：Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<p>擦出规则：</p>
<ul>
<li><t>擦除后变为Obecjt</t></li>
<li>&lt;? extends A&gt;擦除后变为A</li>
<li>&lt;？ super A&gt;擦除后变为Object</li>
</ul>
<h2 id="String为什么要设计成不可变的"><a href="#String为什么要设计成不可变的" class="headerlink" title="String为什么要设计成不可变的"></a>String为什么要设计成不可变的</h2><p>1 字符串常量池的需要:字符串常量池(String pool, String intern pool, String保留池) 是Java堆内存中一个特殊的存储区域, 当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。</p>
<p>2 允许String对象缓存HashCode:字符串不变性保证了hash码的唯一性,因此可以放心地进行缓存.这也是一种性能优化手段,意味着不必每次都去计算新的哈希码.</p>
<p>3 安全性:不可变对象天生就是线程安全的,String被许多的Java类(库)用来当做参数,例如 网络连接地址URL,文件路径path,还有反射机制所需要的String参数等, 假若String不是固定不变的,将会引起各种安全隐患。</p>
<h2 id="Object类的equal和hashCode方法重写"><a href="#Object类的equal和hashCode方法重写" class="headerlink" title="Object类的equal和hashCode方法重写"></a>Object类的equal和hashCode方法重写</h2><p>在Java API文档中关于hashCode方法有以下几点规定：</p>
<ul>
<li>1 在java应用程序执行期间，如果在equals方法比较中所用的信息没有被修改，那么在同一个对象上多次调用hashCode方法时必须一致地返回相同的整数。如果多次执行同一个应用时，不要求该整数必须相同。<ul>
<li>2 如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。</li>
<li>3 如果两个对象通过调用equals方法是不相等的，不要求这两个对象调用hashCode方法必须返回不同的整数。但是程序员应该意识到对不同的对象产生不同的hash值可以提供哈希表的性能。</li>
</ul>
</li>
</ul>
<p>通过前面的分析，我们知道在Object类中，hashCode方法是通过Object对象的地址计算出来的，因为Object对象只与自身相等，所以同一个对象的地址总是相等的，计算取得的哈希码也必然相等，对于不同的对象，由于地址不同，所获取的哈希码自然也不会相等。因此到这里我们就明白了，如果一个类重写了equals方法，但没有重写hashCode方法，将会直接违反了第二点，这样的话，如果我们通过映射表(Map接口)操作相关对象时，就无法达到我们预期想要的效果。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p>1 普通集合类中线程安全的集合：Vector  &amp;&amp; Stack</p>
<p>2 Concurrent包中提供的线程安全集合()：ConcurrentHashMap，ConcurrentLinkedDeque，ConcurrentLinkedQueueConcurrentSkipListMap，ConcurrentSkipSet，CopyOnWriteArrayList，CopyOnWriteArraySet。</p>
<p>3 具体看下ReentranLock(可重入锁机制)：</p>
<h2 id="集合以及集合之间的继承关系"><a href="#集合以及集合之间的继承关系" class="headerlink" title="集合以及集合之间的继承关系"></a>集合以及集合之间的继承关系</h2><p><img src="http://oc4zuck5v.bkt.clouddn.com/collection.png" alt=""></p>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>Iterator接口，这是一个用于遍历集合中元素的接口，主要包含hashNext(),next(),remove()三种方法。</p>
<h3 id="Collection-（集合的最大接口）继承关系"><a href="#Collection-（集合的最大接口）继承关系" class="headerlink" title="Collection （集合的最大接口）继承关系"></a>Collection （集合的最大接口）继承关系</h3><p>Collection定义了集合框架的共性功能:add(e),addAll(collection),remove(e),removeAll(),clear(),contains(e),isEmpty(),iterator(),size(),retainAll(),toArray()。</p>
<ul>
<li>List　可以存放重复的内容</li>
<li>Set　　不能存放重复的内容，所以的重复内容靠hashCode()和equals()两个方法区分</li>
<li>Queue　　队列接口</li>
<li>SortedSet　　可以对集合中的数据进行排序</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特有方法。凡是可以操作角标的方法都是该体系特有的方法:</p>
<ul>
<li>add(index,element)</li>
<li>addAll(index,Collection)</li>
<li>remove(index)</li>
<li>set(index,element)</li>
<li>get(index)</li>
<li>subList(from,to)</li>
<li>listIterator()</li>
<li>int indexOf(obj)</li>
<li>ListIterator listIterator()</li>
</ul>
<p>ArrayList 　　线程不安全，查询速度快</p>
<p>Vector　　线程安全，但速度慢，已被ArrayList替代</p>
<p>LinkedList　　链表结果，增删速度快</p>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set：元素是无序(存入和取出的顺序不一定一致)，元素不可以重复。<br> HashSet:底层数据结构是哈希表。是线程不安全的。不同步。<br> HashSet是如何保证元素唯一性的呢？<br> 　　　　是通过元素的两个方法，hashCode和equals来完成。<br> 　　　　如果元素的HashCode值相同，才会判断equals是否为true。<br> 　　　　如果元素的hashcode值不同，不会调用equals。注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。<br>TreeSet：<br>有序的存放：TreeSet　　<br>线程不安全，可以对Set集合中的元素进行排序通过compareTo或者compare方法来保证元素的唯一性，元素以二叉树的形式存放。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="List：add-remove-get-set。"><a href="#List：add-remove-get-set。" class="headerlink" title="List：add/remove/get/set。"></a>List：add/remove/get/set。</h3><p>　　　　<br>1，ArrayList：其实就是数组，容量一大，频繁增删就是噩梦，适合随机查找；<br>2，LinkedList：增加了push/[pop|remove|pull]，其实都是removeFirst；<br>3，Vector：历史遗留产物，同步版的ArrayList，代码和ArrayList太像；<br>4，Stack：继承自Vector。Java里其实没有纯粹的Stack，可以自己实现，用组合的方式，封装一下LinkedList即可；<br>5，Queue：本来是单独的一类，不过在SUN的JDK里就是用LinkedList来提供这个功能的，主要方法是offer/pull/peek，因此归到这里呢。
　　　　</p>
<h3 id="Set：add-remove。可以用迭代器或者转换成list。"><a href="#Set：add-remove。可以用迭代器或者转换成list。" class="headerlink" title="Set：add/remove。可以用迭代器或者转换成list。"></a>Set：add/remove。可以用迭代器或者转换成list。</h3><p>1，HashSet：内部采用HashMap实现的；<br>2，LinkedHashSet：采用LinkedHashMap实现；<br>3，TreeSet：TreeMap。
　　　　</p>
<h3 id="Map：put-get-remove。"><a href="#Map：put-get-remove。" class="headerlink" title="Map：put/get/remove。"></a>Map：put/get/remove。</h3><p>1，HashMap/HashTable：散列表，和ArrayList一样采用数组实现，超过初始容量会对性能有损耗；<br>2，LinkedHashMap：继承自HashMap，但通过重写嵌套类HashMap.Entry实现了链表结构，同样有容量的问题；<br>3，Properties：是继承的HashTable。</p>
<h2 id="有了进程为什么还要线程？"><a href="#有了进程为什么还要线程？" class="headerlink" title="有了进程为什么还要线程？"></a>有了进程为什么还要线程？</h2><p>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。<br>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。  </p>
<h2 id="如何控制某个方法允许并发访问线程的个数？"><a href="#如何控制某个方法允许并发访问线程的个数？" class="headerlink" title="如何控制某个方法允许并发访问线程的个数？"></a>如何控制某个方法允许并发访问线程的个数？</h2><p>Semaphore mSemaphore = new Semaphore(5);  </p>
<p>Semaphore两个重要的方法就是：</p>
<p>semaphore.acquire() 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p>
<p>semaphore.release() 释放一个信号量，此时信号量个数+1</p>
<h2 id="线程如何关闭"><a href="#线程如何关闭" class="headerlink" title="线程如何关闭"></a>线程如何关闭</h2><p>1 使用共享变量（shared variable）发出信号，让线程自己退出。<br>2 使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。<br>3 使用interrupt方法中断线程。</p>
<h2 id="线程间操作List"><a href="#线程间操作List" class="headerlink" title="线程间操作List"></a>线程间操作List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Long&gt; list  = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Long&gt;());</span><br></pre></td></tr></table></figure>
<h2 id="synchronize的原理"><a href="#synchronize的原理" class="headerlink" title="synchronize的原理"></a>synchronize的原理</h2><p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<p>1.如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。<br>2.如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.<br>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<h2 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a>死锁的条件</h2><ul>
<li>（1） 互斥条件：一个资源每次只能被一个进程使用。</li>
<li>（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-线程与CPU" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/26/线程与CPU/" class="article-date">
  	<time datetime="2018-01-25T16:00:00.000Z" itemprop="datePublished">2018-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/26/线程与CPU/">
        线程与CPU
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="线程与CPU"><a href="#线程与CPU" class="headerlink" title="线程与CPU"></a>线程与CPU</h1><p>线程是最小的调度单位，在很多情况下为了使APP更加流程地运行，我们不可能将很多事情都放在主线程上执行，这样会造成严重卡顿（ANR），那么这些事情应该交给子线程去做，但对于一个系统而言，创建、销毁、调度线程的过程是需要开销的，所以我们并不能无限量地开启线程，那么对线程的了解就变得尤为重要了。</p>
<p>CPU中央处理器(Central Processing Unit)是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。</p>
<h2 id="CPU核数"><a href="#CPU核数" class="headerlink" title="CPU核数"></a>CPU核数</h2><p>一般来讲CPU的核数和线程同时运行的个数是相等的，因此合数越多，多线程处理能力越强。</p>
<h3 id="CPU超线程"><a href="#CPU超线程" class="headerlink" title="CPU超线程"></a>CPU超线程</h3><p>CPU超线程就是利用特殊字符的硬件指令，把两个逻辑内核模拟成物理芯片，让单个处理器能使用线程级并行计算，从而兼容多线程并行计算，从而兼容多线程操作系统和软件，使运行性能提高。也就是说，支持超线程技术的cpu单核可以同时运行两个线程，也就是俗称的伪双核，但其实单核超线程的性能要比双核的差。</p>
<h3 id="线程池的线程数"><a href="#线程池的线程数" class="headerlink" title="线程池的线程数"></a>线程池的线程数</h3><p>如果是CPU密集型应用，则线程池大小设置为N+1</p>
<p>如果是IO密集型应用，则线程池大小设置为2N+1</p>
<p>CPU密集型任务：尽量使用较小的线程池，一般为CPU核心数+1。因为CPU密集型任务得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。</p>
<p>IO密集型任务：可以使用稍大的线程池，一般为2*CPU核心数。IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</p>
<p>混合型任务：可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。 因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p>
<h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><h3 id="Thread-Runnable-Callable"><a href="#Thread-Runnable-Callable" class="headerlink" title="Thread/Runnable/Callable"></a>Thread/Runnable/Callable</h3><h4 id="runnable与callable区别"><a href="#runnable与callable区别" class="headerlink" title="runnable与callable区别"></a>runnable与callable区别</h4><ul>
<li>(1) Callable规定的方法是call()，Runnable规定的方法是run()。其中Runnable可以提交给Thread来包装下，直接启动一个线程来执行，而Callable则一般都是提交给ExecuteService来执行。 </li>
<li>(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值得 </li>
<li>(3) call方法可以抛出异常，run方法不可以 </li>
<li>(4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>表示如果线程池中的某个线程死掉了，线程池会生成一个新的线程代替它。</p>
<h4 id="线程池的作用：线程池作用就是限制系统中执行线程的数量。"><a href="#线程池的作用：线程池作用就是限制系统中执行线程的数量。" class="headerlink" title="线程池的作用：线程池作用就是限制系统中执行线程的数量。"></a>线程池的作用：线程池作用就是限制系统中执行线程的数量。</h4><p>线程池的分配遵循这样的规则：</p>
<ul>
<li>当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；</li>
<li>如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；</li>
<li>如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；</li>
<li>如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。</li>
</ul>
<p>主要参数：</p>
<ul>
<li>corePoolSize：核心运行的poolSize，也就是当超过这个范围的时候，就需要将新的Thread放入到等待队列中了；</li>
<li>maximumPoolSize：一般你用不到，当大于了这个值就会将Thread由一个丢弃处理机制来处理，但是当你发生：newFixedThreadPool的时候，corePoolSize和maximumPoolSize是一样的，而corePoolSize是先执行的，所以他会先被放入等待队列，而不会执行到下面的丢弃处理中，看了后面的代码你就知道了。</li>
<li>workQueue：等待队列，当达到corePoolSize的时候，就向该等待队列放入线程信息（默认为一个LinkedBlockingQueue），运行中的队列属性为：workers，为一个HashSet；内部被包装了一层，后面会看到这部分代码。</li>
<li>keepAliveTime：默认都是0，当线程没有任务处理后，保持多长时间，cachedPoolSize是默认60s，不推荐使用。</li>
<li>threadFactory：是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法即可；</li>
<li>handler：也就是参数maximumPoolSize达到后丢弃处理的方法，java提供了5种丢弃处理的方法，当然你也可以自己弄，主要是要实现接口：RejectedExecutionHandler中的方法：</li>
</ul>
<p>处理任务的优先级为： </p>
<ul>
<li>（1） 核心线程corePoolSize &gt; 任务队列workQueue &gt; 最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 </li>
<li>（2）当池中的线程数大于corePoolSize的时候，多余的线程会等待keepAliveTime长的时间，如果无请求可处理就自行销毁。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Gradle 详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/22/Gradle 详解/" class="article-date">
  	<time datetime="2018-01-21T16:00:00.000Z" itemprop="datePublished">2018-01-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/22/Gradle 详解/">
        Gradle 详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Gradle-详解"><a href="#Gradle-详解" class="headerlink" title="Gradle 详解"></a>Gradle 详解</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。</p>
<p>Android工程通过gradle文件管理各项配置，gradle文件利用DSL（Domain Specific Language）语言描述配置，并使用Groovy语言处理编译逻辑。</p>
<p>Gradle 和 Android 插件独立于 Android Studio 运行。这意味着，可以在 Android Studio 内、使用计算机上的命令行工具或在未安装 Android Studio 的计算机（例如持续性集成服务器）上构建 Android 应用。如果您不使用 Android Studio，可以学习如何从命令行构建和运行您的应用。无论您是从命令行、在远程计算机上还是使用 Android Studio 构建项目，构建的输出都相同。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>Gradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等。</p>
<p>Gradle 工作主要包含三个阶段：</p>
<ul>
<li>首先是初始化阶段。对我们前面的multi-project build而言，就是执行settings.gradle，确定项目project(每个模块都是一个project)对象的个数。</li>
<li>Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过API来添加的。Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。所以，我们可以添加一个HOOK，即当Task关系图建立好后，执行一些操作。</li>
<li>最后一个阶段就是执行任务了。</li>
</ul>
<p>简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。 在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</p>
<h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><h3 id="编译–-gt-DEX–-gt-打包–-gt-签名和对齐"><a href="#编译–-gt-DEX–-gt-打包–-gt-签名和对齐" class="headerlink" title="编译–&gt;DEX–&gt;打包–&gt;签名和对齐"></a>编译–&gt;DEX–&gt;打包–&gt;签名和对齐</h3><p><img src="https://upload-images.jianshu.io/upload_images/2839011-58310b412bae9a01.png?imageMogr2/auto-orient/" alt=""></p>
<ul>
<li>1 Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件(aapt工具)，以及有aidl文件生成的java接口文件(aidl工具)。产出为.class文件。</li>
<li>2 .class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，可能有一个或多个，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。</li>
<li>3 apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。</li>
<li>4 分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。</li>
</ul>
<p>老官网：<br><img src="http://loody.me/images/android_build.png" alt=""></p>
<ul>
<li>1 通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）</li>
<li>2 处理.aidl文件，生成对应的Java接口文件</li>
<li>3 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件</li>
<li>4 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex</li>
<li>5 通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk</li>
<li>6 通过Jarsigner工具，对上面的apk进行debug或release签名</li>
<li>7 通过zipalign工具，将签名后的apk进行对齐处理。</li>
</ul>
<p><img src="http://loody.me/images/android_build_detail.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-麦肯锡工作法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/08/麦肯锡工作法/" class="article-date">
  	<time datetime="2018-01-07T16:00:00.000Z" itemprop="datePublished">2018-01-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/08/麦肯锡工作法/">
        麦肯锡工作法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="麦肯锡工作法"><a href="#麦肯锡工作法" class="headerlink" title="麦肯锡工作法"></a>麦肯锡工作法</h1><h2 id="第一课-麦肯锡专业作风"><a href="#第一课-麦肯锡专业作风" class="headerlink" title="第一课 麦肯锡专业作风"></a>第一课 麦肯锡专业作风</h2><h3 id="客户第一主义"><a href="#客户第一主义" class="headerlink" title="客户第一主义"></a>客户第一主义</h3><h3 id="任何时候都积极应对"><a href="#任何时候都积极应对" class="headerlink" title="任何时候都积极应对"></a>任何时候都积极应对</h3><ul>
<li>绝不逃避，无论身处何种情况，绝不退缩，积极应对-PMA(Positive Mental Attitude-积极心态)。</li>
</ul>
<h3 id="专业人士应该尽善尽美地工作"><a href="#专业人士应该尽善尽美地工作" class="headerlink" title="专业人士应该尽善尽美地工作"></a>专业人士应该尽善尽美地工作</h3><ul>
<li>事情不允许完成一半就讨论，即是全部完成，也要尽善尽美，苛刻要求。</li>
</ul>
<h3 id="修行僧与艺术家"><a href="#修行僧与艺术家" class="headerlink" title="修行僧与艺术家"></a>修行僧与艺术家</h3><ul>
<li>在工作达到自己预设的标准之前决不妥协，一直追求尽善尽美，直到截止日期。</li>
</ul>
<h3 id="勿将调查当工作"><a href="#勿将调查当工作" class="headerlink" title="勿将调查当工作"></a>勿将调查当工作</h3><h3 id="成为独一无二的行家"><a href="#成为独一无二的行家" class="headerlink" title="成为独一无二的行家"></a>成为独一无二的行家</h3><h3 id="不要只解决眼前问题"><a href="#不要只解决眼前问题" class="headerlink" title="不要只解决眼前问题"></a>不要只解决眼前问题</h3><ul>
<li>工作中，我们总是希望尽早解决眼前的问题，以至于只专注于现象本身。但是，这时如果进一步转变关注视角，脱离现象这个框架，就可以发现真正的问题所在。</li>
<li>解决问题至关紧要，但是对于真正问题的把握能力也不容忽视。</li>
</ul>
<h2 id="第二课-麦肯锡式解决问题的基本步骤"><a href="#第二课-麦肯锡式解决问题的基本步骤" class="headerlink" title="第二课 麦肯锡式解决问题的基本步骤"></a>第二课 麦肯锡式解决问题的基本步骤</h2><h3 id="什么是“解决问题”？"><a href="#什么是“解决问题”？" class="headerlink" title="什么是“解决问题”？"></a>什么是“解决问题”？</h3><ul>
<li>解决问题的原意并不是应对已经发生的事情，而是深入研究问题的本质：为什么会出现这种问题，应该如何做才能防止这类问题的发生？继而解决问题。也就是说，应该确定真正的问题所在，然后明确解决该问题的具体策略，并付诸实施，这才是解决问题。</li>
<li>解决问题的步骤：区分问题设定与解答区域-&gt;整理并将客体结构化-&gt;收集信息-&gt;建立假说-&gt;验证假说-&gt;考虑解决方案-&gt;实施解决方案</li>
</ul>
<h3 id="解决问题的基本步骤"><a href="#解决问题的基本步骤" class="headerlink" title="解决问题的基本步骤"></a>解决问题的基本步骤</h3><ul>
<li>1 不要打地鼠：像打地鼠一样只解决眼前的问题 - 要明确希望达到的状态</li>
<li><p>2 解决问题的整体流程</p>
<ul>
<li>1 把握问题结构 ：首先要根据眼前发生的事情，定义问题，锁定问题所在，并将问题的结构可视化，即明确与该问题相关的主要因素。</li>
<li><p>2 分析问题构造的方法–逻辑树：就是前提事件是大数的树干，众多的要因成为分枝。</p>
<p>注意：</p>
<pre><code>* 第一应当做到不漏不重。
* 第二应当根据事实基础进行分析。
* 第三不必深究不太重要的事情。

逻辑树案例
</code></pre><p>   <img src="http://oc4zuck5v.bkt.clouddn.com/luojishu.jpeg" alt=""></p>
</li>
</ul>
</li>
<li><p>3 提出假说，进行分析</p>
</li>
<li><p>4 验证假说的方法–要点树：以关键问题为起点，针对由此推出的诸多要素，验证该假说是否成立。</p>
<p>要点树案例：<br><img src="http://oc4zuck5v.bkt.clouddn.com/yaodianshu.jpeg" alt=""></p>
</li>
<li><p>5 推导解决方案–空雨伞：空指的是事实，即现状如何，雨指的是意义，即这种现状意味着什么，伞指的是解决方案与对策，即从该意义推导出要做什么。以现状、意义、对策为基础进行思考，至关重要。</p>
<p> <img src="http://oc4zuck5v.bkt.clouddn.com/WechatIMG7.jpeg" alt=""></p>
</li>
</ul>
<h3 id="解决问题时必须要注意的要点"><a href="#解决问题时必须要注意的要点" class="headerlink" title="解决问题时必须要注意的要点"></a>解决问题时必须要注意的要点</h3><ul>
<li>1 不要过分局限于现在的状况或制约条件：解决问题意味着实现现有状态或希望达到的状态，即填补目标与现状之间的差距。因此在解决问题的时候，比应该拘泥于现状，而应该站在应有状态或希望达成状态这一更高角度想办法。</li>
<li>2 时刻保持思维的逻辑性：逻辑本意-明辨原因与结果，找到合乎道理的思考方法或判断方法，它可以将含混不清的问题理顺。</li>
<li>3 反复重复为什么：要彻底验证逻辑是否严谨</li>
<li>4 必须考虑”针对谁、做什么、如何做”</li>
</ul>
<h2 id="特别讲-麦肯锡式分析框架的入门工具包"><a href="#特别讲-麦肯锡式分析框架的入门工具包" class="headerlink" title="特别讲 麦肯锡式分析框架的入门工具包"></a>特别讲 麦肯锡式分析框架的入门工具包</h2><h3 id="脑中存有框架"><a href="#脑中存有框架" class="headerlink" title="脑中存有框架"></a>脑中存有框架</h3><h3 id="希望把握整体流程中的重要因素时，采用商业体系"><a href="#希望把握整体流程中的重要因素时，采用商业体系" class="headerlink" title="希望把握整体流程中的重要因素时，采用商业体系"></a>希望把握整体流程中的重要因素时，采用商业体系</h3><p>商业体系：指的是在开展事业时，按照性能区分各类必需的要素，并将其整理为连续的流程。</p>
<h3 id="希望探讨市场战略的基本面时，采用3C框架"><a href="#希望探讨市场战略的基本面时，采用3C框架" class="headerlink" title="希望探讨市场战略的基本面时，采用3C框架"></a>希望探讨市场战略的基本面时，采用3C框架</h3><p>3C:取自于客户(customer)、竞争对手(competitor)、公司(company)，该框架是通过分析自己公司现在所处的经营环境，灵活地开发经营课题，制定战略等，并非单纯用于明确自己公司的情况。</p>
<h3 id="希望重新评估组织时，采用7S框架"><a href="#希望重新评估组织时，采用7S框架" class="headerlink" title="希望重新评估组织时，采用7S框架"></a>希望重新评估组织时，采用7S框架</h3><p>硬件：</p>
<ul>
<li>战略：打造开拓市场，增加占有率，消减成本，开发新产品等企业优势，定位企业方向性的活动及活动计划。</li>
<li>组织构造：规定组织形态与管理体制，明确部门间的任务划分等在完成事业时所必需的人力与物力的变动情况。</li>
<li>公司体系：从业务操作到财务等事业必需的信息体系，经营计划及预算管理，决策结构，人事评定，聘用培养等结构。</li>
</ul>
<p>软件</p>
<ul>
<li>组织文化：经营方式，公司风气，潜藏的企业文化及传统。</li>
<li>组织具备的优势：组织拥有的优越性。</li>
<li>人才：拥有各种能力，经历潜力的组织内部人才。</li>
<li>共同的价值观：全体成员共有的理念，梦想，目标及开展事业活动时依据的价值观等。</li>
</ul>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/WechatIMG8.jpeg" alt=""></p>
<h3 id="不知道该如何选择时，采用位置矩阵"><a href="#不知道该如何选择时，采用位置矩阵" class="headerlink" title="不知道该如何选择时，采用位置矩阵"></a>不知道该如何选择时，采用位置矩阵</h3><p>位置矩阵：指的是有助于明确”紧急、重要的事件“以及实践行动优先顺序的框架。</p>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/WechatIMG9.jpeg" alt=""></p>
<h3 id="希望寻求解决问题的真正方法时，采用逻辑树框架"><a href="#希望寻求解决问题的真正方法时，采用逻辑树框架" class="headerlink" title="希望寻求解决问题的真正方法时，采用逻辑树框架"></a>希望寻求解决问题的真正方法时，采用逻辑树框架</h3><h2 id="第三课-麦肯锡式处理信息的技巧"><a href="#第三课-麦肯锡式处理信息的技巧" class="headerlink" title="第三课 麦肯锡式处理信息的技巧"></a>第三课 麦肯锡式处理信息的技巧</h2><h3 id="调查要基于原始材料"><a href="#调查要基于原始材料" class="headerlink" title="调查要基于原始材料"></a>调查要基于原始材料</h3><h3 id="性感地运用信息"><a href="#性感地运用信息" class="headerlink" title="性感地运用信息"></a>性感地运用信息</h3><p>原封不动的仅仅分析眼前已有的信息或数据，是不性感的，不会产生新的价值。不仅需要分析，而且必须从中创造。</p>
<h3 id="风来时，做木桶的人将如何？"><a href="#风来时，做木桶的人将如何？" class="headerlink" title="风来时，做木桶的人将如何？"></a>风来时，做木桶的人将如何？</h3><p>通过现在的某种信息，可以解读对未来的影响。换言之，为了使对方完成自己希望达成的事情，而考虑如何使用现在的某种信息。</p>
<h2 id="第四课-麦肯锡式提高解决问题能力的思考方法"><a href="#第四课-麦肯锡式提高解决问题能力的思考方法" class="headerlink" title="第四课 麦肯锡式提高解决问题能力的思考方法"></a>第四课 麦肯锡式提高解决问题能力的思考方法</h2><h3 id="不要只从硬币的正反面考虑问题"><a href="#不要只从硬币的正反面考虑问题" class="headerlink" title="不要只从硬币的正反面考虑问题"></a>不要只从硬币的正反面考虑问题</h3><p>思考的顺序是：首先，思考从这件事中可以学到什么，以及其带来的意义；其次，改变视角，按照“空雨伞”的逻辑，落实自己应当采取的行动。</p>
<h3 id="决不放弃的定力"><a href="#决不放弃的定力" class="headerlink" title="决不放弃的定力"></a>决不放弃的定力</h3><h3 id="使五感更敏锐"><a href="#使五感更敏锐" class="headerlink" title="使五感更敏锐"></a>使五感更敏锐</h3><p>不要让自己的身心疲惫，尽量早睡早起，这样五感才能更为敏锐，思维才能更为敏捷。</p>
<p>冥想</p>
<h3 id="边放松边集中"><a href="#边放松边集中" class="headerlink" title="边放松边集中"></a>边放松边集中</h3><h3 id="框架型的思考方法"><a href="#框架型的思考方法" class="headerlink" title="框架型的思考方法"></a>框架型的思考方法</h3><h3 id="超越自己的框架"><a href="#超越自己的框架" class="headerlink" title="超越自己的框架"></a>超越自己的框架</h3><p>推荐方法：有意识地改变自己的行为。</p>
<h3 id="区分事实与意见"><a href="#区分事实与意见" class="headerlink" title="区分事实与意见"></a>区分事实与意见</h3><p>聆听的时候，不要被对方的话所牵引，导致自己思路变得不清晰。只需做到一边倾听对方，一边将对方的话分解为意见与事实。</p>
<h3 id="从疑问出发"><a href="#从疑问出发" class="headerlink" title="从疑问出发"></a>从疑问出发</h3><h3 id="疑问的核心是什么？"><a href="#疑问的核心是什么？" class="headerlink" title="疑问的核心是什么？"></a>疑问的核心是什么？</h3><p>提出疑问时需要注意以下两点：</p>
<p>第一，使疑问做到”一言以弊之”<br>第二，抓住问题的核心</p>
<h3 id="有助于抓住疑问核心的好问题"><a href="#有助于抓住疑问核心的好问题" class="headerlink" title="有助于抓住疑问核心的好问题"></a>有助于抓住疑问核心的好问题</h3><p>提出高质量问题的基本态度：</p>
<ul>
<li>注意对方的反应</li>
<li>带着单纯的好奇心(暂且将自己的想法与考虑搁置一边)</li>
<li>不要评论对方的言论与想法</li>
<li>重视简单的疑问并展开询问</li>
<li>深入地思考与观察</li>
</ul>
<p>改变视角的问题，比如</p>
<ul>
<li>如果你是顾客，希望怎么做？</li>
<li>如果你现在正在工作，你认为自己会在做什么？</li>
<li>从整个人生的角度看，这件事的重要程度有多大？</li>
</ul>
<p>探索原因的问题：</p>
<ul>
<li>在整个过程当中，哪个环节让你感到了压力？</li>
<li>在如今所处的环境中，哪些方面让自己身心愉悦？</li>
<li>尽管想做却并未实际去做的是什么事情？</li>
</ul>
<p>认识对方价值的问题：</p>
<ul>
<li>什么时候，你会感到满足？</li>
<li>对你而言，至关重要且无可取代的事物是什么？</li>
<li>你如何在一天内花掉100万？</li>
</ul>
<h3 id="对是否真实发出疑问"><a href="#对是否真实发出疑问" class="headerlink" title="对是否真实发出疑问"></a>对是否真实发出疑问</h3><p>举例：”我最近很在意自己的体重，所以要去健身房减肥，你觉得A或B哪家健身房比较好？“</p>
<p>疑问是：A或B哪家健身房比较好？</p>
<p>真正的问题其实是在意自己的体重。</p>
<p>实际问题也许在于饮食不均衡，也或许在于生活不规律，而并非仅仅缺乏运动。</p>
<h3 id="勿忘全局"><a href="#勿忘全局" class="headerlink" title="勿忘全局"></a>勿忘全局</h3><p>从全局出发观察事物，提高立足点，开阔视野，也是麦肯锡再三强调的注意事项。</p>
<h3 id="试试电梯测试-30秒描述重点"><a href="#试试电梯测试-30秒描述重点" class="headerlink" title="试试电梯测试-30秒描述重点"></a>试试电梯测试-30秒描述重点</h3><h2 id="麦肯锡式提高自身能力的方法"><a href="#麦肯锡式提高自身能力的方法" class="headerlink" title="麦肯锡式提高自身能力的方法"></a>麦肯锡式提高自身能力的方法</h2><h3 id="发挥自己存在的价值"><a href="#发挥自己存在的价值" class="headerlink" title="发挥自己存在的价值"></a>发挥自己存在的价值</h3><p>大家要准确地把握自己的个性与特质，以及擅长的事情，也可以听取同事，前辈或朋友的意见。至于如何发挥这种优势，应当反复思考，如果有导师，也可以与导师探讨。</p>
<p>我们总是不自觉地希望成为获得自己缺失的性格的人。比如成熟的羡慕性格开朗的人，希望变成那类人。但是，要获得自己缺失的性格，是十分困难的。</p>
<p>不要试图改变自己，成为别人。不断提高原本的自己，才能赢到最后，获得最大的回报。</p>
<h3 id="审视自己的外表和内在"><a href="#审视自己的外表和内在" class="headerlink" title="审视自己的外表和内在"></a>审视自己的外表和内在</h3><p>着手解决某件事情的时候，请务必清楚地辨别自己的能量是否足够。</p>
<h3 id="携带简单的工具"><a href="#携带简单的工具" class="headerlink" title="携带简单的工具"></a>携带简单的工具</h3><h3 id="拥有榜样"><a href="#拥有榜样" class="headerlink" title="拥有榜样"></a>拥有榜样</h3><h3 id="不做批判"><a href="#不做批判" class="headerlink" title="不做批判"></a>不做批判</h3><p>拥抱棘手问题</p>
<h2 id="第六课-麦肯锡式创造成果的能力"><a href="#第六课-麦肯锡式创造成果的能力" class="headerlink" title="第六课 麦肯锡式创造成果的能力"></a>第六课 麦肯锡式创造成果的能力</h2><h3 id="在限定时间内取得成果"><a href="#在限定时间内取得成果" class="headerlink" title="在限定时间内取得成果"></a>在限定时间内取得成果</h3><p>需要锻炼忍耐孤独的意志</p>
<h3 id="即便无法喜欢他，也可以与之产生共鸣、实现共享"><a href="#即便无法喜欢他，也可以与之产生共鸣、实现共享" class="headerlink" title="即便无法喜欢他，也可以与之产生共鸣、实现共享"></a>即便无法喜欢他，也可以与之产生共鸣、实现共享</h3><p>首先，清楚对方是什么样的人。其次，有意识地关注对方的优点与长处。</p>
<h3 id="在领导询问之前汇报"><a href="#在领导询问之前汇报" class="headerlink" title="在领导询问之前汇报"></a>在领导询问之前汇报</h3><h3 id="彰显自己存在感的方法"><a href="#彰显自己存在感的方法" class="headerlink" title="彰显自己存在感的方法"></a>彰显自己存在感的方法</h3><p>保持本我，不强迫自己，同时出色地完成需要自己完成的工作。</p>
<h3 id="摆脱“应当论”的束缚"><a href="#摆脱“应当论”的束缚" class="headerlink" title="摆脱“应当论”的束缚"></a>摆脱“应当论”的束缚</h3><p>与其说麦肯锡的经理自己引领团队，不如说他们巧妙地发挥每个人的能力，使个人成果最大化。</p>
<h3 id="不要一个人完成所有的工作"><a href="#不要一个人完成所有的工作" class="headerlink" title="不要一个人完成所有的工作"></a>不要一个人完成所有的工作</h3><h3 id="设计工作"><a href="#设计工作" class="headerlink" title="设计工作"></a>设计工作</h3><p>使用甘特图表</p>
<p>为了检测自己是否掌握项目所需的要素，也已运用4P思考框架：</p>
<ul>
<li>purpose（初衷）</li>
<li>position（问题定位）</li>
<li>perspective（视角）</li>
<li>period（完成时间）</li>
</ul>
<h3 id="运用“原本模式”"><a href="#运用“原本模式”" class="headerlink" title="运用“原本模式”"></a>运用“原本模式”</h3><p>“我们原本希望做什么？”</p>
<p>通过思考原本如如何，可以发散思维，继而从中发现遗漏之处，或激发全新的创意。</p>
<h3 id="设计会议"><a href="#设计会议" class="headerlink" title="设计会议"></a>设计会议</h3><h3 id="使用我们而非我"><a href="#使用我们而非我" class="headerlink" title="使用我们而非我"></a>使用我们而非我</h3><h3 id="提出有效的质疑"><a href="#提出有效的质疑" class="headerlink" title="提出有效的质疑"></a>提出有效的质疑</h3><p>人一旦直面疑问的核心，或是自己真心期待、希望的事情，表情与声音都会发生改变。</p>
<h2 id="第七课-麦肯锡式演示的技巧"><a href="#第七课-麦肯锡式演示的技巧" class="headerlink" title="第七课 麦肯锡式演示的技巧"></a>第七课 麦肯锡式演示的技巧</h2><h3 id="演示所需要的三要素"><a href="#演示所需要的三要素" class="headerlink" title="演示所需要的三要素"></a>演示所需要的三要素</h3><ul>
<li>只做演示资料</li>
<li>演示资料可用于展示</li>
<li>实际进行演示</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-麦肯锡思维" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/27/麦肯锡思维/" class="article-date">
  	<time datetime="2017-12-26T16:00:00.000Z" itemprop="datePublished">2017-12-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/27/麦肯锡思维/">
        麦肯锡思维
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="麦肯锡思维"><a href="#麦肯锡思维" class="headerlink" title="麦肯锡思维"></a>麦肯锡思维</h1><h2 id="第一章-“做正确的事”与”正确地做事”"><a href="#第一章-“做正确的事”与”正确地做事”" class="headerlink" title="第一章 “做正确的事”与”正确地做事”"></a>第一章 “做正确的事”与”正确地做事”</h2><p>###”做正确的事”与”正确地做事”</p>
<ul>
<li>麦肯锡的原则就是既要正确地做事，更要做正确的事。成功的前提是做正确的事。</li>
<li>做正确的事是前提，不要再错误的路上走远。</li>
<li>过去和现在都是暂时的，关键是未来的目标。</li>
<li>当我们开始每项工作前，首先要明确我们要达到的目标，之后在确定正确的去实施。</li>
<li>明确目标能够提示我们哪些工作重要，哪些次要，哪些要当机立断，哪些要等待时机。避免盲目忙乱的无序状态。既要有长期目标，还要有每一步的短期目标。</li>
</ul>
<h3 id="有效的执行力"><a href="#有效的执行力" class="headerlink" title="有效的执行力"></a>有效的执行力</h3><ul>
<li>效率和效能，分别代表着”正确地做事”和”做正确的事”</li>
<li>麦肯锡强调的是在进入工作状态时，首先要明确做正确的事。</li>
<li>从管理角度来讲，一条障碍最小的曲线，也许才是两点间的最短距离。</li>
</ul>
<h3 id="对正确的评估"><a href="#对正确的评估" class="headerlink" title="对正确的评估"></a>对正确的评估</h3><ul>
<li>想要做出正确的判断，只有深入挖掘和掌握事实，根据实际情况，才能把握正确的方向，发现自己的正确与否。(另外，”病人”诉说的情况并不一定是病因。)</li>
<li>发现正确的问题，是做正确的事的第一步。</li>
</ul>
<h3 id="把眼光放得更远一些"><a href="#把眼光放得更远一些" class="headerlink" title="把眼光放得更远一些"></a>把眼光放得更远一些</h3><h3 id="“正确”永远在变化"><a href="#“正确”永远在变化" class="headerlink" title="“正确”永远在变化"></a>“正确”永远在变化</h3><ul>
<li>居安思危，居危思进</li>
</ul>
<p>##第二章 提高效率的二八原则</p>
<h3 id="按事情的重要程度划分先后次序"><a href="#按事情的重要程度划分先后次序" class="headerlink" title="按事情的重要程度划分先后次序"></a>按事情的重要程度划分先后次序</h3><h3 id="重要的少数和不重要的多数"><a href="#重要的少数和不重要的多数" class="headerlink" title="重要的少数和不重要的多数"></a>重要的少数和不重要的多数</h3><ul>
<li>重要而关键的部分总是占少数，而琐碎不重要的部分总是占大多数。</li>
<li>我们发现只要能够掌控最重要的少数因素，那么就意味着掌控了全局。</li>
<li>当今时代早已不再是平均分配的时代，只有紧跟时代形式，抓准市场规律，把重要的少数放在首位，并投入更多的时间和精力，才能更高效地完成工作。</li>
</ul>
<h3 id="做事的秘诀首先是次序的排序"><a href="#做事的秘诀首先是次序的排序" class="headerlink" title="做事的秘诀首先是次序的排序"></a>做事的秘诀首先是次序的排序</h3><ul>
<li>重要 &gt; 紧急</li>
</ul>
<h3 id="做事情前先要精心分好主次"><a href="#做事情前先要精心分好主次" class="headerlink" title="做事情前先要精心分好主次"></a>做事情前先要精心分好主次</h3><p>注意</p>
<ul>
<li>1 明确自己的长远目标</li>
<li>2 现在我要做什么（哪些是需要我来做的，哪些需要交给别人的）</li>
<li>3 什么样的事情给我的回报最高（把自己80%的经历放在最高回报的事情上）</li>
<li>4 要明确做哪些事能给自己满足感(乐趣)。</li>
</ul>
<h3 id="时间管理的”四象限法则”"><a href="#时间管理的”四象限法则”" class="headerlink" title="时间管理的”四象限法则”"></a>时间管理的”四象限法则”</h3><ul>
<li>第一象限：重要且紧急，紧急意味着需要立即做，重要则意味对个人或团队有重大影响。</li>
<li>第二象限：重要不紧急(时间变通)</li>
<li>第三象限：紧急但不重要</li>
<li>第四象限：不重要也不紧急</li>
<li>总结：重要但不紧急的是最重要的事情，应该在这些事情上分配更多的时间和精力。重要紧急的事情很多由重要不紧急转化来的。</li>
</ul>
<h3 id="放在首位的应该是重要的事情"><a href="#放在首位的应该是重要的事情" class="headerlink" title="放在首位的应该是重要的事情"></a>放在首位的应该是重要的事情</h3><p>要事第一</p>
<ul>
<li>为每天的工作制定一个优先表格</li>
<li>做一个进度表，将重要的事情按顺序写下来</li>
<li>在要求自己遵守时间的同时也要求别人遵守时间</li>
</ul>
<h2 id="第三章-让事实自己说话"><a href="#第三章-让事实自己说话" class="headerlink" title="第三章 让事实自己说话"></a>第三章 让事实自己说话</h2><h3 id="以事实为基础"><a href="#以事实为基础" class="headerlink" title="以事实为基础"></a>以事实为基础</h3><ul>
<li>事实使我们用来铺就解决措施道路的基石。</li>
<li>解决问题时的思路遵循三个规则<ul>
<li>1 以事实为基础</li>
<li>2 严格的结构化</li>
<li>3 以假设作为导向</li>
</ul>
</li>
</ul>
<h3 id="不要落入主观陷阱"><a href="#不要落入主观陷阱" class="headerlink" title="不要落入主观陷阱"></a>不要落入主观陷阱</h3><ul>
<li>方案要从实事中来再回归事实中去，不要将它往自己的框架里面加</li>
<li>反省：<ul>
<li>做事的时候是否实事求是，而不是根据猜测或个人的期望<ul>
<li>2 做出判断时，是否允许他人提出意见</li>
<li>3 是不是能采取个人不喜欢可是又有事实依据的行动</li>
<li>4 找不到问题的根源时，是否延迟等到问题确认才去实施的</li>
<li>5 灵感或者内心感受来做决定</li>
<li>6 自己反感，大家都同意的意见，会不会接受</li>
<li>7 身为负责人，能否为了公司的利益不计个人好恶</li>
<li>8 人事问题不惨杂个人意见</li>
<li>9 交往时，未交流就下结论</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第四章-利用关键驱动点直达问题核心"><a href="#第四章-利用关键驱动点直达问题核心" class="headerlink" title="第四章 利用关键驱动点直达问题核心"></a>第四章 利用关键驱动点直达问题核心</h2><h3 id="识别关键驱动点"><a href="#识别关键驱动点" class="headerlink" title="识别关键驱动点"></a>识别关键驱动点</h3><ul>
<li>要学会丢弃所有不重要的因素，只着眼于关键驱动</li>
</ul>
<h3 id="高效率地达到目的"><a href="#高效率地达到目的" class="headerlink" title="高效率地达到目的"></a>高效率地达到目的</h3><h3 id="日常中的关键驱动点"><a href="#日常中的关键驱动点" class="headerlink" title="日常中的关键驱动点"></a>日常中的关键驱动点</h3><ul>
<li>把握关键驱动点<ul>
<li>1 找准正确的方向<ul>
<li>2 大量收集资料，运用逻辑树状图进行分析研究</li>
<li>3 进行头脑风暴（发散思维来打破惯性思维）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-不重叠，不遗漏的MECE分析法"><a href="#第五章-不重叠，不遗漏的MECE分析法" class="headerlink" title="第五章 不重叠，不遗漏的MECE分析法"></a>第五章 不重叠，不遗漏的MECE分析法</h2><h3 id="相互独立，完全穷尽-MECE-读作”me-see”-全称mutually-exclusive-collectively-exhaustive-“相互独立，完全穷尽”"><a href="#相互独立，完全穷尽-MECE-读作”me-see”-全称mutually-exclusive-collectively-exhaustive-“相互独立，完全穷尽”" class="headerlink" title="相互独立，完全穷尽(MECE 读作”me see”,全称mutually exclusive,collectively exhaustive.-“相互独立，完全穷尽”)"></a>相互独立，完全穷尽(MECE 读作”me see”,全称mutually exclusive,collectively exhaustive.-“相互独立，完全穷尽”)</h3><ul>
<li>相互独立可以让问题的各个方面独立呈现，避免混淆</li>
</ul>
<h3 id="列出你的清单"><a href="#列出你的清单" class="headerlink" title="列出你的清单"></a>列出你的清单</h3><ul>
<li>一份完美的清单所包含的一级项目应该在2-5个之间，3个最理想。</li>
<li>运用MECE法则注意事项：<ul>
<li>1 做到全方位，多角度的考虑问题。(此处推荐六顶思考帽)</li>
<li>2 尽可能多地收集事实依据</li>
<li>3 利用图表分析问题</li>
</ul>
</li>
</ul>
<h2 id="第六章用逻辑分析法呈现严禁推理"><a href="#第六章用逻辑分析法呈现严禁推理" class="headerlink" title="第六章用逻辑分析法呈现严禁推理"></a>第六章用逻辑分析法呈现严禁推理</h2><h3 id="从树干到树枝"><a href="#从树干到树枝" class="headerlink" title="从树干到树枝"></a>从树干到树枝</h3><ul>
<li>罗分析法：分层罗列问题的所有子问题，逐层向下扩展分析。</li>
<li>议题树，假设树和是否树<h3 id="逻辑思维解决复杂问题"><a href="#逻辑思维解决复杂问题" class="headerlink" title="逻辑思维解决复杂问题"></a>逻辑思维解决复杂问题</h3></li>
<li>逻辑推理过程<ul>
<li>第一步：确认需要解决的问题(必须是具体的，其内容必须单一，不可出现组合)<ul>
<li>第二步：分解问题（用议题树，假设树和是否树分析）</li>
<li>第三步：提出次要问题</li>
<li>第四步：制定详细的工作计划（将思维过程转化为可执行的工作计划）</li>
<li>第五步：进行关键分析（脑暴关键点）</li>
<li>第六步：综合分析调查结果，建立论证</li>
<li>第七步：陈述整个工作过程，进行交流沟通</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第七章循序渐进，先摘好摘的果子"><a href="#第七章循序渐进，先摘好摘的果子" class="headerlink" title="第七章循序渐进，先摘好摘的果子"></a>第七章循序渐进，先摘好摘的果子</h2><h3 id="将简单的部分作为起点，然后有步骤地向前推进，从一个真理推出另一个真理，再逐一推出更多真理，从简单到复杂，从浅显到深刻。"><a href="#将简单的部分作为起点，然后有步骤地向前推进，从一个真理推出另一个真理，再逐一推出更多真理，从简单到复杂，从浅显到深刻。" class="headerlink" title="将简单的部分作为起点，然后有步骤地向前推进，从一个真理推出另一个真理，再逐一推出更多真理，从简单到复杂，从浅显到深刻。"></a>将简单的部分作为起点，然后有步骤地向前推进，从一个真理推出另一个真理，再逐一推出更多真理，从简单到复杂，从浅显到深刻。</h3><h3 id="从选择容易的对象开始"><a href="#从选择容易的对象开始" class="headerlink" title="从选择容易的对象开始"></a>从选择容易的对象开始</h3><h3 id="用最短的时间，做更多更容易的事"><a href="#用最短的时间，做更多更容易的事" class="headerlink" title="用最短的时间，做更多更容易的事"></a>用最短的时间，做更多更容易的事</h3><ul>
<li>一个人的能力不是指他用大量的时间去做一件出人意料的事，相反，是能在最短的时间内，做出最容易的事。<h3 id="化整为零，循序渐进"><a href="#化整为零，循序渐进" class="headerlink" title="化整为零，循序渐进"></a>化整为零，循序渐进</h3><h3 id="用心去摘好摘的果子"><a href="#用心去摘好摘的果子" class="headerlink" title="用心去摘好摘的果子"></a>用心去摘好摘的果子</h3><h3 id="奥卡姆剃刀"><a href="#奥卡姆剃刀" class="headerlink" title="奥卡姆剃刀"></a>奥卡姆剃刀</h3><ul>
<li>我会做的事情只有两件，一件是完成简单的事情，一件是把复杂的事情变得简单。</li>
<li>奥卡姆剃刀：如果有多个理论能够解释同一件事，那么其中最简单，最少假设的那个理论就是最可取的。</li>
<li>如无必要，勿增实体</li>
<li>简化的一些方法：<ul>
<li>1 找到重点</li>
<li>2 提高技术水平</li>
<li>3 授权</li>
<li>4 外包</li>
<li>5 取消</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第八章-一次只需要做好一件事"><a href="#第八章-一次只需要做好一件事" class="headerlink" title="第八章 一次只需要做好一件事"></a>第八章 一次只需要做好一件事</h2><h3 id="专打一个垒"><a href="#专打一个垒" class="headerlink" title="专打一个垒"></a>专打一个垒</h3><ul>
<li>在团队中，努力做好自己分内的事，不要试图将整个团队的工作一人包办</li>
<li>原因：<ul>
<li>第一，你不可能把所有人的工作都一个人干完。<ul>
<li>第二，即使你做到了一次，也会让周围的人对你产生不切实际的想法。</li>
<li>第三，这种期望对你的压力非常大，如果你不能满足大家的期望，那你就在他们心中丧失了信誉，想再挽回就很难了。<h3 id="提高穿透力"><a href="#提高穿透力" class="headerlink" title="提高穿透力"></a>提高穿透力</h3></li>
</ul>
</li>
</ul>
</li>
<li>像订书器一样将精力集中到关键点，这样力更大。</li>
<li>想要把所有事做好，就不可能把重要的事做好。</li>
<li>在工作中不要频繁的转换工作状态，做好一件事再去做别的。</li>
<li>一次只做一件事，提高穿透力，让自己时刻掌握主动权，几点建议<ul>
<li>1 学会摆脱事物 - 拒绝一部分，或分配出一部分</li>
<li>2 学会摆脱人</li>
<li>3 学会摆脱过去 - 过去的错误不应该成为你的包袱，过去的荣誉也不是你长久的资本，摆脱那些干扰，只专注于现在。</li>
</ul>
</li>
</ul>
<h2 id="第九章筛选资料，应对信息干扰"><a href="#第九章筛选资料，应对信息干扰" class="headerlink" title="第九章筛选资料，应对信息干扰"></a>第九章筛选资料，应对信息干扰</h2><h3 id="准备一个大纸篓"><a href="#准备一个大纸篓" class="headerlink" title="准备一个大纸篓"></a>准备一个大纸篓</h3><ul>
<li>文件资料处理意见：<ul>
<li>有些资料需要立即处理，不要耽搁</li>
<li>阅读后保存下来，在阅读时你会发现哪些是你需要的，将其保存。</li>
<li>进一步阅读发现有些东西可以不用，就立即丢掉。</li>
<li>准备一个收纳文件的地方。</li>
</ul>
</li>
</ul>
<h3 id="布里丹选择-（驴，左右两堆草，循环左好右好，饿死）"><a href="#布里丹选择-（驴，左右两堆草，循环左好右好，饿死）" class="headerlink" title="布里丹选择 （驴，左右两堆草，循环左好右好，饿死）"></a>布里丹选择 （驴，左右两堆草，循环左好右好，饿死）</h3><ul>
<li>多个判断点，未做排序，而徘徊不定。</li>
<li>正确的利用信息，首先要对大量的信息做筛选和排序，去粗取精，去伪存真。</li>
</ul>
<h3 id="数字化干扰"><a href="#数字化干扰" class="headerlink" title="数字化干扰"></a>数字化干扰</h3><ul>
<li>过度的信息一旦使人沉溺其中，也会成为一种沉重的负担。</li>
</ul>
<h3 id="头脑内的战争"><a href="#头脑内的战争" class="headerlink" title="头脑内的战争"></a>头脑内的战争</h3><h3 id="设置无干扰区"><a href="#设置无干扰区" class="headerlink" title="设置无干扰区"></a>设置无干扰区</h3><ul>
<li>在特定的时间段对所有的干扰进行屏蔽</li>
</ul>
<h2 id="第十章深陷迷雾时后退一步看清大局"><a href="#第十章深陷迷雾时后退一步看清大局" class="headerlink" title="第十章深陷迷雾时后退一步看清大局"></a>第十章深陷迷雾时后退一步看清大局</h2><h3 id="从选定方向开始"><a href="#从选定方向开始" class="headerlink" title="从选定方向开始"></a>从选定方向开始</h3><ul>
<li>在开始工作之前，你首先要明确自己工作的最终目标是什么。</li>
<li>经常检验一下自己的行进路线，避免因为太匆忙而偏离了方向或迷失了方向。<h3 id="关注”大画面”"><a href="#关注”大画面”" class="headerlink" title="关注”大画面”"></a>关注”大画面”</h3><ul>
<li>一个人如果处于胡乱中，那么就应该主动后退一步，思考一下正在做的事情。</li>
<li>最重要的是关注大画面，你正在做的事是否与大画面吻合。</li>
<li>怎样才能让工作重心和注意力的中心锁定在大画面<ul>
<li>1 简历自己希望的大画面</li>
<li>2 写下你的目标 （贴在显眼的位置）</li>
<li>3 学会切割目标 （庞大的目标往往看上去非常虚幻，容易消磨意志，让人心生疲倦）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="创新要讲究实事求是"><a href="#创新要讲究实事求是" class="headerlink" title="创新要讲究实事求是"></a>创新要讲究实事求是</h3><ul>
<li>对于创新我们应该有一个正确的认识，它的目标是更高效地工作，更完善地发展，如果因为创新而发生停滞甚至倒退的现象，那就不是创新了。</li>
</ul>
<h3 id="认识你自己"><a href="#认识你自己" class="headerlink" title="认识你自己"></a>认识你自己</h3><ul>
<li>在日常忙碌中，不要被纷繁的事情所困扰，要时刻看清自己，胸怀远大的抱负，心中想着宏伟的目标，随时调整自己的方向，调整自己的观念，这样才会获得更高的效能，实现更好的效果。</li>
</ul>
<h2 id="第十一章以矛盾激发思维的”头脑风暴”"><a href="#第十一章以矛盾激发思维的”头脑风暴”" class="headerlink" title="第十一章以矛盾激发思维的”头脑风暴”"></a>第十一章以矛盾激发思维的”头脑风暴”</h2><h3 id="麦肯锡团队的头脑风暴"><a href="#麦肯锡团队的头脑风暴" class="headerlink" title="麦肯锡团队的头脑风暴"></a>麦肯锡团队的头脑风暴</h3><ul>
<li>头脑风暴就像魔方一样，它的每一个面，就是一个事实，而你每一次转动，都会有惊喜的发现，都会得到启发，都会得到答案。</li>
</ul>
<h3 id="头脑风暴的原则"><a href="#头脑风暴的原则" class="headerlink" title="头脑风暴的原则"></a>头脑风暴的原则</h3><ul>
<li>目标：产生新的想法</li>
<li>不需要老生常谈，不要因循守旧，不要人云亦云。</li>
<li>原则：<ul>
<li>1 特定问题的提出（预先给出问题，叫大家做足准备）</li>
<li>2 营造宽松的氛围，不做任何评价</li>
<li>3 对狂热和夸张的想法给予鼓励（大部分创新出自夸张的想法）</li>
<li>4 在观点上追求数量的最大化</li>
<li>5 在集思广益的基础上建立新的观点</li>
<li>6 不要担心你的意见被否决</li>
<li>7 不要忽略简单问题</li>
<li>8 “准备好扼杀自己的婴儿”</li>
<li>9 合理安排时间</li>
<li>10 做好后勤服务工作 （放送时间，事物）</li>
<li>11 用笔写下来</li>
</ul>
</li>
</ul>
<h3 id="完善头脑风暴容易出现的问题"><a href="#完善头脑风暴容易出现的问题" class="headerlink" title="完善头脑风暴容易出现的问题"></a>完善头脑风暴容易出现的问题</h3><ul>
<li>1 头脑风暴法的削弱是由社会惰化造成的 （群体越大，个体付出越少）</li>
<li>2 头脑风暴法中有”冒险转移”的潜在问题</li>
<li>3 对上级的服从观点，妨碍了新观点的产生</li>
</ul>
<h3 id="脑暴注意事项"><a href="#脑暴注意事项" class="headerlink" title="脑暴注意事项"></a>脑暴注意事项</h3><ul>
<li>1 领导尽量回避</li>
<li>2 选择适宜的环境</li>
<li>3 如何认识批评和指责</li>
<li>4 培养创新思维方式</li>
<li>5 要有确定的主题 - 不能偏题</li>
<li>6 对方案最好分析</li>
</ul>
<h2 id="第十二章每天一个图标管理你的工作"><a href="#第十二章每天一个图标管理你的工作" class="headerlink" title="第十二章每天一个图标管理你的工作"></a>第十二章每天一个图标管理你的工作</h2><h3 id="做好一张简单的表格"><a href="#做好一张简单的表格" class="headerlink" title="做好一张简单的表格"></a>做好一张简单的表格</h3><ul>
<li>记录每天最重要的事，或者一闪而过的想法观点</li>
<li>表格的目的：使每天的工作明确</li>
</ul>
<h3 id="工作日志的意义"><a href="#工作日志的意义" class="headerlink" title="工作日志的意义"></a>工作日志的意义</h3><ul>
<li>无论工作还是生活，时常做一些反思，总结一下得失，汲取一些经验教训，这对改进工作，提高生活质量都是大有益处的。</li>
<li>每天无论如何让也要挤出一点时间，把一天的工作像过电影一样回顾一遍，既从中发现自己的成绩，也查找自己的疏漏，看有什么地方需要改进，并做好记录。</li>
<li>好处<ul>
<li>工作日志使你的工作作风更加严谨</li>
<li>增强你的逻辑思维能力</li>
<li>每天变得有意义</li>
<li>通过总结，提高文字表达能力</li>
<li>为后代做一个表率</li>
</ul>
</li>
</ul>
<h3 id="将每日总结作为一种习惯"><a href="#将每日总结作为一种习惯" class="headerlink" title="将每日总结作为一种习惯"></a>将每日总结作为一种习惯</h3><p>作用：</p>
<ul>
<li>省时，是工作总结完善</li>
<li>提高执行力和工作主动性</li>
<li>保证工作的衔接</li>
<li>积累工作经验</li>
</ul>
<h3 id="如何记录工作日志"><a href="#如何记录工作日志" class="headerlink" title="如何记录工作日志"></a>如何记录工作日志</h3><p>注意：</p>
<ul>
<li>1 明确每天开始的第一件事就是制定一天的工作计划。</li>
<li>2 制定计划要严肃认真，不要被干扰。</li>
<li>3 计划要与工作实际相结合，必须是符合实际的，能在当天予以落实。</li>
<li>4 计划一旦制定，就要认真执行</li>
<li>5 总结要突出重点，不用长篇累叙</li>
<li>6 注意阶段性总结，半个月，一个月一次。</li>
</ul>
<h2 id="第十三章迅速沟通的”30秒电梯法则”"><a href="#第十三章迅速沟通的”30秒电梯法则”" class="headerlink" title="第十三章迅速沟通的”30秒电梯法则”"></a>第十三章迅速沟通的”30秒电梯法则”</h2><p>###快速且清晰地表达自己的意图</p>
<ul>
<li>电梯法则真正的核心在于要求当事者在做简要说明时必须谈到问题的核心或站在对方立场上关注他所想看到的并进行强调，且要迅速有力地突出强调，有效地将自己的意思传达给对方，而不要受到其他相关信息的干扰。</li>
</ul>
<h3 id="“知、感、行”"><a href="#“知、感、行”" class="headerlink" title="“知、感、行”"></a>“知、感、行”</h3><ul>
<li>知：你要做的第一步就是要清晰地表达自己，让对方明白你所了解的就是他想明白的事情。</li>
<li>感：在自己表达结束后，必须让对方有想表达自个意愿的意思，当然我们不可能让他一定对我们所说的产生想法，但必须让他明白你通过自我的表达来营销的，而且以此作为自己的个人要求。</li>
<li>行：在清楚地表达自己的观点之后，必须让对方有所行动，例如赞成你的所有观点，并且请你详细地解释你的想法和原因。</li>
</ul>
<h2 id="第十四章在有限的时间内达到目的的走访法则"><a href="#第十四章在有限的时间内达到目的的走访法则" class="headerlink" title="第十四章在有限的时间内达到目的的走访法则"></a>第十四章在有限的时间内达到目的的走访法则</h2><h2 id="第十五章与客户一起工作"><a href="#第十五章与客户一起工作" class="headerlink" title="第十五章与客户一起工作"></a>第十五章与客户一起工作</h2><h3 id="让客户与你站一起"><a href="#让客户与你站一起" class="headerlink" title="让客户与你站一起"></a>让客户与你站一起</h3><h3 id="与客户中的”讨债鬼”打交道"><a href="#与客户中的”讨债鬼”打交道" class="headerlink" title="与客户中的”讨债鬼”打交道"></a>与客户中的”讨债鬼”打交道</h3><ul>
<li>一类是作用不大或者没什么用的人，其二就是有意与你作对的人，最好将这两类人都请出你的团队。<h3 id="不要让客户置身事外"><a href="#不要让客户置身事外" class="headerlink" title="不要让客户置身事外"></a>不要让客户置身事外</h3></li>
</ul>
<h2 id="第十六章一个人不可能煮沸整个海洋"><a href="#第十六章一个人不可能煮沸整个海洋" class="headerlink" title="第十六章一个人不可能煮沸整个海洋"></a>第十六章一个人不可能煮沸整个海洋</h2><h3 id="必要的团队精神"><a href="#必要的团队精神" class="headerlink" title="必要的团队精神"></a>必要的团队精神</h3><ul>
<li>培养团队精神：<ul>
<li>1 建立团队的全局观</li>
<li>2 团队精神大于个人利益</li>
<li>3 听取别人的意见<h3 id="正确组织团队"><a href="#正确组织团队" class="headerlink" title="正确组织团队"></a>正确组织团队</h3><h3 id="破冰游戏"><a href="#破冰游戏" class="headerlink" title="破冰游戏"></a>破冰游戏</h3></li>
</ul>
</li>
<li>破冰：打破人与人之间的隔阂，消除人际交往中的猜疑和疏远。</li>
<li>常用的破冰游戏：集体跳绳和连点游戏</li>
</ul>
<h3 id="在团队中保持高昂的士气"><a href="#在团队中保持高昂的士气" class="headerlink" title="在团队中保持高昂的士气"></a>在团队中保持高昂的士气</h3><ul>
<li>麦肯锡管理者将员工分为四类：<ul>
<li>第一类：工作能力强，工作热情高 - 重用鼓励</li>
<li>第二类：工作能力差，工作热情高 - 培训调用</li>
<li>第三类：工作能力强，工作热情低 - 不录用</li>
<li>第四类：工作能力低，工作热情低 - 不留</li>
</ul>
</li>
<li>保持士气原则<ul>
<li>1 把握团队的温度：做好一件事除了掌握方法，很重要的是要让人们乐于去干，这能产生很大的动力，调动人们的积极性和创造性。</li>
<li>2 掌握稳定的过程：要想让团队的工作顺利进行，就要事先做好周密的计划，确定目标。</li>
<li>3 让大家明白当前工作的目的</li>
<li>4 对团队同事的尊重</li>
<li>5 提倡人性化管理</li>
<li>6 遭遇困境要努力支撑下去<h3 id="团队的内部管理要畅通"><a href="#团队的内部管理要畅通" class="headerlink" title="团队的内部管理要畅通"></a>团队的内部管理要畅通</h3></li>
<li>既要了解领导的意图也要让领导了解团队工作的进展</li>
<li>一个有效的信息一般要具备三个条件：即简洁，完整和结构(结构：先说什么后说什么，内容排版)。<h3 id="为集体做好保密工作"><a href="#为集体做好保密工作" class="headerlink" title="为集体做好保密工作"></a>为集体做好保密工作</h3></li>
</ul>
</li>
</ul>
<h2 id="第十七章请向导引领你走出丛林"><a href="#第十七章请向导引领你走出丛林" class="headerlink" title="第十七章请向导引领你走出丛林"></a>第十七章请向导引领你走出丛林</h2><h3 id="不去重新发明轮子"><a href="#不去重新发明轮子" class="headerlink" title="不去重新发明轮子"></a>不去重新发明轮子</h3><ul>
<li>具体做法的建议<ul>
<li>1 运用现有资源也要考虑具体情况</li>
<li>2 先跟随，再赶超</li>
<li>3 找到最佳经验</li>
</ul>
</li>
</ul>
<h3 id="跟随向导走出荆棘"><a href="#跟随向导走出荆棘" class="headerlink" title="跟随向导走出荆棘"></a>跟随向导走出荆棘</h3><h3 id="找准你的导师"><a href="#找准你的导师" class="headerlink" title="找准你的导师"></a>找准你的导师</h3><ul>
<li>导师：导师就是你所从事行业或专业里学有专长的人，对于你当前的学习和工作，他们可以提供指导，建议和帮助。</li>
<li>戒除“我比别人聪明”的心态</li>
</ul>
<h2 id="第十八章从种子到果实的人才培养法则"><a href="#第十八章从种子到果实的人才培养法则" class="headerlink" title="第十八章从种子到果实的人才培养法则"></a>第十八章从种子到果实的人才培养法则</h2><h3 id="压力面试"><a href="#压力面试" class="headerlink" title="压力面试"></a>压力面试</h3><ul>
<li>波特五力模式：进入壁垒，替代品威胁，买方议价能力，卖方议价能力以及现存竞争者之间的竞争。</li>
<li>在压力下，不要让自己情绪失控，要以自信和冷静的态度和专业上的优势，尽量用事实说明问题，化压力为动力。</li>
</ul>
<h3 id="麦肯锡的与员工培训体系"><a href="#麦肯锡的与员工培训体系" class="headerlink" title="麦肯锡的与员工培训体系"></a>麦肯锡的与员工培训体系</h3><h3 id="方法比知识更重要"><a href="#方法比知识更重要" class="headerlink" title="方法比知识更重要"></a>方法比知识更重要</h3><ul>
<li>形成独立的学习方法，要比获得知识更重要。</li>
<li>学习能力：<ul>
<li>1 学会问”为什么”和”怎么样”</li>
<li>2 学会多角度思考问题</li>
<li>3 改进你的方法<h3 id="不晋则退"><a href="#不晋则退" class="headerlink" title="不晋则退"></a>不晋则退</h3></li>
</ul>
</li>
</ul>
<h2 id="第十九章用外出清单管理琐事"><a href="#第十九章用外出清单管理琐事" class="headerlink" title="第十九章用外出清单管理琐事"></a>第十九章用外出清单管理琐事</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 ShenYonghe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>