<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Diablo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Diablo">
<meta property="og:url" content="https://github.com/sirencode/page/7/index.html">
<meta property="og:site_name" content="Diablo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Diablo">
  
    <link rel="alternative" href="/atom.xml" title="Diablo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ShenYonghe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ShenYonghe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ShenYonghe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-gradle 配置信息详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/09/gradle 配置信息详解/" class="article-date">
  	<time datetime="2017-05-08T16:00:00.000Z" itemprop="datePublished">2017-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/09/gradle 配置信息详解/">
        gradle 配置信息详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>一个项目有一个setting.gradle、包括一个顶层的 build.gradle文件、每个Module 都有自己的一个build.gradle文件。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20160902/20160902211134_505.png?_=5855774" alt=""></p>
<h4 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h4><p>这个setting文件定义了哪些module 应该被加入到编译过程，对于单个module 的项目可以不用需要这个文件，但是对于 multimodule 的项目我们就需要这个文件，否则gradle 不知道要加载哪些项目。这个文件的代码在初始化阶段就会被执行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include(':app',</span><br><span class="line">    ':Provider',</span><br><span class="line">    ':data',</span><br><span class="line">    ':Quotation',</span><br><span class="line">    ':Tools',</span><br><span class="line">    ':Notification',</span><br><span class="line">    ':gdt',</span><br><span class="line">    ':im',</span><br><span class="line">    ':BloomplusTradeV3',</span><br><span class="line">    ':easechat',</span><br><span class="line">    ':reddot',</span><br><span class="line">    ':trade')</span><br></pre></td></tr></table></figure>
<h4 id="顶层的build-gradle"><a href="#顶层的build-gradle" class="headerlink" title="顶层的build.gradle"></a>顶层的build.gradle</h4><p>顶层的build.gradle文件的配置最终会被应用到所有项目中。它典型的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath 'com.android.tools.build:gradle:1.2.3'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects&#123;</span><br><span class="line">    repositories&#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Repositories:epositories 就是代码仓库，这个相信大家都知道，我们平时的添加的一些 dependency 就是从这里下载的，Gradle 支持三种类型的仓库：Maven,Ivy和一些静态文件或者文件夹。在编译的执行阶段，gradle 将会从仓库中取出对应需要的依赖文件，当然，gradle 本地也会有自己的缓存，不会每次都去取这些依赖。</li>
<li>buildscript：定义了 Android 编译工具的类路径。repositories中,jCenter是一个著名的 Maven 仓库。</li>
<li>allprojects:中定义的属性会被应用到所有 moudle 中，但是为了保证每个项目的独立性，我们一般不会在这里面操作太多共有的东西。</li>
</ul>
<h4 id="每个项目单独的-build-gradle"><a href="#每个项目单独的-build-gradle" class="headerlink" title="每个项目单独的 build.gradle"></a>每个项目单独的 build.gradle</h4><p>针对每个moudle 的配置，如果这里的定义的选项和顶层build.gradle定义的相同，后者会被覆盖。典型的 配置内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion globalConfiguration.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion globalConfiguration.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId globalConfiguration.android.applicationId</span><br><span class="line">        minSdkVersion globalConfiguration.android.minSdkVersion</span><br><span class="line">        targetSdkVersion globalConfiguration.android.targetSdkVersion</span><br><span class="line">        versionCode APP_VERSION_CODE</span><br><span class="line">        versionName APP_VERSION</span><br><span class="line">        manifestPlaceholders = [</span><br><span class="line">                PACKAGE_NAME: globalConfiguration.android.applicationId</span><br><span class="line">        ]</span><br><span class="line">        multiDexEnabled true</span><br><span class="line">        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"</span><br><span class="line">    &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias "YtxAegis"</span><br><span class="line">            keyPassword "ytxaegis"</span><br><span class="line">            storeFile file("../key_store.jks")</span><br><span class="line">            storePassword "ytxaegis"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        def BOOLEAN = "boolean"</span><br><span class="line">        def TRUE = "true"</span><br><span class="line">        def FALSE = "false"</span><br><span class="line">        def ENV_DEBUG = "ENV_DEBUG"</span><br><span class="line">        def ENABLE_LOG = "ENABLE_LOG"</span><br><span class="line">        def PERFORMANCE_DEBUG = "PERFORMANCE_DEBUG"</span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField BOOLEAN, ENV_DEBUG, FALSE</span><br><span class="line">            buildConfigField BOOLEAN, ENABLE_LOG, FALSE</span><br><span class="line">            buildConfigField BOOLEAN, PERFORMANCE_DEBUG, FALSE</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'</span><br><span class="line">            signingConfig signingConfigs.config</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            buildConfigField BOOLEAN, ENV_DEBUG, TRUE</span><br><span class="line">            buildConfigField BOOLEAN, ENABLE_LOG, TRUE</span><br><span class="line">            buildConfigField BOOLEAN, PERFORMANCE_DEBUG, TRUE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError false</span><br><span class="line">    &#125;</span><br><span class="line">    packagingOptions &#123;</span><br><span class="line">        exclude 'lib/arm64-v8a/librealm-jni.so'</span><br><span class="line">        exclude 'lib/mips/librealm-jni.so'</span><br><span class="line">        exclude 'lib/x86_64/librealm-jni.so'</span><br><span class="line">        exclude 'lib/x86/librealm-jni.so'</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line"></span><br><span class="line">        def NORMAL_TYPE = "\"normal_type\""</span><br><span class="line">        def QIHUO_TYPE = "\"qihuo_type\""</span><br><span class="line">        def PRODUCT_TYPE = "PRODUCT_TYPE"</span><br><span class="line">        def STRING = "String"</span><br><span class="line">        normal &#123;</span><br><span class="line">            buildConfigField STRING, PRODUCT_TYPE, NORMAL_TYPE</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qihuo &#123;</span><br><span class="line">            buildConfigField STRING, PRODUCT_TYPE, QIHUO_TYPE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(include: ['*.jar'], dir: 'libs')</span><br><span class="line"></span><br><span class="line">    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123;</span><br><span class="line">        exclude group: 'com.android.support', module: 'support-annotations'</span><br><span class="line">    &#125;)</span><br><span class="line">    testCompile 'junit:junit:4.12'</span><br><span class="line">    testCompile 'org.mockito:mockito-core:1.10.19'</span><br><span class="line"></span><br><span class="line">    rootProject.dependenciesMethod rootProject.ext.appDps, &#123; type, library, key -&gt;</span><br><span class="line">        if (type == 'compile') &#123;</span><br><span class="line">            compile library</span><br><span class="line">        &#125; else if (type == 'debugCompile') &#123;</span><br><span class="line">            debugCompile library</span><br><span class="line">        &#125; else if (type == 'testCompile') &#123;</span><br><span class="line">            testCompile library</span><br><span class="line">        &#125; else if (type == 'apt') &#123;</span><br><span class="line">            apt library</span><br><span class="line">        &#125; else if (type == 'debuggableReleaseCompile') &#123;</span><br><span class="line">            debuggableReleaseCompile library</span><br><span class="line">        &#125; else if (type == 'debugProCompile') &#123;</span><br><span class="line">            debugProCompile library</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="apply-plugin"><a href="#apply-plugin" class="headerlink" title="apply plugin"></a>apply plugin</h5><p>第一行代码应用了Android 程序的gradle插件，作为Android 的应用程序，这一步是必须的，因为plugin中提供了Android 编译、测试、打包等等的所有task。</p>
<h5 id="android"><a href="#android" class="headerlink" title="android"></a>android</h5><p>这是编译文件中最大的代码块，关于android 的所有特殊配置都在这里，这就是又我们前面的声明的 plugin 提供的。</p>
<ul>
<li>productFlavors:做差异化打包，包括包名，资源等信息的差异化处理。</li>
<li>signingConfigs:签名信息</li>
</ul>
<h5 id="defaultConfig"><a href="#defaultConfig" class="headerlink" title="defaultConfig"></a>defaultConfig</h5><p>就是程序的默认配置，注意，如果在AndroidMainfest.xml里面定义了与这里相同的属性，会以这里的为主。这里最有必要要说明的是applicationId的选项：在我们曾经定义的AndroidManifest.xml中，那里定义的包名有两个用途：一个是作为程序的唯一识别ID,防止在同一手机装两个一样的程序；另一个就是作为我们R资源类的包名。在以前我们修改这个ID会导致所有用引用R资源类的地方都要修改。但是现在我们如果修改applicationId只会修改当前程序的ID,而不会去修改源码中资源文件的引用。</p>
<h5 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h5><p>定义了编译类型，针对每个类型我们可以有不同的编译配置，不同的编译配置对应的有不同的编译命令。默认的有debug、release 的类型。</p>
<h5 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h5><p>是属于gradle 的依赖配置。它定义了当前项目需要依赖的其他库。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-android 图形显示" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/08/android 图形显示/" class="article-date">
  	<time datetime="2017-05-07T16:00:00.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/android 图形显示/">
        图形显示
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自：<a href="https://juejin.im/post/590a91ceac502e0058258293" target="_blank" rel="noopener">博客</a></p>
<h3 id="绘制中的角色"><a href="#绘制中的角色" class="headerlink" title="绘制中的角色"></a>绘制中的角色</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><ul>
<li>CPU：Measure，Layout，纹理和多边形生成，发送纹理和多边形到GPU</li>
<li>GPU：将CPU生成的纹理和多边形进行栅格化以及合成</li>
</ul>
<p>Android 4.1 加入的VSync信号同步到上层以及三缓冲</p>
<h4 id="SurfaceFlinger-图形合成者"><a href="#SurfaceFlinger-图形合成者" class="headerlink" title="SurfaceFlinger-图形合成者"></a>SurfaceFlinger-图形合成者</h4><p>作为上层应用的消费者，硬件层的生产者。负责图形的合成，和ActivityManagerService一样，是一个系统服务。</p>
<p>生产者将自己的内容绘制在对应的Surface内，接着，SufaceFlinger需要将所有上层对应的Surface内的图形进行合成。</p>
<h5 id="Surface："><a href="#Surface：" class="headerlink" title="Surface："></a>Surface：</h5><ul>
<li>对应上层的一个Window（对话框、Activity、状态栏）</li>
<li>作为上层图形绘制的画板</li>
<li>Canvas是画笔，上层通过调用Canvas的API向Surface上绘制图形</li>
<li>Surface内部存在多个缓冲区，形成一个BufferQueue</li>
</ul>
<p><img src="https://dn-mhke0kuv.qbox.me/08d0142d954b365dd8f0.png" alt="surface"></p>
<p>Surface内部提供一个BufferQueue，与上层和SurfaceFlinger形成一个生产者消费者模型，上层对应Producer，SurfaceFlinger对应Consumer。三者通过Buffer产生联系，每个Buffer都有四种状态：</p>
<ul>
<li>Free：可被上层使用</li>
<li>Dequeued：出列，正在被上层使用</li>
<li>Queued：入列，已完成上层绘制，等待SurfaceFlinger合成</li>
<li>Acquired：被获取，SurfaceFlinger正持有该Buffer进行合成</li>
</ul>
<p>Buffer的一次转移过程大致为：</p>
<ul>
<li>1 从BufferQueue转移到上层</li>
<li>2 上层绘制完成再放回BufferQueue</li>
<li>3 接着SurfaceFlinger再拿去合成</li>
<li>4 最后又放回BufferQueue</li>
</ul>
<p>如此循环，形成一个Buffer被循环使用的过程。</p>
<h4 id="显示屏"><a href="#显示屏" class="headerlink" title="显示屏"></a>显示屏</h4><p>显示屏上的内容，是从硬件帧缓冲区读取的，大致读取过程为：从Buffer的起始地址开始，从上往下，从左往右扫描整个Buffer，将内容映射到显示屏上。</p>
<p>当然，屏幕上的内容需要需要不断的更新，如果在同一个Buffer进行读取和写入（合成）操作，将会导致屏幕显示多帧内容。所以硬件层除了提供一个Buffer用于屏幕显示，还提供了一个Buffer用于后台的图形合成，也就是我们常说的双缓冲。</p>
<p><img src="https://dn-mhke0kuv.qbox.me/62bd216a289d49f6eb7d.png" alt=""></p>
<p>前缓冲区：用来显示内容到屏幕的帧缓冲区</p>
<p>后缓冲区：用于后台合成下一帧图形的帧缓冲区</p>
<p>屏幕刷新率（HZ）：代表屏幕在一秒内刷新屏幕的次数，Android手机一般为60HZ（也就是1秒刷新60帧，大约16.67毫秒刷新1帧）</p>
<p>系统帧速率（FPS）：代表了系统在一秒内合成的帧数，该值的大小由系统算法和硬件决定。</p>
<p>垂直同步（VSync）：当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，发出的一个同步信号，该信号用来切换前缓冲区和后缓冲区。</p>
<h3 id="Android绘制的主要流程"><a href="#Android绘制的主要流程" class="headerlink" title="Android绘制的主要流程"></a>Android绘制的主要流程</h3><p>生产者 -&gt; 中间处理 -&gt; 显示器</p>
<p>图形的传递是通过Buffer作为载体</p>
<ul>
<li>1 生产者负责生成surface对象并交付给SurfaceFlinger进行合成。</li>
<li>2 SurfaceFlinger将合成好的内容提交到屏幕的后缓冲区，等待屏幕的下一个垂直同步信号的到来，再显示到屏幕上。</li>
</ul>
<p>未加入的VSync信号同步到上层以及三缓冲的处理流程：</p>
<p><img src="https://dn-mhke0kuv.qbox.me/78c6579ffd792d84e129.jpg" alt=""></p>
<ul>
<li>1 CPU和GPU代表上层的绘制执行者</li>
<li>2 Composite代表的是SurfaceFlinger对多个Surface的合成</li>
<li>3 Background Buffer和Front Buffer分别代表的是硬件帧缓冲区中的前缓冲和后缓冲</li>
<li>4 显示屏扫描完一帧之后，会发出VSync信号来切换并显示下一帧</li>
</ul>
<p>上面的流程中，存在一个问题，屏幕的VSync信号只是用来控制帧缓冲区的切换，并未控制上层的绘制节奏，也就是说上层的生产节奏和屏幕的显示节奏是脱离的.</p>
<p>google在Android 4.1系统中加入了上层接收垂直同步信号的逻辑，大致流程如下：</p>
<p><img src="https://dn-mhke0kuv.qbox.me/60c10f0847f270b5c10b.png" alt=""></p>
<p>屏幕在显示完一帧后，发出的垂直同步除了通知帧缓冲区的切换之外，该消息还会发送到上层，通知上层开始绘制下一帧。</p>
<p>只有等到第二个VSync信号来了之后，CPU才开始在绘制下一帧。如果CPU和GPU需要合成的图形太多，将会导致连续性的卡顿，如果CPU和GPU大部分时候都无法在16.6ms完成一帧的绘制，将会导致连续的卡顿现象。</p>
<h5 id="parallel-processing-and-triple-buffering"><a href="#parallel-processing-and-triple-buffering" class="headerlink" title="parallel processing and triple buffering"></a>parallel processing and triple buffering</h5><p>加入第三个Buffer，CPU和GPU还有SurfaceFlinger各占一个Buffer，并行处理图形：</p>
<p><img src="https://dn-mhke0kuv.qbox.me/47a962b7b7e477e031f2.png" alt=""></p>
<p>从上图可以看出，在第一个VSync到来时，尽管SurfaceFlinger占了一个Buffer，GPU又占了一个Buffer，CPU仍然可以在第三个Buffer中开始下一帧的计算，整个显示过程就开始时卡顿了一帧，之后都是流畅的。</p>
<p>当然系统并非一直开启三个Buffer，因为Buffer是需要消耗资源的，并且，我们会发现，上图中，GPU处理好的图形，需要跨越两个VSync信号，才能显示。这样的话，给用户的影响是一个延迟的现象。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-lambda 语法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/05/lambda 语法/" class="article-date">
  	<time datetime="2017-05-04T16:00:00.000Z" itemprop="datePublished">2017-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/05/lambda 语法/">
        lambda 语法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java8之前，我们实现一个简单的、仅有一个方法的接口或者将一个简单的功能作为方法参数时，需要实例化一个匿名类对象，但是它看起来臃肿且不直观。现在，Java8提供了Lambda表达式简化了上述操作。Lambda可以将方法或者代码片段作为数据进行参数传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;&#125;                <span class="comment">// No parameters; result is void</span></span><br><span class="line">() -&gt; <span class="number">42</span>                <span class="comment">// No parameters, expression body</span></span><br><span class="line">() -&gt; <span class="keyword">null</span>              <span class="comment">// No parameters, expression body</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;    <span class="comment">// No parameters, block body with return</span></span><br><span class="line">() -&gt; &#123; System.gc(); &#125;  <span class="comment">// No parameters, void block body</span></span><br><span class="line"></span><br><span class="line">() -&gt; &#123;                 <span class="comment">// Complex block body with returns</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">true</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      result *= i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          </span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> x) -&gt; x+<span class="number">1</span>              <span class="comment">// Single declared-type parameter</span></span><br><span class="line">(<span class="keyword">int</span> x) -&gt; &#123; <span class="keyword">return</span> x+<span class="number">1</span>; &#125;  <span class="comment">// Single declared-type parameter</span></span><br><span class="line">(x) -&gt; x+<span class="number">1</span>                  <span class="comment">// Single inferred-type parameter</span></span><br><span class="line">x -&gt; x+<span class="number">1</span>                    <span class="comment">// Parentheses optional for</span></span><br><span class="line">                            <span class="comment">// single inferred-type parameter</span></span><br><span class="line"></span><br><span class="line">(String s) -&gt; s.length()      <span class="comment">// Single declared-type parameter</span></span><br><span class="line">(Thread t) -&gt; &#123; t.start(); &#125;  <span class="comment">// Single declared-type parameter</span></span><br><span class="line">s -&gt; s.length()               <span class="comment">// Single inferred-type parameter</span></span><br><span class="line">t -&gt; &#123; t.start(); &#125;           <span class="comment">// Single inferred-type parameter</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x+y  <span class="comment">// Multiple declared-type parameters</span></span><br><span class="line">(x, y) -&gt; x+y          <span class="comment">// Multiple inferred-type parameters</span></span><br><span class="line">(x, <span class="keyword">int</span> y) -&gt; x+y    <span class="comment">// Illegal: can't mix inferred and declared types</span></span><br><span class="line">(x, <span class="keyword">final</span> y) -&gt; x+y  <span class="comment">// Illegal: no modifiers with inferred types</span></span><br></pre></td></tr></table></figure>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(e -&gt; &#123; aList.add(e); &#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-javascript 学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/19/javascript 学习/" class="article-date">
  	<time datetime="2017-04-18T16:00:00.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/javascript 学习/">
        javascript 学习笔记
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>JavaScript 有七种内置类型:</p>
<ul>
<li>空值(null)</li>
<li>未定义(undefined)</li>
<li>布尔值( boolean)</li>
<li>数字(number)</li>
<li>字符串(string)</li>
<li>对象(object)</li>
<li>符号(symbol，ES6 中新增)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          === <span class="string">"boolean"</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>            === <span class="string">"number"</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"42"</span>          === <span class="string">"string"</span>;</span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">life</span>: <span class="number">42</span> &#125;  === <span class="string">"object"</span>;</span><br><span class="line"><span class="comment">// ES6中新加入的类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">"symbol"</span>;  </span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">"object"</span>; <span class="comment">// true  </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* .. */</span> &#125; === <span class="string">"function"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h4><p>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。</p>
<h5 id="undefined-和-undeclared"><a href="#undefined-和-undeclared" class="headerlink" title="undefined 和 undeclared"></a>undefined 和 undeclared</h5><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明 过的变量，是 undeclared 的。</p>
<p>对于 undeclared(或者 not defined)变量，typeof 照样返回 “undefined”。这是因为typeof有一个特殊的安全防范机制。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">1</span>, <span class="string">"2"</span>, [<span class="number">3</span>] ];a.length;              <span class="comment">// 3</span>a[<span class="number">0</span>] === <span class="number">1</span>;           <span class="comment">// true</span>a[<span class="number">2</span>][<span class="number">0</span>] === <span class="number">3</span>;        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在创建“稀疏”数组(sparse array，即含有空白或空缺单元的数组)时要特别注意:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="number">0</span>] = <span class="number">1</span>;a[<span class="number">1</span>];       <span class="comment">// undefined</span>a.length;   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="string">"foobar"</span>] = <span class="number">2</span>;a.length; /<span class="number">2</span></span><br><span class="line">a[<span class="string">"foobar"</span>]; /<span class="number">2</span>a.foobar; /<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里有个问题需要特别注意，如果字符串键值能够被强制类型转换为十进制数字的话，它 就会被当作数字索引来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="string">"13"</span>] = <span class="number">42</span>;a.length; <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>
<h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><p>有时需要将类数组(一组通过数字索引的值)转换为真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from( <span class="built_in">arguments</span> );</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但<br>JavaScript 中的字符串和字符数组并不是一回事，最多只是看上去相似而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"foo"</span>;<span class="keyword">var</span> b = [<span class="string">"f"</span>,<span class="string">"o"</span>,<span class="string">"o"</span>];</span><br><span class="line"></span><br><span class="line">a.length;                           <span class="comment">// 3</span>b.length;                           <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a.indexOf( <span class="string">"o"</span> );                   <span class="comment">//1</span>b.indexOf( <span class="string">"o"</span> );                   <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.concat( <span class="string">"bar"</span> );</span><br><span class="line"><span class="keyword">var</span> d = b.concat( [<span class="string">"b"</span>,<span class="string">"a"</span>,<span class="string">"r"</span>] );  <span class="comment">// ["f","o","o","b","a","r"]</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>JavaScript 只有一种数值类型:number(数字)，包括“整数”和带小数的十进制数。</p>
<h5 id="数字的语法"><a href="#数字的语法" class="headerlink" title="数字的语法"></a>数字的语法</h5><p>数字前面的 0 可以省略: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 0.42;var b = .42;</span><br></pre></td></tr></table></figure>
<p>特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a * a;b;                  <span class="comment">// 2.5e+21</span><span class="keyword">var</span> c = <span class="number">1</span> / a;c;                  <span class="comment">// 2e-11</span></span><br></pre></td></tr></table></figure>
<h5 id="较小的数值"><a href="#较小的数值" class="headerlink" title="较小的数值"></a>较小的数值</h5><p>二进制浮点数最大的问题(不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此)，是 会出现如下情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>最常见的方法是设置一个误差范围值，通常称为“机器精度”(machine epsilon)，对<br>JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。</p>
<p>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前<br>的版本写 polyfill:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br></pre></td></tr></table></figure>
<h5 id="整数的安全范围"><a href="#整数的安全范围" class="headerlink" title="整数的安全范围"></a>整数的安全范围</h5><p>能够被“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为 Number.MAX_SAFE_INTEGER。 最 小 整 数 是 -9007199254740991， 在 ES6 中 被 定 义 为 Number. MIN_SAFE_INTEGER。</p>
<h5 id="整数检查"><a href="#整数检查" class="headerlink" title="整数检查"></a>整数检查</h5><p>要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42</span> );     <span class="comment">// true</span><span class="built_in">Number</span>.isInteger( <span class="number">42.000</span> ); <span class="comment">// true</span><span class="built_in">Number</span>.isInteger( <span class="number">42.3</span> );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Number</span>.MAX_SAFE_INTEGER );  <span class="comment">// true</span><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) ); <span class="comment">// false</span><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) - <span class="number">1</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="32-位有符号整数"><a href="#32-位有符号整数" class="headerlink" title="32 位有符号整数"></a>32 位有符号整数</h5><p>虽然整数最大能够达到 53 位，但是有些数字操作(如数位操作)只适用于 32 位数字， 所以这些操作中数字的安全范围就要小很多，变成从 Math.pow(-2,31)(-2147483648， 约-21 亿)到 Math.pow(2,31) - 1(2147483647，约 21 亿)。</p>
<h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><h5 id="不是值的值"><a href="#不是值的值" class="headerlink" title="不是值的值"></a>不是值的值</h5><p>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名<br>称既是类型也是值。</p>
<ul>
<li>null 指空值(empty value)</li>
<li>undefined 指没有值(missing value)</li>
</ul>
<p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而<br>undefined 却是一个标识符，可以被当作变量来使用和赋值。</p>
<h5 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h5><p>表达式void ___没有返回值，因此返回结果是undefined。void并不改变表达式的结果， 只是让表达式不返回值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="keyword">void</span> a, a ); <span class="comment">// undefined 42</span></span><br></pre></td></tr></table></figure>
<p>void 0来获得undefined(这主要源自C语言，当然使用void true或其他 void 表达式也是可以的)。void 0、void 1 和 undefined 之间并没有实质上的区别。</p>
<h5 id="特殊的数字NaN"><a href="#特殊的数字NaN" class="headerlink" title="特殊的数字NaN"></a>特殊的数字NaN</h5><p>如果数学运算的操作数不是数字类型(或者无法解析为常规的十进制或十六进制数字)， 就无法返回一个有效的数字，这种情况下返回值为 NaN。不是数字的数字”仍然是数字类型。NaN 是一个“警戒值”(sentinel value，有特殊用途的常规值)，用于指出数字类型中的错误 情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">"foo"</span>;       <span class="comment">// NaN</span><span class="keyword">typeof</span> a === <span class="string">"number"</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="无穷数"><a href="#无穷数" class="headerlink" title="无穷数"></a>无穷数</h5><p>计算结果一旦溢出为无穷数(infinity)就无法再得到有穷数。换句话说，就是你可以从有 穷走向无穷，但无法从无穷回到有穷。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span>;  <span class="comment">// Infinity</span><span class="keyword">var</span> b = <span class="number">-1</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<h5 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h5><p>JavaScript 有一个常规的 0(也叫作 +0)和一个 -0。在解释为什么会有 -0 之前，我们先来看看 JavaScript 是如何来处理它的。加法和减法运算不会得到负零(negative zero)。</p>
<p>有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度)，数字的符号位 (sign)用来代表其他信息(比如移动的方向)。此时如果一个值为 0 的变量失去了它的符<br>号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。</p>
<h5 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h5><p>ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等，可以用来处理 上述所有的特殊情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">"foo"</span>;<span class="keyword">var</span> b = <span class="number">-3</span> * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( a, <span class="literal">NaN</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">-0</span> ); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">0</span> );  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>能使用 == 和 ===时就尽量不要使用 Object.is(..)，因为前者效率更高、<br>更为通用。Object.is(..) 主要用来处理那些特殊的相等比较。</p>
<h4 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h4><p>JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用 / 指向关系。</p>
<p>JavaScript 对值和引用的赋值 / 传递在语法上没有区别，完全根据值的类型来决定。</p>
<h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><h4 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性 [[Class]]"></a>内部属性 [[Class]]</h4><p>所有 typeof 返回值为 “object” 的对象(如数组)都包含一个内部属性 <a href="我们可 以把它看作一个内部的分类，而非传统的面向对象意义上的类">[Class]</a>。这个属性无法直接访问， 一般通过 Object.prototype.toString(..) 来查看。例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ); <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>
<h4 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h4><p>封装对象(object wrapper)扮演着十分重要的角色。由于基本类型值没有 .length 和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为 基本类型值包装(box 或者 wrap)一个封装对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"abc"</span>;a.length; <span class="comment">// 3</span>a.toUpperCase(); <span class="comment">// "ABC"</span></span><br></pre></td></tr></table></figure>
<p>如果需要经常用到这些字符串属性和方法，比如在for循环中使用i &lt; a.length，那么从 一开始就创建一个封装对象也许更为方便，这样 JavaScript 引擎就不用每次都自动创建了。<br>但实际证明这并不是一个好办法，因为浏览器已经为 .length 这样的常见情况做了性能优 化，直接使用封装对象来“提前优化”代码反而会降低执行效率。</p>
<p>如果想要自行封装基本类型值，可以使用 Object(..) 函数(不带 new 关键字):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"abc"</span>;var b = <span class="keyword">new</span> String( a );var c = Object( a );typeof a; <span class="comment">// "string"</span>typeof b; <span class="comment">// "object"</span>typeof c; <span class="comment">// "object"</span>b <span class="keyword">instanceof</span> String; <span class="comment">// true</span>c <span class="keyword">instanceof</span> String; <span class="comment">// true</span>Object.prototype.toString.call( b ); <span class="comment">// "[object String]"</span>Object.prototype.toString.call( c ); <span class="comment">// "[object String]"</span></span><br></pre></td></tr></table></figure>
<h4 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h4><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> String( <span class="string">"abc"</span> );var b = <span class="keyword">new</span> Number( <span class="number">42</span> );var c = <span class="keyword">new</span> Boolean( <span class="keyword">true</span> );a.valueOf(); <span class="comment">// "abc"</span>b.valueOf(); <span class="comment">// 42</span>c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> String( <span class="string">"abc"</span> ); </span><br><span class="line">var b = a + <span class="string">""</span>; <span class="comment">// b的值为"abc"</span>typeof a;       <span class="comment">// "object"</span>typeof b;       <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure>
<h4 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h4><p>关于数组(array)、对象(object)、函数(function)和正则表达式，我们通常喜欢以常 量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的(创建的值都是 通过封装对象来包装)。应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的 结果。</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">a; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">var b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的。</p>
<p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度(length)，而 非只充当数组中的一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> Array(<span class="number">3</span>);</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h5 id="Object-、Function-和-RegExp"><a href="#Object-、Function-和-RegExp" class="headerlink" title="Object(..)、Function(..) 和 RegExp(..)"></a>Object(..)、Function(..) 和 RegExp(..)</h5><p>同样，除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var c = <span class="keyword">new</span> Object();</span><br><span class="line">c.foo = <span class="string">"bar"</span>;</span><br><span class="line">c; <span class="comment">// &#123; foo: "bar" &#125;</span></span><br><span class="line"></span><br><span class="line">var d = &#123;</span><br><span class="line">  foo: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line">d; <span class="comment">// &#123; foo: "bar" &#125;</span></span><br><span class="line"></span><br><span class="line">var e = <span class="keyword">new</span> Function(<span class="string">"a"</span>, <span class="string">"return a * 2;"</span>);</span><br><span class="line">var f = function (a) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">g</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var h = <span class="keyword">new</span> RegExp(<span class="string">"^a*b+"</span>, <span class="string">"g"</span>);</span><br><span class="line">var i = /^a*b+/g;</span><br></pre></td></tr></table></figure>
<h5 id="Date-和Error"><a href="#Date-和Error" class="headerlink" title="Date()和Error()"></a>Date()和Error()</h5><p>创建日期对象必须使用new Date()。Date(..)可以带参数，用来指定日期和时间，而不带 参数的话则使用当前的日期和时间。</p>
<p>构造函数 Error(..)(与前面的 Array() 类似)带不带 new 关键字都可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"x wasn’t provided"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>符号并非对象，而是一种简单标量基本类型。</p>
<p>符号是具有唯一性的特殊值(并 非绝对)，用它来命名对象属性不容易导致重名。该类型的引入主要源于 ES6 的一些特殊 构造，此外符号也可以自行定义。</p>
<p>我们可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会出错:</p>
<h5 id="原生原型"><a href="#原生原型" class="headerlink" title="原生原型"></a>原生原型</h5><p>原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。<br>根 据 文 档 约 定， 我 们 将 String.prototype.XYZ 简 写 为 String#XYZ， 对 其 他 .prototypes 也同样如此。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">" abc "</span>;</span><br><span class="line">a.indexOf( <span class="string">"c"</span> ); <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase();  <span class="comment">// " ABC "</span></span><br><span class="line">a.trim();         <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 为基本数据类型值提供了封装对象，称为原生函数(如 String、Number、Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如:String#trim() 和 Array#concat(..))。</p>
<p>对于简单标量基本类型值，比如 “abc”，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实 现对这些属性和方法的访问。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h4><p>将值从一种类型转换为另一种类型通常称为类型转换(type casting)，这是显式的情况;隐式的情况称为强制类型转换(coercion)。</p>
<p>JavaScript 中的强制类型转换总是返回标量基本类型值(参见第 2 章)，如字 符串、数字和布尔值，不会返回对象和函数。在第 3 章中，我们介绍过“封 装”，就是为标量基本类型值封装一个相应类型的对象，但这并非严格意义 上的强制类型转换。</p>
<p>也可以这样来区分:类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时(runtime)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = a + <span class="string">""</span>; <span class="comment">// 隐式强制类型转换 </span></span><br><span class="line">var c = String( a ); <span class="comment">// 显式强制类型转换</span></span><br></pre></td></tr></table></figure>
<h4 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h4><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>它负责处理非字符串到字符串的强制类型转换。</p>
<p>基本类型值的字符串化规则为:null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。</p>
<p>对普通对象来说，除非自行定义，否则 toString()(Object.prototype.toString())返回 内部属性 [[Class]] 的值(参见第 3 章)，如 “[object Object]”。</p>
<p>数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接起 来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.toString(); <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure>
<h5 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h5><p>工具函数 JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(<span class="number">42</span>); <span class="comment">// "42"</span></span><br><span class="line">JSON.stringify(<span class="string">"42"</span>); <span class="comment">// ""42""(含有双引号的字符串) JSON.stringify( null ); // "null"</span></span><br><span class="line">JSON.stringify(<span class="keyword">true</span>); <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure>
<p>所有安全的 JSON 值(JSON-safe)都可以使用 JSON.stringify(..) 字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。</p>
<p>undefined、function、symbol (ES6+)和包含循环引用(对象之间相互引用，形成一个无限循环)的对象都不符合 JSON<br>结构标准，支持 JSON 的语言无法处理它们。</p>
<p>JSON.stringify(..) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在<br>数组中则会返回 null(以保证单元位置不变)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(undefined);  <span class="comment">//undefined</span></span><br><span class="line">JSON.stringify(function () &#123;&#125;);  <span class="comment">//undefined</span></span><br><span class="line">JSON.stringify(</span><br><span class="line">  [<span class="number">1</span>, undefined, function () &#123;&#125;, <span class="number">4</span>] <span class="comment">//"[1,null,null,4]"</span></span><br><span class="line">);</span><br><span class="line">JSON.stringify(&#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: function () &#123;&#125;</span><br><span class="line">&#125;);   <span class="comment">//"&#123;"a":2&#125;"</span></span><br></pre></td></tr></table></figure>
<p>我们可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用 来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  b: <span class="number">42</span>,</span><br><span class="line">  c: <span class="string">"42"</span>,</span><br><span class="line">  d: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line">JSON.stringify(a, [<span class="string">"b"</span>, <span class="string">"c"</span>]); <span class="comment">// "&#123;"b":42,"c":"42"&#125;"</span></span><br><span class="line">JSON.stringify(a, function (k, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (k !== <span class="string">"c"</span>) <span class="keyword">return</span> v;</span><br><span class="line">&#125;);<span class="comment">// "&#123;"b":42,"d":[1,2,3]&#125;"</span></span><br></pre></td></tr></table></figure>
<p>JSON.stringify(..) 并不是强制类型转换。在这里介绍是因为它涉及 ToString 强制类型转换，具体表现在以下两点。</p>
<ul>
<li>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。</li>
<li>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</li>
</ul>
<h5 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h5><p>其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>
<p>ToNumber 对字符串的处理基本遵循数字常量的相关规则 / 语法。处理失败 时返回 NaN(处理数字常量失败时会产生语法错误)。不同之处是 ToNumber 对以 0 开头的 十六进制数并不按十六进制处理(而是按十进制)。</p>
<p>对象(包括数组)会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型 值，则再遵循以上规则将其强制转换为数字。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p>
<h5 id="toBoolean"><a href="#toBoolean" class="headerlink" title="toBoolean"></a>toBoolean</h5><p>JavaScript 中的值可以分为以下两类:</p>
<ul>
<li>(1) 可以被强制类型转换为 false 的值</li>
<li>(2) 其他(被强制类型转换为 true 的值)</li>
</ul>
<p>以下这些是假值:</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0 和 NaN</li>
<li>“”</li>
<li>var a = new Boolean( false );</li>
<li>var b = new Number( 0 );</li>
<li>var c = new String( “” );</li>
</ul>
<h4 id="显示强制类型转化"><a href="#显示强制类型转化" class="headerlink" title="显示强制类型转化"></a>显示强制类型转化</h4><p>对显式强制类型转换几乎不存在非议，它类似于静态语言中的类型转换，已被广泛接受， 不会有什么坑。</p>
<h5 id="字符串和数字之间的显式转换"><a href="#字符串和数字之间的显式转换" class="headerlink" title="字符串和数字之间的显式转换"></a>字符串和数字之间的显式转换</h5><p>字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数(原生构造函 数，参见第 3 章)来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。<br>在 JavaScript 开源社区中，一元运算 + 被普遍认为是显式强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = String(a);</span><br><span class="line">var c = <span class="string">"3.14"</span>;</span><br><span class="line">var d = Number(c);</span><br><span class="line"></span><br><span class="line">var c = <span class="string">"3.14"</span>;</span><br><span class="line">var d = <span class="number">5</span> + +c; <span class="comment">//8.14</span></span><br><span class="line">var d = <span class="keyword">new</span> Date(<span class="string">"Mon, 18 Aug 2014 08:53:06 CDT"</span>); +</span><br><span class="line">d; <span class="comment">// 1408369986000</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带 ()。</p>
<h5 id="奇特的-运算符"><a href="#奇特的-运算符" class="headerlink" title="奇特的 ~ 运算符"></a>奇特的 ~ 运算符</h5><p>它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”(对每一个字 位进行反转)。~x 大致等同于 -(x+1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">42</span>; <span class="comment">// -(42+1) ==&gt; -43</span></span><br></pre></td></tr></table></figure>
<h5 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h5><p>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停 止。而转换不允许出现非数字字符，否则会失败并返回 NaN。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"42"</span>;</span><br><span class="line">var b = <span class="string">"42px"</span>;</span><br><span class="line">Number(a); <span class="comment">// 42</span></span><br><span class="line">parseInt(a); <span class="comment">// 42</span></span><br><span class="line">Number(b); <span class="comment">// NaN</span></span><br><span class="line">parseInt(b); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h5 id="显式转换为布尔值"><a href="#显式转换为布尔值" class="headerlink" title="显式转换为布尔值"></a>显式转换为布尔值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"0"</span>;</span><br><span class="line">var b = [];</span><br><span class="line">var c = &#123;&#125;;</span><br><span class="line">var d = <span class="string">""</span>;</span><br><span class="line">var e = <span class="number">0</span>;</span><br><span class="line">var f = <span class="keyword">null</span>;</span><br><span class="line">var g;</span><br><span class="line">Boolean(a); <span class="comment">// true</span></span><br><span class="line">Boolean(b); <span class="comment">// true</span></span><br><span class="line">Boolean(c); <span class="comment">// true</span></span><br><span class="line">Boolean(d); <span class="comment">// false</span></span><br><span class="line">Boolean(e); <span class="comment">// false</span></span><br><span class="line">Boolean(f); <span class="comment">// false</span></span><br><span class="line">Boolean(g); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!a; <span class="comment">// true</span></span><br><span class="line">!!b; <span class="comment">// true</span></span><br><span class="line">!!c; <span class="comment">// true</span></span><br><span class="line">!!d; <span class="comment">// false</span></span><br><span class="line">!!e; <span class="comment">// false</span></span><br><span class="line">!!f; <span class="comment">// false</span></span><br><span class="line">!!g; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>虽然 Boolean(..) 是显式的，但并不常用。所以显式强制类型转换为布尔值最常用的方法是 !!，因为第二个 ! 会将结果反转回原值:</p>
<h4 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h4><h5 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h5><p>&amp;&amp; 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = <span class="string">"abc"</span>;</span><br><span class="line">var c = <span class="keyword">null</span>;</span><br><span class="line">a || b;<span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b;<span class="comment">// "abc"</span></span><br><span class="line">c || b;<span class="comment">// "abc"</span></span><br><span class="line">c &amp;&amp; b;<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">a || b;</span><br><span class="line"><span class="comment">// 大致相当于(roughly equivalent to): a ? a : b;</span></span><br><span class="line">a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 大致相当于(roughly equivalent to): a ? b : a;</span></span><br></pre></td></tr></table></figure>
<h4 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h4><p>宽松相等(loose equals)== 和严格相等(strict equals)=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。</p>
<p>正确的解释是:“== 允许在相等比较中进行强制类型转换，而 === 不允许。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = <span class="string">"42"</span>;</span><br><span class="line">a === b; <span class="comment">// false</span></span><br><span class="line">a == b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="其他类型和布尔类型之间的相等比较"><a href="#其他类型和布尔类型之间的相等比较" class="headerlink" title="其他类型和布尔类型之间的相等比较"></a>其他类型和布尔类型之间的相等比较</h5><p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果;</p>
<p>(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"42"</span>;</span><br><span class="line">var b = <span class="keyword">true</span>;</span><br><span class="line">a == b; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="null-和-undefined-之间的相等比较"><a href="#null-和-undefined-之间的相等比较" class="headerlink" title="null 和 undefined 之间的相等比较"></a>null 和 undefined 之间的相等比较</h5><p>在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换:</p>
<h5 id="对象和非对象之间的相等比较"><a href="#对象和非对象之间的相等比较" class="headerlink" title="对象和非对象之间的相等比较"></a>对象和非对象之间的相等比较</h5><p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果; </p>
<p>(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = [<span class="number">42</span>];</span><br><span class="line">a == b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h4><p>句子”(sentence)是完整表达某个意思的一组词，由一个或多个“短语”(phrase)组成， 它们之间由标点符号或连接词(and 和 or 等)连接起来。短语可以由更小的短语组成。有 些短语是不完整的，不能独立表达意思;有些短语则相对完整，并且能够独立表达某个意 思。这些规则就是英语的语法。JavaScript 的语法也是如此。语句相当于句子，表达式相当于短语，运算符则相当于标点 符号和连接词。</p>
<h5 id="语句的结果值"><a href="#语句的结果值" class="headerlink" title="语句的结果值"></a>语句的结果值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面方法获取不到值</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a =</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    b = <span class="number">4</span> + <span class="number">38</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a = <span class="built_in">eval</span>(<span class="string">"if (true) &#123; b = 4 + 38; &#125;"</span>);</span><br><span class="line">a; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h5 id="表达式的副作用"><a href="#表达式的副作用" class="headerlink" title="表达式的副作用"></a>表达式的副作用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// 结果值:undefined。副作用:a的值被改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a++;</span><br><span class="line"><span class="comment">//a 43,b 42</span></span><br></pre></td></tr></table></figure>
<h5 id="上下文规则"><a href="#上下文规则" class="headerlink" title="上下文规则"></a>上下文规则</h5><h5 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h5><p>下面两种情况会用到大括号 { .. }</p>
<p>对象常量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  foo: bar()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>标签</p>
<h5 id="else-if-和可选代码块"><a href="#else-if-和可选代码块" class="headerlink" title="else if 和可选代码块"></a>else if 和可选代码块</h5><p>javascript没有elseif，但 if 和 else 只包含单条语句的时候可以省略代码块的 { }。</p>
<p>else if实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123; <span class="comment">// ..</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (b) &#123; <span class="comment">// ..</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// .. &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><h5 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h5><p>对 &amp;&amp; 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数。我们将 这种现象称为“短路”(即执行最短路径)。</p>
<p>以a &amp;&amp; b为例，如果a是一个假值，足以决定&amp;&amp;的结果，就没有必要再判断b的值。同 样对于 a || b，如果 a 是一个真值，也足以决定 || 的结果，也就没有必要再判断 b 的值。</p>
<ul>
<li>&amp;&amp; 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。</li>
</ul>
<h4 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h4><p>因为如果缺失了必要的 ;，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的 ;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>,b</span><br><span class="line">c;<span class="comment">//c会被作为var语句的一部分来处理</span></span><br></pre></td></tr></table></figure>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>JavaScript 不仅有各种类型的运行时错误(TypeError、ReferenceError、SyntaxError 等)，它的语法中也定义了一些编译时错误。</p>
<h4 id="提前使用变量"><a href="#提前使用变量" class="headerlink" title="提前使用变量"></a>提前使用变量</h4><p>ES6 规范定义了一个新概念，叫作 TDZ(Temporal Dead Zone，暂时性死区)。 TDZ 指的是由于代码中的变量还没有初始化而不能被引用的情况。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>在 ES6 中，如果参数被省略或者值为 undefined，则取该参数的默认值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a = <span class="number">42</span>, b = a + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">// 42 43</span></span><br><span class="line">foo(<span class="literal">undefined</span>);<span class="comment">// 42 43</span></span><br><span class="line">foo(<span class="number">5</span>);<span class="comment">// 5 6</span></span><br><span class="line">foo(<span class="keyword">void</span> <span class="number">0</span>, <span class="number">7</span>);<span class="comment">// 42 7</span></span><br><span class="line">foo(<span class="literal">null</span>);<span class="comment">// null 1</span></span><br></pre></td></tr></table></figure>
<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try..finally"></a>try..finally</h4><p>finally 中的代码总是会在 try 之后执行，如果有 catch 的话则在 catch 之后执行。也可以将 finally 中的代码看作一个回调函数，即无论出现什么情况最后一定会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"never runs"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> (a || b == <span class="number">10</span>):</span><br><span class="line">    <span class="comment">// 永远执行不到这里</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 的决议:一种在异步任务中作为两个或更多步骤的流程控制机制，时序上的 this- then-that。</p>
<p>Promise 至多只能有一个决议值(完成或拒绝)。</p>
<p>两个 Promise 固有行为特性:</p>
<ul>
<li>每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来;</li>
<li>不管从then(..) 调用的完成回调(第一个参数)返回的值是什么，它都会被自动设置 为被链接 Promise(第一点中的)的完成。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"B"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = p.then(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="comment">// 用值42填充p2</span></span><br><span class="line">  <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 连接p2</span></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="术语-决议、完成以及拒绝"><a href="#术语-决议、完成以及拒绝" class="headerlink" title="术语:决议、完成以及拒绝"></a>术语:决议、完成以及拒绝</h5><p>对于术语决议(resolve)、完成(fulfill)和拒绝(reject)，在更深入学习 Promise 之前，我们还有一些模糊之处需要澄清。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">X, Y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// X()用于完成</span></span><br><span class="line">  <span class="comment">// Y()用于拒绝 </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数字没有string函数，所以会抛出错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line">).catch(handleErrors);</span><br></pre></td></tr></table></figure>
<p>因为我们没有为 then(..) 传入拒绝处理函数，所以默认的处理函数被替换掉了，而这仅仅是把错误传递给了链中的下一个 promise。因此，进入 p 的错误以及 p 之后进入其决议 (就像 msg.toLowerCase())的错误都会传递到最后的handleErrors(..)。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([ .. ])"></a>Promise.all([ .. ])</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = request(<span class="string">"http://some.url.1/"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = request(<span class="string">"http://some.url.2/"</span>);</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">msgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里，p1和p2完成并把它们的消息传入 return request(</span></span><br><span class="line">    <span class="string">"http://some.url.3/?v="</span> + msgs.join(<span class="string">","</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>从Promise.all([ .. ])返回的主promise在且仅在所有的成员promise都完成后才会完 成。如果这些promise中有任何一个被拒绝的话，主Promise.all([ .. ])promise就会立 即被拒绝，并丢弃来自其他所有 promise 的全部结果。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([ .. ])"></a>Promise.race([ .. ])</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = request(<span class="string">"http://some.url.1/"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = request(<span class="string">"http://some.url.2/"</span>);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p1或者p2将赢得这场竞赛 return request(</span></span><br><span class="line">    <span class="string">"http://some.url.3/?v="</span> + msg</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>因为只有一个 promise 能够取胜，所以完成值是单个消息，而不是像对 Promise.all([ 那样的是一个数组。<br>.. ])</p>
<p>与Promise.all([ .. ])类似，一旦有任何一个Promise决议为完成，Promise.race([ .. ]) 就会完成;一旦有任何一个 Promise 决议为拒绝，它就会拒绝。</p>
<h4 id="Promise-API-概述"><a href="#Promise-API-概述" class="headerlink" title="Promise API 概述"></a>Promise API 概述</h4><h5 id="new-Promise-构造器"><a href="#new-Promise-构造器" class="headerlink" title="new Promise(..) 构造器"></a>new Promise(..) 构造器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve(..)用于决议/完成这个promise</span></span><br><span class="line">  <span class="comment">// reject(..)用于拒绝这个promise</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>reject(..) 就是拒绝这个 promise;但 resolve(..) 既可能完成 promise，也可能拒绝，要 根据传入参数而定。如果传给 resolve(..) 的是一个非 Promise、非 thenable 的立即值，这 个 promise 就会用这个值完成。</p>
<p>但是，如果传给 resolve(..) 的是一个真正的 Promise 或 thenable 值，这个值就会被递归展 开，并且(要构造的)promise 将取用其最终决议值或状态。</p>
<h5 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve(..) 和 Promise.reject(..)"></a>Promise.resolve(..) 和 Promise.reject(..)</h5><p>创建一个已被拒绝的 Promise 的快捷方式是使用 Promise.reject(..)，所以以下两个promise 是等价的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="string">"Oops"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">"Oops"</span>);</span><br></pre></td></tr></table></figure>
<p>Promise.resolve(..) 常用于创建一个已完成的 Promise,但是，Promise.resolve(..) 也会展开 thenable 值在这种情况 下，返回的 Promise 采用传入的这个 thenable 的最终决议值，可能是完成，也可能是拒绝:</p>
<h5 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then(..) 和 catch(..)"></a>then(..) 和 catch(..)</h5><p>每个 Promise 实例(不是 Promise API 命名空间)都有 then(..) 和 catch(..) 方法，通过 这两个方法可以为这个 Promise 注册完成和拒绝处理函数。Promise 决议之后，立即会调用 这两个处理函数之一，但不会两个都调用，而且总是异步调用.</p>
<h5 id="then-接受一个或两个参数"><a href="#then-接受一个或两个参数" class="headerlink" title="then(..) 接受一个或两个参数"></a>then(..) 接受一个或两个参数</h5><p>then(..) 接受一个或两个参数:第一个用于完成回调，第二个用于拒绝回调。如果两者中 的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回 调只是把消息传递下去，而默认拒绝回调则只是重新抛出(传播)其接收到的出错原因。</p>
<p>就像刚刚讨论过的一样，catch(..) 只接受一个拒绝回调作为参数，并自动替换默认完成 回调。换句话说，它等价于 then(null,..):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.then(fulfilled);</span><br><span class="line">p.then(fulfilled, rejected);</span><br><span class="line">p.catch(rejected); <span class="comment">// 或者p.then( null, rejected )</span></span><br></pre></td></tr></table></figure>
<p>then(..) 和 catch(..) 也会创建并返回一个新的 promise，这个 promise 可以用于实现 Promise 链式流程控制。如果完成或拒绝回调中抛出异常，返回的 promise 是被拒绝的。如 果任意一个回调返回非 Promise、非 thenable 的立即值，这个值会被用作返回 promise 的完 成值。如果完成处理函数返回一个 promise 或 thenable，那么这个值会被展开，并作为返回 promise 的决议值。</p>
<h4 id="Promise-局限性"><a href="#Promise-局限性" class="headerlink" title="Promise 局限性"></a>Promise 局限性</h4><h5 id="顺序错误处理"><a href="#顺序错误处理" class="headerlink" title="顺序错误处理"></a>顺序错误处理</h5><p>Promise 的设计局限性(具体来说，就 是它们链接的方式)造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被 无意中默默忽略掉。</p>
<h5 id="单一值"><a href="#单一值" class="headerlink" title="单一值"></a>单一值</h5><p>Promise 只能有一个完成值或一个拒绝理由。</p>
<h5 id="单决议"><a href="#单决议" class="headerlink" title="单决议"></a>单决议</h5><p>Promise 最本质的一个特征是:Promise 只能被决议一次(完成或拒绝)。</p>
<h5 id="无法取消的Promise"><a href="#无法取消的Promise" class="headerlink" title="无法取消的Promise"></a>无法取消的Promise</h5><p>一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。</p>
<h5 id="Promise-性能"><a href="#Promise-性能" class="headerlink" title="Promise 性能"></a>Promise 性能</h5><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="打破完整运行"><a href="#打破完整运行" class="headerlink" title="打破完整运行"></a>打破完整运行</h4><p>下面是实现这样的合作式并发的 ES6 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// 暂停!</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x:"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个迭代器it来控制这个生成器</span></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"><span class="comment">// 这里启动foo()! </span></span><br><span class="line">it.next();</span><br><span class="line">x; <span class="comment">// 2 </span></span><br><span class="line">bar();</span><br><span class="line">x; <span class="comment">// 3 </span></span><br><span class="line">it.next(); <span class="comment">// x: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>it = foo()运算并没有执行生成器*foo()，而只是构造了一个迭代器(iterator)，这个 迭代器会控制它的执行。后面会介绍迭代器。</li>
<li>第一个 it.next() 启动了生成器 <em>foo()，并运行了 </em>foo() 第一行的 x++。</li>
<li><em>foo() 在 yield 语句处暂停，在这一点上第一个 it.next() 调用结束。此时 </em>foo() 仍在运行并且是活跃的，但处于暂停状态。</li>
<li>我们查看 x 的值，此时为 2。</li>
<li>我们调用 bar()，它通过 x++ 再次递增 x。</li>
<li>我们再次查看 x 的值，此时为 3。</li>
<li>最后的 it.next() 调用从暂停处恢复了生成器 *foo() 的执行，并运行 console.log(..)语句，这条语句使用当前 x 的值 3。</li>
</ul>
<h5 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h5><p>生成器函数是一个特殊的函数，具有前面我们展示的新的执行模式。但是，它仍然是一个 函数，这意味着它仍然有一些基本的特性没有改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line">res.value; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>yield .. 和 next(..) 这一对组合起来，在生成器的执行过程中构成了一个双向消息传递系统。</p>
<h5 id="多个迭代器"><a href="#多个迭代器" class="headerlink" title="多个迭代器"></a>多个迭代器</h5><p>同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  z++;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span>(x * z);</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> it1 = foo();</span><br><span class="line"><span class="keyword">var</span> it2 = foo();</span><br><span class="line"><span class="keyword">var</span> val1 = it1.next().value; <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line"><span class="keyword">var</span> val2 = it2.next().value; <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line">val1 = it1.next(val2 * <span class="number">10</span>).value; <span class="comment">// 40   &lt;-- x:20,  z:2</span></span><br><span class="line">val2 = it2.next(val1 * <span class="number">5</span>).value; <span class="comment">// 600  &lt;-- x:200, z:3</span></span><br><span class="line">it1.next(val2 / <span class="number">2</span>); <span class="comment">// y:300</span></span><br><span class="line">it2.next(val1 / <span class="number">4</span>); <span class="comment">// y:10</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/17/设计模式/" class="article-date">
  	<time datetime="2017-04-16T16:00:00.000Z" itemprop="datePublished">2017-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/17/设计模式/">
        设计模式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>设计模式起源于建筑领域，是由美国著名建筑学家Christopher Alexander（克里斯托弗.亚历山大，被称为模式之父）。模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。</p>
<p>最早将模式的思想引入软件工程方法学的是1991-1992年以“四人组(Gang of Four，简称GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”自称的四位著名软件工程学者，他们在1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。</p>
<p>软件模式基本结构：</p>
<p><img src="http://img.my.csdn.net/uploads/201204/02/1333301568_8769.gif" alt=""></p>
<p>在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案，它融合了众多专家的设计经验，已经在成千上万的软件中得以应用。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据用途，设计模式可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。</p>
<p>常用设计模式一览表：</p>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/Snip20170417_2.png" alt="一览表"></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>使用这些方案将可以让我们避免做一些重复性的工作，提高效率。</li>
<li>使得设计方案更加通俗易懂，方便沟通。</li>
<li>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。</li>
<li>有助于别人更快地理解系统。</li>
<li>有助于阅读源码，以及实现更好的编码风格。</li>
</ul>
<h3 id="六个创建模式"><a href="#六个创建模式" class="headerlink" title="六个创建模式"></a>六个创建模式</h3><h4 id="简单-静态工厂模式"><a href="#简单-静态工厂模式" class="headerlink" title="简单/静态工厂模式"></a>简单/静态工厂模式</h4><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>
<ul>
<li>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。<ul>
<li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
<li>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//公共方法的实现  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//声明抽象业务方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//实现业务方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//业务方法的实现  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//静态工厂方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">getProduct</span><span class="params">(String arg)</span> </span>&#123;  </span><br><span class="line">        Product product = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">"A"</span>)) &#123;  </span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductA();  </span><br><span class="line">            <span class="comment">//初始化设置product  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">"B"</span>)) &#123;  </span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductB();  </span><br><span class="line">            <span class="comment">//初始化设置product  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> product;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li>
</ul>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p>
<ul>
<li>Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li>
<li>ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li>
<li>Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li>
<li>ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志记录器接口：抽象产品  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//数据库日志记录器：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseLogger</span> <span class="keyword">implements</span> <span class="title">Logger</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"数据库日志记录。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//文件日志记录器：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">implements</span> <span class="title">Logger</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"文件日志记录。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//日志记录器工厂接口：抽象工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoggerFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//数据库日志记录器工厂类：具体工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title">LoggerFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="comment">//连接数据库，代码省略  </span></span><br><span class="line">            <span class="comment">//创建数据库日志记录器对象  </span></span><br><span class="line">            Logger logger = <span class="keyword">new</span> DatabaseLogger();   </span><br><span class="line">            <span class="comment">//初始化数据库日志记录器，代码省略  </span></span><br><span class="line">            <span class="keyword">return</span> logger;  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//文件日志记录器工厂类：具体工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLoggerFactory</span> <span class="keyword">implements</span> <span class="title">LoggerFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="comment">//创建文件日志记录器对象  </span></span><br><span class="line">            Logger logger = <span class="keyword">new</span> FileLogger();   </span><br><span class="line">            <span class="comment">//创建文件，代码省略  </span></span><br><span class="line">            <span class="keyword">return</span> logger;  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        LoggerFactory factory;  </span><br><span class="line">        Logger logger;  </span><br><span class="line">        factory = <span class="keyword">new</span> FileLoggerFactory(); <span class="comment">//可引入配置文件实现  </span></span><br><span class="line">        logger = factory.createLogger();  </span><br><span class="line">        logger.writeLog();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li>
<li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
</ul>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p>
<p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p>
<ul>
<li>AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li>ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
<li>AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li>ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按钮接口：抽象产品  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Button</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Spring按钮类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringButton</span> <span class="keyword">implements</span> <span class="title">Button</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示浅绿色按钮。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Summer按钮类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerButton</span> <span class="keyword">implements</span> <span class="title">Button</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示浅蓝色按钮。"</span>);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//文本框接口：抽象产品  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TextField</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Spring文本框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringTextField</span> <span class="keyword">implements</span> <span class="title">TextField</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示绿色边框文本框。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Summer文本框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerTextField</span> <span class="keyword">implements</span> <span class="title">TextField</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示蓝色边框文本框。"</span>);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//组合框接口：抽象产品  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ComboBox</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Spring组合框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringComboBox</span> <span class="keyword">implements</span> <span class="title">ComboBox</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示绿色边框组合框。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Summer组合框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerComboBox</span> <span class="keyword">implements</span> <span class="title">ComboBox</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示蓝色边框组合框。"</span>);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//界面皮肤工厂接口：抽象工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SkinFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">createButton</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextField <span class="title">createTextField</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComboBox <span class="title">createComboBox</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Spring皮肤工厂：具体工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringSkinFactory</span> <span class="keyword">implements</span> <span class="title">SkinFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">createButton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringButton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextField <span class="title">createTextField</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringTextField();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComboBox <span class="title">createComboBox</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringComboBox();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//Summer皮肤工厂：具体工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerSkinFactory</span> <span class="keyword">implements</span> <span class="title">SkinFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">createButton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SummerButton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextField <span class="title">createTextField</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SummerTextField();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComboBox <span class="title">createComboBox</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SummerComboBox();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p>
<p>单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<h5 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h5><p>如果使用饿汉式单例来实现类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span>&#123; &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;   </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="懒汉式单例类与线程锁定"><a href="#懒汉式单例类与线程锁定" class="headerlink" title="懒汉式单例类与线程锁定"></a>懒汉式单例类与线程锁定</h5><p>懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123; &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();   </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="饿汉式单例类与懒汉式单例类比较"><a href="#饿汉式单例类与懒汉式单例类比较" class="headerlink" title="饿汉式单例类与懒汉式单例类比较"></a>饿汉式单例类与懒汉式单例类比较</h5><p>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</p>
<p>懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</p>
<h5 id="Initialization-Demand-Holder"><a href="#Initialization-Demand-Holder" class="headerlink" title="Initialization Demand Holder"></a>Initialization Demand Holder</h5><p>通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderClass</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> HolderClass.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        Singleton s1, s2;   </span><br><span class="line">            s1 = Singleton.getInstance();  </span><br><span class="line">        s2 = Singleton.getInstance();  </span><br><span class="line">        System.out.println(s1==s2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</p>
<ul>
<li>Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</li>
<li>ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</li>
<li>Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String  attr; <span class="comment">//成员属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setAttr</span><span class="params">(String attr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attr = attr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String  <span class="title">getAttr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.attr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//克隆方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Prototype  <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Prototype  prototype = <span class="keyword">new</span> ConcretePrototype(); <span class="comment">//创建新对象</span></span><br><span class="line">            prototype.setAttr(<span class="keyword">this</span>.attr);</span><br><span class="line">            <span class="keyword">return</span> prototype;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li>
</ul>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p>
<ul>
<li>Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</li>
<li>ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</li>
<li>Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</li>
<li>Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String type;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProduct</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"名称："</span>+name);  </span><br><span class="line">        System.out.println(<span class="string">"型号："</span>+type);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.type = type;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">(String arg1, String arg2)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//构建器中new一个产品对象，也可以通过构造方法传入</span></span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();  </span><br><span class="line">    <span class="comment">//提供返回产品的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.product;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//buildName 返回this.product 链式结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.product.setName(name); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.product; </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//buildType 返回this.product 链式结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildType</span><span class="params">(String type)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.product.setType(type); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.product; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Director通过Builder创建对象</span></span><br><span class="line"><span class="comment"> * Director 也可以理解为一个工厂模式的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ConcreteBuilder();  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getAProduct</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        builder.buildName(<span class="string">"宝马汽车"</span>).build(<span class="string">"X7"</span>);  </span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getBProduct</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        builder.buildName(<span class="string">"奥迪汽车"</span>).build(<span class="string">"Q5"</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用Director</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Director director = <span class="keyword">new</span> Director();  </span><br><span class="line">        Product product1 = director.getAProduct();  </span><br><span class="line">        product1.showProduct();  </span><br><span class="line"></span><br><span class="line">        Product product2 = director.getBProduct();  </span><br><span class="line">        product2.showProduct();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<p>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p>
<p>对象适配器模式结构图中包含如下几个角色：</p>
<ul>
<li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li>
<li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li>
<li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li>
</ul>
<p>典型的对象适配器代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee; <span class="comment">//维持一个对适配者对象的引用  </span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        adaptee.specificRequest(); <span class="comment">//转发调用  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系.</p>
<p>典型的类适配器代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        specificRequest();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h5><p> 在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器.</p>
<p>双向适配器的实现较为复杂，其典型代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span>,<span class="title">Adaptee</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//同时维持对抽象目标类和适配者的引用  </span></span><br><span class="line">    <span class="keyword">private</span> Target target;  </span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Target target)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        adaptee.specificRequest();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        target.request();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用例:ScoreOperation接口充当抽象目标，QuickSort和BinarySearch类充当适配者，OperationAdapter充当适配器。</p>
<p><img src="http://img.my.csdn.net/uploads/201303/01/1362069067_3033.jpg" alt=""></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象成绩操作类：目标接口  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ScoreOperation</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> array[]); <span class="comment">//成绩排序  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> key)</span></span>; <span class="comment">//成绩查找  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//快速排序类：适配者  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span> array[]) &#123;  </span><br><span class="line">        sort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">return</span> array;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span>(p&lt;r) &#123;  </span><br><span class="line">            q=partition(array,p,r);  </span><br><span class="line">            sort(array,p,q-<span class="number">1</span>);  </span><br><span class="line">            sort(array,q+<span class="number">1</span>,r);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> x=a[r];  </span><br><span class="line">        <span class="keyword">int</span> j=p-<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=p;i&lt;=r-<span class="number">1</span>;i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (a[i]&lt;=x) &#123;  </span><br><span class="line">                j++;  </span><br><span class="line">                swap(a,j,i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        swap(a,j+<span class="number">1</span>,r);  </span><br><span class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">int</span> t = a[i];     </span><br><span class="line">        a[i] = a[j];     </span><br><span class="line">        a[j] = t;     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二分查找类：适配者  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> high = array.length -<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;  </span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;  </span><br><span class="line">            <span class="keyword">int</span> midVal = array[mid];  </span><br><span class="line">            <span class="keyword">if</span>(midVal &lt; key) &#123;    </span><br><span class="line">low = mid +<span class="number">1</span>;    </span><br><span class="line">&#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key) &#123;    </span><br><span class="line">high = mid -<span class="number">1</span>;    </span><br><span class="line">&#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//找到元素返回1    </span></span><br><span class="line">&#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//未找到元素返回-1  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//操作适配器：适配器  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAdapter</span> <span class="keyword">implements</span> <span class="title">ScoreOperation</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> QuickSort sortObj; <span class="comment">//定义适配者QuickSort对象  </span></span><br><span class="line">    <span class="keyword">private</span> BinarySearch searchObj; <span class="comment">//定义适配者BinarySearch对象  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperationAdapter</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        sortObj = <span class="keyword">new</span> QuickSort();  </span><br><span class="line">        searchObj = <span class="keyword">new</span> BinarySearch();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> array[]) &#123;    </span><br><span class="line"><span class="keyword">return</span> sortObj.quickSort(array); <span class="comment">//调用适配者类QuickSort的排序方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> key)</span> </span>&#123;    </span><br><span class="line"><span class="keyword">return</span> searchObj.binarySearch(array,key); <span class="comment">//调用适配者类BinarySearch的查找方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>1 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li>2 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li>
<li>3 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ul>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><ul>
<li>1 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li>
<li>2 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>
<p>转载自<a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">史上最全设计模式导学目录（完整版）</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-OKR" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/13/OKR/" class="article-date">
  	<time datetime="2017-04-12T16:00:00.000Z" itemprop="datePublished">2017-04-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/13/OKR/">
        OKR
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="OKR-定义"><a href="#OKR-定义" class="headerlink" title="OKR 定义"></a>OKR 定义</h2><p>OKR的全称是Objectives and Key Results，即目标与关键成果法。它是一套定义和跟踪目标及其完成情况的管理方法。</p>
<p>OKR分两个部分，一个就是O代表的目标，第二个是KR代表的关键结果。一个O对应多个KR，KR是为了更好的支持O的完成，是要明显可量化的，便于度量的。</p>
<p>例子：</p>
<p>Objective 目标：招募更多的司机</p>
<p>KRs：所有地区的司机基数提升 20%</p>
<p>KRs：所有活跃地区司机的平均工作时长提升至每周 90 小时  </p>
<h2 id="OKR有几个原则"><a href="#OKR有几个原则" class="headerlink" title="OKR有几个原则"></a>OKR有几个原则</h2><ul>
<li>在精不在多。因为它就是用来明确并聚焦工作重心的；</li>
<li>可量化，有挑战，透明化：公开、透明、可视化的管理</li>
</ul>
<h2 id="为什么用OKR"><a href="#为什么用OKR" class="headerlink" title="为什么用OKR"></a>为什么用OKR</h2><ul>
<li>1 OKR能让我们抓住主要矛盾，找出对企业发展真正重要的事。 </li>
<li>2 让我们能聚焦优势资源在最重要的事上，可以很大程度的减少资源浪费，这对创业企业尤为重要。 </li>
<li>3 能让团队成长的进化迭代周期更短。 </li>
<li>4 能让每个人都有清晰的目标感，都能盯在重要的事情上。</li>
<li>5 能让每个人对目标的理解都是一致的，从而同心协力，避免因为方向分散带来很多内耗。 </li>
<li>6 能让我们变的更加战略主动，避免被竞争者牵着鼻子走。</li>
</ul>
<h2 id="OKR的三个层次"><a href="#OKR的三个层次" class="headerlink" title="OKR的三个层次"></a>OKR的三个层次</h2><ul>
<li>公司OKR：明确公司的整体目标，聚焦重点。 </li>
<li>团队OKR：明确团队的工作优先级。它并不是公司OKR的简单拆分，也不是个人OKR的简单汇总，而是从团队层面重新思考并确定出来的。 </li>
<li><p>个人OKR：明确自己该做什么，是最具体的一层。 </p>
<p>其中，每一层都向上对齐。</p>
</li>
</ul>
<h2 id="制定OKR原则"><a href="#制定OKR原则" class="headerlink" title="制定OKR原则"></a>制定OKR原则</h2><ul>
<li>OKR要能支撑战略。 </li>
<li>最多有5个O，每个O最多4个KR。 </li>
<li>目标要有野心，有时候甚至要有些不舒服。从打分来看，最终得分在0.6~0.7是最佳的，当然前提是执行是没问题的。如果得分在0.4，很可能是目标定的太难了，这样容易让人受挫，如果得分是1分的话，很可能目标就定的太简单了，起不到目标的拉动作用。最佳的OKR应该是既有挑战性，还要切合实际。</li>
<li>一定要可以衡量。 </li>
<li>一定要有截止时间。</li>
<li>要有60%以上的目标是自下而上提出的。 </li>
<li>目标必须100%的都是协商并同意的，不能是命令。 </li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>准备 -&gt; 确定OKR -&gt; 公式OKR -&gt; 执行OKR -&gt; 复盘OKR </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/10/node学习/" class="article-date">
  	<time datetime="2017-04-09T16:00:00.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/node学习/">
        node学习
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="学习js"><a href="#学习js" class="headerlink" title="学习js"></a>学习js</h3><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6</a></p>
<p>建议学习2，8 ，21章。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>let:声明范围内可用。这表示外层代码块不受内层代码块的影响。</p>
<p>var:全局可用。</p>
<p>变量提升:即变量可以在声明之前使用，值为undefined。</p>
<p>let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<p>let不允许在相同作用域内，重复声明同一个变量。</p>
<p>如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<h4 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<p>参数变量是默认声明的，所以不能用let或const在函数内再次声明。</p>
<p>如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符:扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br></pre></td></tr></table></figure>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>export 命令</p>
<p>如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。export命令除了输出变量，还可以输出函数或类（class）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="熟悉node的写法"><a href="#熟悉node的写法" class="headerlink" title="熟悉node的写法"></a>熟悉node的写法</h3><p><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">Nodejs</a></p>
<h3 id="sails"><a href="#sails" class="headerlink" title="sails"></a>sails</h3><h4 id="安装sails"><a href="#安装sails" class="headerlink" title="安装sails"></a>安装sails</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install sails -g</span><br></pre></td></tr></table></figure>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sails new <span class="built_in">test</span>-project</span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>-project</span><br><span class="line">$ sails lift /node app.js</span><br></pre></td></tr></table></figure>
<h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><p>controller里面写业务接口，services里面写业务代码，models配置数据库表结构，之后配置routes路由。</p>
<p>connections配置底层数据库，</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-学会提问" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/08/学会提问/" class="article-date">
  	<time datetime="2017-04-07T16:00:00.000Z" itemprop="datePublished">2017-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/08/学会提问/">
        学会提问
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="学会提出好问题"><a href="#学会提出好问题" class="headerlink" title="学会提出好问题"></a>学会提出好问题</h3><p>批判性的提问是检索信息和搜寻答案的最好方法。</p>
<h4 id="批判思维"><a href="#批判思维" class="headerlink" title="批判思维"></a>批判思维</h4><ul>
<li>有一套相互关联，环环相扣的关键问题的意识。</li>
<li>恰如其分地提出和回答关键问题的能力。</li>
<li>积极主动地利用关键问题的强烈愿望。</li>
</ul>
<h4 id="两种思维方式-海绵思维和淘金思维"><a href="#两种思维方式-海绵思维和淘金思维" class="headerlink" title="两种思维方式:海绵思维和淘金思维"></a>两种思维方式:海绵思维和淘金思维</h4><h5 id="海绵思维"><a href="#海绵思维" class="headerlink" title="海绵思维"></a>海绵思维</h5><p>充分吸收</p>
<p>优点：吸取很多知识。被动吸收不需要冥思苦想。</p>
<p>缺点：信息观点的取舍，如果依赖海绵思维，就会对自己读到的信息深信不疑。</p>
<h5 id="淘金式思维"><a href="#淘金式思维" class="headerlink" title="淘金式思维"></a>淘金式思维</h5><p>对接触到的信息进行取舍，即带着问题去解除信息，这种交互式被称为淘金式思维。</p>
<p>海绵思维强调单纯的知识获取结果，而淘金思维则重视获取知识过程中与知识展开积极互动。</p>
<h4 id="脑海里存在一份淘金式思维清单"><a href="#脑海里存在一份淘金式思维清单" class="headerlink" title="脑海里存在一份淘金式思维清单"></a>脑海里存在一份淘金式思维清单</h4><ul>
<li>我有没有问”为什么”别人要我相信他的观点</li>
<li>在我想到别人的说法可能有问题时有没有把它记下来</li>
<li>我对别人说过的话有没有进行客观评价</li>
<li>针对某一特定主题我又没有在别人合理说法的基础上形成自己的结论</li>
</ul>
<h4 id="最好先问一问”关我什么事”"><a href="#最好先问一问”关我什么事”" class="headerlink" title="最好先问一问”关我什么事”"></a>最好先问一问”关我什么事”</h4><p>一寸光阴一寸金</p>
<h4 id="弱批判思维和强批判思维"><a href="#弱批判思维和强批判思维" class="headerlink" title="弱批判思维和强批判思维"></a>弱批判思维和强批判思维</h4><p>弱批判思维是利用批判思维来捍卫自己的现有立场和看法。弱批判性思维是为了抵制和驳倒那些与你意见不同的人。强批判性思维是利用批判性思维来评估所有的断言和看法，尤其是自己的看法。强势的批判思维要求我们用关键性问题一视同仁地质疑一切主张，包括自己的主张。</p>
<h4 id="也许我们根本就问错了问题"><a href="#也许我们根本就问错了问题" class="headerlink" title="也许我们根本就问错了问题"></a>也许我们根本就问错了问题</h4><ul>
<li>论题和结论是什么</li>
<li>理由是什么</li>
<li>哪些词语意思不明确</li>
<li>什么是价值观假设和描述性假设</li>
<li>推理过程中有没有谬误</li>
<li>证据的效力如何</li>
<li>有没有替代原因</li>
<li>数据有没有欺骗性</li>
<li>有什么重要信息被忽略了</li>
<li>能得出哪些合理的结论</li>
</ul>
<h4 id="价值观决定人与人的互动"><a href="#价值观决定人与人的互动" class="headerlink" title="价值观决定人与人的互动"></a>价值观决定人与人的互动</h4><p>批判性思维很大程度上依赖于虚心听取别人的意见来取长补短。</p>
<h5 id="批判性思考的人拥有的主要价值观"><a href="#批判性思考的人拥有的主要价值观" class="headerlink" title="批判性思考的人拥有的主要价值观"></a>批判性思考的人拥有的主要价值观</h5><ul>
<li>自助性</li>
<li>好奇心：要想充分的利用淘金思维来立身处世，要兼听博观。</li>
<li>谦虚有礼</li>
<li>以理服人</li>
</ul>
<h4 id="理智思考和情感用事"><a href="#理智思考和情感用事" class="headerlink" title="理智思考和情感用事"></a>理智思考和情感用事</h4><p>接受还是拒绝一个立场，感情上的依恋绝不应该成为最重要的基础。</p>
<h4 id="让对话一直进行下去"><a href="#让对话一直进行下去" class="headerlink" title="让对话一直进行下去"></a>让对话一直进行下去</h4><ul>
<li>尽量阐明你对别人结论的理解</li>
<li>问一下别人，有没有证据让他改变他的观点</li>
<li>暂停一段时间，去尽可能找到支撑自己结论的最佳观点</li>
<li>问一问别人，为什么他们认为你的证据不堪一击</li>
<li>尽量弥合分歧</li>
<li>寻找一些共同的价值观或其他一致同意的结论，以此为基础，找出对话中分歧产生的原因</li>
<li>好奇心再强也要表现的体贴关心和不温不火</li>
<li>确保你的情绪和肢体动作都表现的谦恭的样子</li>
</ul>
<h4 id="一厢情愿是批判性思维的最大劲敌"><a href="#一厢情愿是批判性思维的最大劲敌" class="headerlink" title="一厢情愿是批判性思维的最大劲敌"></a>一厢情愿是批判性思维的最大劲敌</h4><p>是不是因为我希望它是真的这事才是真的，还是有确凿无疑的证据证明它是真的？</p>
<h3 id="理由是什么"><a href="#理由是什么" class="headerlink" title="理由是什么"></a>理由是什么</h3><p>只有找到支撑结论的理由时你才能判定一个结论的价值。</p>
<p>理由 + 结论 = 论证</p>
<p>一个论证由一个结论和多个支撑这一结论的理由组成。</p>
<p>注意结论本身并不是证据，它是由证据或者其他看法支撑起来的看法。</p>
<h4 id="尽量让理由和结论一目了然"><a href="#尽量让理由和结论一目了然" class="headerlink" title="尽量让理由和结论一目了然"></a>尽量让理由和结论一目了然</h4><p>找到文章的重点的技巧</p>
<ul>
<li>圈出指示词</li>
<li>用不同颜色标出理由和结论。</li>
<li>在页边给理由和序号编上序号。</li>
<li>读完长篇大论后，在文章的结尾处按顺序列出所有理由。</li>
</ul>
<h4 id="薄弱的理由必然导致薄弱的结论"><a href="#薄弱的理由必然导致薄弱的结论" class="headerlink" title="薄弱的理由必然导致薄弱的结论"></a>薄弱的理由必然导致薄弱的结论</h4><h4 id="理想的做法是，理由是模具，结论据此得以成型和修改"><a href="#理想的做法是，理由是模具，结论据此得以成型和修改" class="headerlink" title="理想的做法是，理由是模具，结论据此得以成型和修改"></a>理想的做法是，理由是模具，结论据此得以成型和修改</h4><h3 id="哪些词语意思不明确"><a href="#哪些词语意思不明确" class="headerlink" title="哪些词语意思不明确***"></a>哪些词语意思不明确<strong><strong>***</strong></strong></h3><h3 id="论题和结论是什么"><a href="#论题和结论是什么" class="headerlink" title="论题和结论是什么"></a>论题和结论是什么</h3><p>只有理解了关键术语和词语的意思(无论直接还是含蓄)，你才能对一个论证进行评论。</p>
<h4 id="让人捉摸不透的多义词"><a href="#让人捉摸不透的多义词" class="headerlink" title="让人捉摸不透的多义词"></a>让人捉摸不透的多义词</h4><h4 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h4><ul>
<li>检查论题看有没有关键词</li>
<li>在理由和结论里面寻找</li>
<li>留意抽象的词语</li>
<li>通过反串来判断别人怎么给特定的词语不同的定义</li>
</ul>
<h4 id="检查有没有歧义"><a href="#检查有没有歧义" class="headerlink" title="检查有没有歧义"></a>检查有没有歧义</h4><ul>
<li>第一个障碍就是你自以为和别人表达的是同一个意思，应该多问”你这样说是什么意思”，而不是”我就知道你是这个意思”</li>
<li>第二个障碍就是人文术语只有一个明显的定义，”这些词语有没有不同的意思？”</li>
</ul>
<h4 id="判定歧义"><a href="#判定歧义" class="headerlink" title="判定歧义"></a>判定歧义</h4><p>只有出现在分析推理的过程中，意思不明确的词才是关键。</p>
<h4 id="小心那些饱含感情色彩的词语，它会让你思维短路"><a href="#小心那些饱含感情色彩的词语，它会让你思维短路" class="headerlink" title="小心那些饱含感情色彩的词语，它会让你思维短路"></a>小心那些饱含感情色彩的词语，它会让你思维短路</h4><p>那些激发强烈感情反应的术语被称为附加感情色彩的术语，它们感动我们的能力远远超越了它们本身的描述含义。</p>
<h3 id="什么是价值观假设和描述性假设"><a href="#什么是价值观假设和描述性假设" class="headerlink" title="什么是价值观假设和描述性假设"></a>什么是价值观假设和描述性假设</h3><p>一个论证表面可见的部分常常最有可能穿上华丽的外衣。</p>
<h4 id="价值观假设"><a href="#价值观假设" class="headerlink" title="价值观假设"></a>价值观假设</h4><p>价值观假设：是指一种想当然的看法，认为某些相互独立的价值观中一个比另一个更重要。</p>
<h4 id="对方的背景可以作为价值观假设的一个线索"><a href="#对方的背景可以作为价值观假设的一个线索" class="headerlink" title="对方的背景可以作为价值观假设的一个线索"></a>对方的背景可以作为价值观假设的一个线索</h4><p>注意并不是因为一个人身为某一个团体的一元，就一定会认同这个团体的特定价值取向。</p>
<h4 id="寻找价值观假设"><a href="#寻找价值观假设" class="headerlink" title="寻找价值观假设"></a>寻找价值观假设</h4><ul>
<li>调查作者背景</li>
<li>为什么作者的立场产生的结果对他而言显得那么重要？</li>
<li>寻找类似的辩论，寻找类似的价值观假设</li>
<li>反串，采取与作者相反的立场，看一看哪些价值观对这一相反立场显得非常重要</li>
<li>找一找常见的价值观冲突</li>
</ul>
<h4 id="描述性假设"><a href="#描述性假设" class="headerlink" title="描述性假设"></a>描述性假设</h4><p>就是对这个世界过去，现在和未来是什么样的想法。</p>
<h4 id="避免两费时间分析无意义的假设"><a href="#避免两费时间分析无意义的假设" class="headerlink" title="避免两费时间分析无意义的假设"></a>避免两费时间分析无意义的假设</h4><h3 id="推理过程中的谬误"><a href="#推理过程中的谬误" class="headerlink" title="推理过程中的谬误"></a>推理过程中的谬误</h3><p>谬误，就是推理中的欺骗手段，作者有可能利用这个欺骗手段来说服你采纳其结论。</p>
<p>批判性阅读和聆听的主要目标就在于判定结论的可接受程度或者价值的大小。</p>
<h4 id="三种常见谬误"><a href="#三种常见谬误" class="headerlink" title="三种常见谬误"></a>三种常见谬误</h4><ul>
<li>提供的推理需要明显错误的或者让人不能接受的假设才能成立，因此是推理和结论前的毫无关系。</li>
<li>把那些明明和结论无关的信息弄得好像和结论有关，以此来分散我们的注意力。</li>
<li>看似为结论找证据，而证据算数的前提取决于结论本身已经成立。</li>
</ul>
<p>推理结构：</p>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-08%20%E4%B8%8B%E5%8D%883.24.00.png" alt="图片"></p>
<h4 id="人身攻击谬论"><a href="#人身攻击谬论" class="headerlink" title="人身攻击谬论"></a>人身攻击谬论</h4><h4 id="滑坡谬误"><a href="#滑坡谬误" class="headerlink" title="滑坡谬误"></a>滑坡谬误</h4><p>滑坡谬误指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件。</p>
<h4 id="追求完美解决方案的谬误"><a href="#追求完美解决方案的谬误" class="headerlink" title="追求完美解决方案的谬误"></a>追求完美解决方案的谬误</h4><p>最求完美解决方案谬误是指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种方案根本就不应该采用。(坐等完美解决方案，固守原地，现阶段方案可能不完美，但它可能让我们向彻底解决问题迈进一步)</p>
<h4 id="偷梁换柱谬论"><a href="#偷梁换柱谬论" class="headerlink" title="偷梁换柱谬论"></a>偷梁换柱谬论</h4><p>偷梁换柱谬论是指在论证中关键词语有两种或者两种以上的含义，一旦不同含义之间的转换被认出来，这个结论就讲不通了。</p>
<h4 id="诉诸公众谬误"><a href="#诉诸公众谬误" class="headerlink" title="诉诸公众谬误"></a>诉诸公众谬误</h4><p>诉诸公众谬误指通过引述大部分人都持有这一观点的说法来竭力证明某个论断有道理，错误地假设大部分人喜欢的一切就是有道理的，可以接受的。</p>
<h4 id="诉诸可疑权威谬误"><a href="#诉诸可疑权威谬误" class="headerlink" title="诉诸可疑权威谬误"></a>诉诸可疑权威谬误</h4><p>诉诸可疑权威谬误指引用某一权威的话来证明结论，但该权威对这一结论并没有特别的专门知识。</p>
<h4 id="诉诸情感谬误"><a href="#诉诸情感谬误" class="headerlink" title="诉诸情感谬误"></a>诉诸情感谬误</h4><p>诉诸情感谬误指使用带有强烈感情色彩的语言来分散读者或听众的注意力，让他们忽略相关理由和证据。常被用来记忆力用的感情有害怕，希望，爱国主义，怜悯同情。(常用语广告，政治和法庭辩论)</p>
<h4 id="稻草人谬误"><a href="#稻草人谬误" class="headerlink" title="稻草人谬误"></a>稻草人谬误</h4><p>稻草人谬误指歪曲对方的观点，使它容易受到攻击，这样我们攻击的观点事实上根本就不存在。</p>
<h4 id="虚假的两难谬误"><a href="#虚假的两难谬误" class="headerlink" title="虚假的两难谬误"></a>虚假的两难谬误</h4><p>虚假的两难谬误指当现实中存在两种以上的选择时却假设只有两种解决方案。(不是…就是，唯一的选择就是…,两种选则分别是…,因为甲不起作用只能用乙)</p>
<h4 id="乱扣帽子谬误"><a href="#乱扣帽子谬误" class="headerlink" title="乱扣帽子谬误"></a>乱扣帽子谬误</h4><p>乱扣帽子谬误指错误地假设因为你为特定事件或行为提供了一个名称，你也就合情合理地解释了这一事件。</p>
<h4 id="光环效应谬误"><a href="#光环效应谬误" class="headerlink" title="光环效应谬误"></a>光环效应谬误</h4><p>光环效应谬误指使用模糊，引发人们强烈感情认同的美德词汇，使我们倾向于同意某件事件而不去细致检查其理由。</p>
<h4 id="转移话题谬误"><a href="#转移话题谬误" class="headerlink" title="转移话题谬误"></a>转移话题谬误</h4><p>转移话题谬误指一个不相干的话题被插进来，将注意力从原来的话题上移走，通过将注意力转移到另一话题上来帮助赢得辩论。谬误顺序：1 甲主题正在讨论。2 乙主题被介绍进来，看似和甲有关，其实没关系。3 甲主题被遗忘。</p>
<h4 id="循环论证谬误"><a href="#循环论证谬误" class="headerlink" title="循环论证谬误"></a>循环论证谬误</h4><p>循环论证谬误指在推理过程中已然假设自己的结构成立的论证。</p>
<h4 id="以偏概全谬误"><a href="#以偏概全谬误" class="headerlink" title="以偏概全谬误"></a>以偏概全谬误</h4><p>以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。</p>
<h4 id="强求确定性谬误"><a href="#强求确定性谬误" class="headerlink" title="强求确定性谬误"></a>强求确定性谬误</h4><p>强求确定性谬误指认为一个研究结果如果不是百分百确定的话就应该被抛弃。</p>
<h4 id="错误类比谬误"><a href="#错误类比谬误" class="headerlink" title="错误类比谬误"></a>错误类比谬误</h4><p>错误类比谬误指有人提出一个类比，其中存在重要而又相关的不同点。</p>
<h4 id="过度简化因果关系谬误"><a href="#过度简化因果关系谬误" class="headerlink" title="过度简化因果关系谬误"></a>过度简化因果关系谬误</h4><p>指依赖并不足以解释这个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素中的一个或多个因素的作用。</p>
<h4 id="因果混淆谬误"><a href="#因果混淆谬误" class="headerlink" title="因果混淆谬误"></a>因果混淆谬误</h4><p>因果混淆谬误指将事件的起因和结果相混淆或是认不出两件事件之间可能是相互影响的。</p>
<h4 id="忽略常见原因谬误"><a href="#忽略常见原因谬误" class="headerlink" title="忽略常见原因谬误"></a>忽略常见原因谬误</h4><p>忽略常见原因谬误指认不出两件事之间之所以有联系是因为常见的第三种因素在起作用。</p>
<h4 id="事后归因谬误"><a href="#事后归因谬误" class="headerlink" title="事后归因谬误"></a>事后归因谬误</h4><p>事后归因谬误指假设某件事乙是由另一事件甲所造成的，仅仅因为乙在时间上紧随甲之后。</p>
<p>一旦作者有下列行为之一，就应该驳回其推理</p>
<ul>
<li>对人不对事</li>
<li>实用滑坡推理方式</li>
<li>表现出寻找完美解决方案的趋势</li>
<li>用模棱两可的话隐瞒真相</li>
<li>不恰当地诉诸公众意见</li>
<li>诉诸可以权威</li>
<li>攻击稻草人</li>
<li>呈现虚假的两难情形</li>
<li>通过恶语中伤别人来解释</li>
<li>将注意力从论题上转移开</li>
<li>通过光环效应让读者分神</li>
<li>循环论证</li>
<li>介绍另一个话题来转移注意力</li>
</ul>
<h3 id="证据的效力如何：直觉-个人经历-典型案例-当事人证词和专家意见"><a href="#证据的效力如何：直觉-个人经历-典型案例-当事人证词和专家意见" class="headerlink" title="证据的效力如何：直觉 个人经历 典型案例 当事人证词和专家意见"></a>证据的效力如何：直觉 个人经历 典型案例 当事人证词和专家意见</h3><h4 id="怎么确定理由的可靠性，可以问一下问题？"><a href="#怎么确定理由的可靠性，可以问一下问题？" class="headerlink" title="怎么确定理由的可靠性，可以问一下问题？"></a>怎么确定理由的可靠性，可以问一下问题？</h4><ul>
<li>你的证明是什么？</li>
<li>你怎么知道它是真的？</li>
<li>证据在哪里？</li>
<li>你为什么相信它？</li>
<li>你确信它是真的吗？</li>
<li>你能证明吗？</li>
</ul>
<h4 id="事实断言"><a href="#事实断言" class="headerlink" title="事实断言"></a>事实断言</h4><ul>
<li>1 当这个断言表现为无可置疑的常识，比如说”举重可以锻炼肌肉”</li>
<li>2 断言是从无懈可击的论证中得出的结论。</li>
<li>3 断言被很多过硬的证据合理的证实。</li>
</ul>
<h4 id="要铭记，没有一样证据可以向灌篮一样一锤定音，一劳永逸。你总是在找更好的证据，如果一根筋地去找完美证据，那你肯定要泄气。"><a href="#要铭记，没有一样证据可以向灌篮一样一锤定音，一劳永逸。你总是在找更好的证据，如果一根筋地去找完美证据，那你肯定要泄气。" class="headerlink" title="要铭记，没有一样证据可以向灌篮一样一锤定音，一劳永逸。你总是在找更好的证据，如果一根筋地去找完美证据，那你肯定要泄气。"></a>要铭记，没有一样证据可以向灌篮一样一锤定音，一劳永逸。你总是在找更好的证据，如果一根筋地去找完美证据，那你肯定要泄气。</h4><h4 id="主要的证据类型"><a href="#主要的证据类型" class="headerlink" title="主要的证据类型"></a>主要的证据类型</h4><ul>
<li>直觉</li>
<li>个人经历(以偏概全谬误)</li>
<li>典型案例(要问一下是否有代表性)</li>
<li>当事人证词(名人广告)：选择性，个人兴趣，省略作为判断的信息，人为因素</li>
<li>权威或专家意见：专家也会常常犯错，同意他们内部也常常意见不统一。专家和观点是否有利益瓜葛。</li>
<li>个人观察</li>
<li>研究报告</li>
</ul>
<h3 id="证据的效力如何：个人观察，研究报告和类比"><a href="#证据的效力如何：个人观察，研究报告和类比" class="headerlink" title="证据的效力如何：个人观察，研究报告和类比"></a>证据的效力如何：个人观察，研究报告和类比</h3><h4 id="个人观察"><a href="#个人观察" class="headerlink" title="个人观察"></a>个人观察</h4><p>我们所”见”所说的都是经过一系列价值观，偏见，态度和期望过滤后剩下的东西。还有一些阻碍，比如注意力无法集中，环境压力，观察事件快速进行。</p>
<h4 id="研究报告"><a href="#研究报告" class="headerlink" title="研究报告"></a>研究报告</h4><p>研究的质量有高有低，差别很大。</p>
<p>研究成果常常互相矛盾。</p>
<p>研究结果并不能证明结论。</p>
<p>研究人员也也有他们的期望值，态度，价值观和需求。不论一个科学报告显得多么客观，还是难免会夹杂了重要的主观因素。</p>
<p>研究的事实会随着时间的流逝而发生改变。</p>
<p>赞成的：</p>
<ul>
<li>科学研究能接受公共验证</li>
<li>研究可使用控制来让外部影响因素最小化</li>
<li>科学研究使用语言方面能做到精确和前后一致</li>
</ul>
<p>反对的：</p>
<ul>
<li>研究的质量和人为因素变化较大</li>
<li>研究结果互相矛盾，事实会随着时间的流逝发生变化</li>
<li>研究结果只能支撑结论</li>
</ul>
<h4 id="样本能代替总体吗？"><a href="#样本能代替总体吗？" class="headerlink" title="样本能代替总体吗？"></a>样本能代替总体吗？</h4><ul>
<li>样本的覆盖率必须要大到足以产生概括或者得出结论的程度。</li>
<li>样本必须覆盖足够的范围或者说包含足够的多样性。</li>
<li>样本的随机性越大越好。</li>
</ul>
<p>只有和我们研究过的人群或事件类似的或相同的情况我们才能加以概括。</p>
<h4 id="调查和问卷的回答真实吗？"><a href="#调查和问卷的回答真实吗？" class="headerlink" title="调查和问卷的回答真实吗？"></a>调查和问卷的回答真实吗？</h4><ul>
<li>由于种种原因人们常常掩盖真相。</li>
<li>调查的问题的措辞含糊不清，问题可能被误读。小心查看问题的言辞用字。</li>
<li>语境的影响也是很大</li>
<li>哪怕是片面的调查也可能承载大量的信息，但你需要知道偏见所在，以防止自己过分被调查结果所说服。</li>
</ul>
<h4 id="类比作为证据可靠吗？"><a href="#类比作为证据可靠吗？" class="headerlink" title="类比作为证据可靠吗？"></a>类比作为证据可靠吗？</h4><p>类比往往涉及比较，他们依赖相似度作为主要类型的证据。</p>
<p>影响类比质量的因素:</p>
<ul>
<li>两个作比较的事物相同和相异的方式。</li>
<li>相似点和不同点的关联。</li>
</ul>
<p>原则：</p>
<p>相关的共同点和不同点就是直接和类比所展示的那些潜在的原则相关。</p>
<h3 id="有没有替代原因"><a href="#有没有替代原因" class="headerlink" title="有没有替代原因"></a>有没有替代原因</h3><p>代替原因：指一个言之有理的代替解释，可以说明为什么特定的结果发生。</p>
<p>教训：</p>
<ul>
<li>很多类型的事件都可以通过各种相互替代的原因来加以解释。</li>
<li>专家可以检查同一个证据的而发现不同原因对其进行解释。</li>
<li>大部分持论者只给你那些他们喜欢的原因，独立思考的读者必须自己找出替代原因。</li>
<li>特定因果断言的确定性和言之成理的替代原因的数量正好成反比。</li>
</ul>
<h4 id="找到更多的替代原因"><a href="#找到更多的替代原因" class="headerlink" title="找到更多的替代原因"></a>找到更多的替代原因</h4><ul>
<li>我能不能找到其他的方法来解释这个证据</li>
<li>从其他角度看问题，找重要原因</li>
<li>如果这个解释不正确，还有什么别的解释可以说得通</li>
</ul>
<h4 id="唯一的原因还是原因之一"><a href="#唯一的原因还是原因之一" class="headerlink" title="唯一的原因还是原因之一"></a>唯一的原因还是原因之一</h4><p>我们找到的任何一个单独的原因都极有可能是引起事件发生的其中一个原因，而不是其唯一的原因。</p>
<h4 id="组间差异代替原因"><a href="#组间差异代替原因" class="headerlink" title="组间差异代替原因"></a>组间差异代替原因</h4><p>研究人员将一个实验组同一个控制组进行比较.</p>
<ul>
<li>很多种因素可能引起研究组之间的差异</li>
</ul>
<h4 id="相关不能证明因果关系"><a href="#相关不能证明因果关系" class="headerlink" title="相关不能证明因果关系"></a>相关不能证明因果关系</h4><ul>
<li>甲是乙的一个起因</li>
<li>乙是甲的一个起因</li>
<li>甲和乙有关系是因为第三种因素</li>
<li>甲和乙互相影响</li>
</ul>
<h4 id="在这之后不等于因为这个"><a href="#在这之后不等于因为这个" class="headerlink" title="在这之后不等于因为这个"></a>在这之后不等于因为这个</h4><p>一件事紧接在另一件事后面发生的这一发现本身并不能证明两者之间因果关系，这可能是个巧合。</p>
<h4 id="很多事情并非只有一个解释"><a href="#很多事情并非只有一个解释" class="headerlink" title="很多事情并非只有一个解释"></a>很多事情并非只有一个解释</h4><p>千万不要贸然接受你所遇到的事件的第一个解释。</p>
<h4 id="哪个原因更合理"><a href="#哪个原因更合理" class="headerlink" title="哪个原因更合理"></a>哪个原因更合理</h4><p>比较理由时，使用下列标准：</p>
<ul>
<li>逻辑上的合理性</li>
<li>和你所学的其他知识的一致性</li>
<li>以前解释或预测事件的成功率</li>
</ul>
<h4 id="发觉潜在原因，逐步缩小潜在原因的范围"><a href="#发觉潜在原因，逐步缩小潜在原因的范围" class="headerlink" title="发觉潜在原因，逐步缩小潜在原因的范围"></a>发觉潜在原因，逐步缩小潜在原因的范围</h4><h3 id="数据有没有欺骗性"><a href="#数据有没有欺骗性" class="headerlink" title="数据有没有欺骗性"></a>数据有没有欺骗性</h3><p>要找出欺骗性的数据，第一个策略就是尽量找出足够多的关于这些数据是如何采集的信息。</p>
<p>在对这样的数据做出反应之前，我们先要问一声他们是怎么得到的。</p>
<h4 id="令人困扰的平均值"><a href="#令人困扰的平均值" class="headerlink" title="令人困扰的平均值"></a>令人困扰的平均值</h4><p>平均值的种类以及计算方法：</p>
<ul>
<li>平均数：把所有数值相加除以总数。</li>
<li>中位数：把所有数值排序，位于最中间的数值。</li>
<li>众数：出现频率最高的数字。</li>
</ul>
<p>不仅判断一个平均值是平均数，中位数还是众数非常重要，判断最小数值和最大数值之间的差距即全距以及每个数值出现的频率也很重要。</p>
<p>了解全距和数值分布的一个整体好处就是这样会提醒你大多数人或事并不正好符合平均值，与平均值差异极大的结果也在意料中。</p>
<h4 id="把一个结论改头换面包装成另一个结论"><a href="#把一个结论改头换面包装成另一个结论" class="headerlink" title="把一个结论改头换面包装成另一个结论"></a>把一个结论改头换面包装成另一个结论</h4><p>我们要加倍注意统计数据的措辞和结论的措辞，看看二者是不是指的同一件事，如果不是，数据说谎。</p>
<h4 id="省略数据也是欺骗"><a href="#省略数据也是欺骗" class="headerlink" title="省略数据也是欺骗"></a>省略数据也是欺骗</h4><p>在判断数据影响力前还要哪些进一步的信息。</p>
<p>当前遇到听起来让人心动的数字或者百分比，一定要当心。绝对数值百分比比较，相对比较信息忽略。</p>
<h4 id="表达方式不同效果更加动人"><a href="#表达方式不同效果更加动人" class="headerlink" title="表达方式不同效果更加动人"></a>表达方式不同效果更加动人</h4><p>当遇到数字统计论证时，要了解相对结果和绝对结果。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>了解数据是怎样产生的，数据的含义，以及数据存在的局限性。</p>
<h3 id="有什么重要信息被忽略了"><a href="#有什么重要信息被忽略了" class="headerlink" title="有什么重要信息被忽略了"></a>有什么重要信息被忽略了</h3><h4 id="接受说服之前，先打问号"><a href="#接受说服之前，先打问号" class="headerlink" title="接受说服之前，先打问号"></a>接受说服之前，先打问号</h4><p>应应该记住几乎任何一个你所遇到的信息都有一个目的。换句话说就是这个信息的组织结构是由别人精心挑选呈现的，目的就是希望它从某种程度上影响到你的思维。</p>
<h4 id="不完整的推论在所难免"><a href="#不完整的推论在所难免" class="headerlink" title="不完整的推论在所难免"></a>不完整的推论在所难免</h4><p>不完整推论出现的理由：</p>
<ul>
<li>时空(时间空间)对推论产生了限制。</li>
<li>由于读者注意力集中时间的限制，论证必须尽快完成。</li>
<li>持论者的知识的不全面。</li>
<li>论证常常是为了欺骗(广告)。</li>
<li>持论者常常与你有不同的价值观，信仰和态度。</li>
</ul>
<h4 id="识别省略信息的线索"><a href="#识别省略信息的线索" class="headerlink" title="识别省略信息的线索"></a>识别省略信息的线索</h4><p>找到常见类型重要信息的提示：</p>
<h5 id="常见的反驳论证"><a href="#常见的反驳论证" class="headerlink" title="常见的反驳论证"></a>常见的反驳论证</h5><ul>
<li>反对的人会提什么理由</li>
<li>有没有研究和所说的研究冲突</li>
<li>有没有备受尊敬的权威人士提供的例子，证词或观点被省略掉，或者支持对立面的类比被忽略</li>
</ul>
<h5 id="遗漏掉的定义"><a href="#遗漏掉的定义" class="headerlink" title="遗漏掉的定义"></a>遗漏掉的定义</h5><p>如果关键词用另一种方式定义，这个结论会有怎样的不同。</p>
<h5 id="遗漏的价值观偏向或视角"><a href="#遗漏的价值观偏向或视角" class="headerlink" title="遗漏的价值观偏向或视角"></a>遗漏的价值观偏向或视角</h5><ul>
<li>不同的价值观会不会产生处理这一论题的不同方法</li>
<li>与作者从不同的价值观出发会产生怎样的论证</li>
</ul>
<h5 id="论证中”事实”的来源"><a href="#论证中”事实”的来源" class="headerlink" title="论证中”事实”的来源"></a>论证中”事实”的来源</h5><ul>
<li>事实的来源是什么</li>
<li>事实是不是由出色的研究和可靠的来源支撑</li>
</ul>
<h5 id="获得事实的细节"><a href="#获得事实的细节" class="headerlink" title="获得事实的细节"></a>获得事实的细节</h5><p>有多少人完成问卷？问题措辞？调查者有没有机会选择其他选项。</p>
<h5 id="收集证据的其他技巧"><a href="#收集证据的其他技巧" class="headerlink" title="收集证据的其他技巧"></a>收集证据的其他技巧</h5><ul>
<li>访谈和书面问卷的结果可能有怎样的不同</li>
<li>实验室试验示范可以产生更可靠的结果</li>
</ul>
<h5 id="遗漏掉的或者不完整的数字，图表，表格湖综合数据"><a href="#遗漏掉的或者不完整的数字，图表，表格湖综合数据" class="headerlink" title="遗漏掉的或者不完整的数字，图表，表格湖综合数据"></a>遗漏掉的或者不完整的数字，图表，表格湖综合数据</h5><ul>
<li>如果数据包含早期挥着未来的数据看起来会不会不一样。</li>
<li>有没有故意拉长数字让差距显得很大</li>
</ul>
<h5 id="省略的结果，不管是正面反面，短期长期，还是提倡反对"><a href="#省略的结果，不管是正面反面，短期长期，还是提倡反对" class="headerlink" title="省略的结果，不管是正面反面，短期长期，还是提倡反对"></a>省略的结果，不管是正面反面，短期长期，还是提倡反对</h5><ul>
<li>省略的结果代价是什么？好处又是什么？</li>
</ul>
<h4 id="考虑是否有负面效果"><a href="#考虑是否有负面效果" class="headerlink" title="考虑是否有负面效果"></a>考虑是否有负面效果</h4><p>被提倡的行动的潜在负面效果。</p>
<p>提议潜在的长期负面效果是什么？</p>
<h4 id="面对信息缺失的现实"><a href="#面对信息缺失的现实" class="headerlink" title="面对信息缺失的现实"></a>面对信息缺失的现实</h4><p>自动声明只要信息仍然找不到你就不能做出决断，那就会阻止你形成任何观点。</p>
<h3 id="能得出什么合理的结论"><a href="#能得出什么合理的结论" class="headerlink" title="能得出什么合理的结论"></a>能得出什么合理的结论</h3><p>从一套理由中可以得出多套理论，它们都有可能是这套理由得出的结果。</p>
<h4 id="各种假设和各种结论"><a href="#各种假设和各种结论" class="headerlink" title="各种假设和各种结论"></a>各种假设和各种结论</h4><p>理由可以解释成不同的含义，结论只有在某人对理由的含义进行特定的解读或者假设才能得出来。</p>
<p>如果你对理由的不同含义进行不同的测试，那你就会得出不同的结论。</p>
<h4 id="二分式思维方法-妨碍我们考虑多种可能"><a href="#二分式思维方法-妨碍我们考虑多种可能" class="headerlink" title="二分式思维方法:妨碍我们考虑多种可能"></a>二分式思维方法:妨碍我们考虑多种可能</h4><p>人们习惯用非黑即白，非是即否，非对即错的方式来思考问题，这就是二分式思维。</p>
<h4 id="两面还是多面"><a href="#两面还是多面" class="headerlink" title="两面还是多面"></a>两面还是多面</h4><p>一些问题好似在寻求一个是或不是的答案，但是还有很多种可能，是的情况下和不是的情况下的每种理由都是一种可能。</p>
<h4 id="寻找多个结论"><a href="#寻找多个结论" class="headerlink" title="寻找多个结论"></a>寻找多个结论</h4><p>即使我们接受了特定理由，我们也不一定就能得出特定的结论。</p>
<h4 id="某个条件下才合理的理由"><a href="#某个条件下才合理的理由" class="headerlink" title="某个条件下才合理的理由"></a>某个条件下才合理的理由</h4><p>条件句为你提供了多种结论，他们同时也增加了结论的范围。</p>
<h4 id="以解决问题为导向的可能结论"><a href="#以解决问题为导向的可能结论" class="headerlink" title="以解决问题为导向的可能结论"></a>以解决问题为导向的可能结论</h4><p>当一个规定性论证中的理由是实际存在的问题时，寻找这个问题不同的解决方法就是这个论证可能得出的结论。</p>
<h4 id="更多可能的结论，更多可能的自由选择"><a href="#更多可能的结论，更多可能的自由选择" class="headerlink" title="更多可能的结论，更多可能的自由选择"></a>更多可能的结论，更多可能的自由选择</h4><h4 id="“是什么”和”应不应该”的问题"><a href="#“是什么”和”应不应该”的问题" class="headerlink" title="“是什么”和”应不应该”的问题"></a>“是什么”和”应不应该”的问题</h4><h4 id="论题种类-：描述性论题和规定性论题。"><a href="#论题种类-：描述性论题和规定性论题。" class="headerlink" title="论题种类 ：描述性论题和规定性论题。"></a>论题种类 ：描述性论题和规定性论题。</h4><p>这些论题都属于描述性论题。描述性论题指对过去，现在活着将来的各种描述的精确与否提出的问题。</p>
<p>规定性论题：指对什么该做什么不该做，什么是对什么是错，什么是好什么是坏所提出的问题。</p>
<h4 id="他想让我相信什么结论"><a href="#他想让我相信什么结论" class="headerlink" title="他想让我相信什么结论"></a>他想让我相信什么结论</h4><p>你相信一个结论是因为它由其他方法支撑，这就是在进行推理。一旦找到结论，就将结论作为你评论的重点。</p>
<h4 id="找到结论的方法"><a href="#找到结论的方法" class="headerlink" title="找到结论的方法"></a>找到结论的方法</h4><ul>
<li>问问论题是什么</li>
<li>寻找指示词(因此，表明。。。)</li>
<li>在可能的位置上查看一下</li>
<li>记住不可能作为结论的东西</li>
<li>检查一下交流的语境和作者的背景</li>
<li>问一问”所以吶”</li>
</ul>
<h3 id="理由是什么？"><a href="#理由是什么？" class="headerlink" title="理由是什么？"></a>理由是什么？</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android 安全概述" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/17/Android 安全概述/" class="article-date">
  	<time datetime="2017-03-16T16:00:00.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Android 安全概述/">
        Android 安全概述
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="安全要点"><a href="#安全要点" class="headerlink" title="安全要点"></a>安全要点</h3><p>Android 操作系统内置了安全功能，可显著降低应用出现安全问题的频率及其造成的影响。系统经过精心设计，您在通常情况下只需使用默认的系统和文件权限即可打造自己的应用，而无需费心针对安全性作出艰难决策。</p>
<p>下面是一些可以帮助您打造安全应用的核心安全功能：</p>
<ul>
<li>Android 应用沙盒，可以将您的应用数据和代码执行与其他应用分隔开来。</li>
<li>应用框架，可以稳健实现常见的安全性功能，例如加密、权限和安全 IPC。</li>
<li>ASLR、NX、ProPolice、safe_iop、OpenBSD dlmalloc、OpenBSD calloc 和 Linux mmap_min_addr 等多项技术，可降低与常见内存管理错误相关的风险。</li>
<li>加密的文件系统，启用后可保护丢失或被盗设备上的数据。</li>
<li>用户授予的权限，可用来限制对系统功能和用户数据的使用。</li>
<li>应用定义的权限，可针对各个应用分别控制应用数据。</li>
</ul>
<p>不过，我们仍建议您熟悉一下本文档中所述的 Android 安全性最佳做法。遵循这些最佳做法，养成常规编码习惯，就可以有效减少因疏忽而引发安全问题的几率，防止对用户产生不利的影响。</p>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h4 id="内部存储-在设备内存中存储私有数据"><a href="#内部存储-在设备内存中存储私有数据" class="headerlink" title="内部存储(在设备内存中存储私有数据)"></a>内部存储(在设备内存中存储私有数据)</h4><p>默认情况下，您在内部存储空间中创建的文件仅供您的应用访问。这项保护措施由 Android 实现，而且这对于大多数应用来说足够了。</p>
<p>尽量避免将 MODE_WORLD_WRITEABLE 或 MODE_WORLD_READABLE 模式用于 IPC 文件，因为在这两种模式下，系统不提供针对特定应用限制数据访问的功能，也不会对数据格式进行任何控制。</p>
<h4 id="使用外部存储设备-在共享的外部存储中存储公共数据"><a href="#使用外部存储设备-在共享的外部存储中存储公共数据" class="headerlink" title="使用外部存储设备(在共享的外部存储中存储公共数据)"></a>使用外部存储设备(在共享的外部存储中存储公共数据)</h4><p>在外部存储设备（例如 SD 卡）上创建的文件不受任何读取和写入权限的限制。对于外部存储设备中的内容，不仅用户可以将其移除，而且任何应用都可以对其进行修改，因此最好不要使用外部存储设备来存储敏感信息。</p>
<h4 id="使用内容提供程序"><a href="#使用内容提供程序" class="headerlink" title="使用内容提供程序"></a>使用内容提供程序</h4><p>在创建要导出以供其他应用使用的 ContentProvider 时，您可以在清单中指定允许读取和写入的单一权限，也可以针对读取和写入操作分别指定权限。我们建议您仅对需要完成相应任务的应用授予权限。请注意，与其移除权限而影响到现有用户，不如以后要使用新功能时再添加权限。</p>
<p>如果您要使用内容提供程序仅在自己的应用之间共享数据，最好将 android:protectionLevel 属性设置为 “signature” 保护级别。签名权限不需要用户确认，因此，这种方式不仅能提升用户体验，而且在相关应用使用相同的密钥进行签名来访问数据时，还能更好地控制对内容提供程序数据的访问。</p>
<p>内容提供程序还可以通过以下方式提供更细化的访问权限：声明 android:grantUriPermissions 属性，并使用用来启动组件的 Intent 对象中的 FLAG_GRANT_READ_URI_PERMISSION 和 FLAG_GRANT_WRITE_URI_PERMISSION 标记。使用 <grant-uri-permission element=""> 还能进一步限制这些权限的范围。</grant-uri-permission></p>
<p>访问内容提供程序时，请使用参数化的查询方法（例如 query()、update() 和 delete()），以免产生来源不受信任的 SQL 注入风险。请注意，如果以组合用户数据的方式构建 selection 参数，然后再将其提交至参数化方法，则使用参数化方法可能不够安全。</p>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>由于 Android 通过沙盒机制管理各个应用，因此应用必须以明确的方式共享资源和数据。应用会通过声明自己需要的权限来获取基本沙盒未提供的额外功能（包括对相机等设备功能的访问权限），从而实现这一点。</p>
<h4 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h4><p>尽量减少应用请求的权限。如果不具备对敏感数据的访问权限，就能降低不慎误用这类权限的风险，并可提高用户的采用率，同时让您的应用不那么容易受到攻击者的攻击。一般来说，如果您的应用无需某项权限也能正常运行，就不要请求该权限。</p>
<p>除了请求权限之外，您的应用也可以使用 <permissions> 来保护对安全性要求较高且会被其他应用访问的 IPC，例如 ContentProvider。一般而言，我们建议您尽量使用访问权限控制，而不使用需要用户确认的权限，因为权限管理对用户来说可能比较复杂。例如，对于同一开发者提供的不同应用之间的 IPC 通信，不妨使用 “signature” 保护级别。</permissions></p>
<h4 id="创建权限"><a href="#创建权限" class="headerlink" title="创建权限"></a>创建权限</h4><p>如果必须创建新权限，请尽量考虑创建 “signature” 保护级别的权限。“签名”级别权限的内容对用户完全透明开放，而且只有由执行权限检查的应用的开发者签名的应用才可访问这些内容。</p>
<p>如果您创建了 “dangerous” 保护级别的权限，则事情就会更加复杂，您需要注意：</p>
<ul>
<li>该权限必须包含一个字符串，向用户清楚明确地说明他们需要做出的安全决策。</li>
<li>该权限的字符串必须翻译成多种不同语言。</li>
<li>用户可能会因为权限含糊不清或存在风险而选择不安装应用。</li>
<li>应用可能会在权限创建程序尚未安装的情况下请求权限。</li>
</ul>
<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><h4 id="使用-IP-网络"><a href="#使用-IP-网络" class="headerlink" title="使用 IP 网络"></a>使用 IP 网络</h4><p>Android 网络运行机制与其他 Linux 环境差别不大，关键是确保对敏感数据使用合适的协议，如使用 HttpsURLConnection 来保证网络流量安全。我们建议您在服务器支持 HTTPS 的情况下一律使用 HTTPS（而非 HTTP），因为移动设备经常会连接到不安全的网络（如公共 WLAN 热点）。</p>
<p>您可以使用 SSLSocket 类轻松实现经过身份验证和加密的套接字层通信。考虑到 Android 设备会频繁使用 WLAN 连接到不安全的无线网络，我们强烈建议所有通过网络通信的应用使用安全的网络。</p>
<p>我们发现有些应用使用 localhost 网络端口处理敏感的 IPC。我们不建议采用这种方法，因为设备上的其他应用也可以访问这些接口。相反，您应该使用可通过 Service 等进行身份验证的 Android IPC 机制。（绑定到 INADDR_ANY 比使用回送功能还要糟糕，因为这样一来，您的应用可能会收到任何位置发来的请求。）</p>
<p>此外，还有一个需要再三强调的常见问题就是，切勿相信通过 HTTP 或其他非安全协议下载的数据，包括 WebView 中的输入验证以及对通过 HTTP 发出的 intent 的任何响应。</p>
<h4 id="使用电话网络"><a href="#使用电话网络" class="headerlink" title="使用电话网络"></a>使用电话网络</h4><p>短信 协议主要是为用户间通信设计的，并不适合要传输数据的应用。考虑到短信的局限性，因此，想从网络服务器向用户设备上安装的应用发送数据消息时，我们强烈建议您使用 Google 云消息传递 (GCM) 和 IP 网络。</p>
<p>请注意，短信在网络上和设备上均未经过加密，也没有经过严格的身份验证。而且，短信的所有接收者都应明白，您的应用收到的短信可能来自恶意用户。因此，切勿使用未经身份验证的短信数据执行敏感命令。还需要注意的是，短信可能包含欺骗性内容，也有可能在网络上传输时被拦截。在 Android 设备上，短信会以广播 intent 的形式传输，因此可能会被其他拥有 READ_SMS 权限的应用读取或捕获。</p>
<h3 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h3><p>无论应用是在哪种平台上运行，输入验证功能不完善都是影响应用的最常见安全问题。Android 为此提供了平台级对策，可降低应用出现输入验证问题的可能性。如果可行，请尽量使用这些功能。另请注意，选择类型安全的语言通常也有助于降低出现输入验证问题的可能性。</p>
<p>使用基于字符串的动态语言（如 JavaScript 和 SQL）也可能因为转义字符和脚本注入而出现输入验证问题。</p>
<h3 id="处理用户数据"><a href="#处理用户数据" class="headerlink" title="处理用户数据"></a>处理用户数据</h3><p>通常情况下，确保用户数据安全的最佳做法是尽量避免使用会访问用户敏感数据或个人数据的 API。如果您拥有用户数据的访问权限，并且能够避免存储或传输这些信息，那么就不要存储或传输这些数据。最后，请评估您的应用逻辑能否使用经过哈希算法处理或不可逆的数据格式进行实现。例如，您的应用可能会使用电子邮件地址的哈希值作为主要密钥，以避免传输或存储电子邮件地址。这样可降低在无意之中泄露数据的可能性，还可以降低攻击者尝试利用您的应用搞破坏的可能性。</p>
<p>请注意，如果您的应用会访问密码或用户名等个人信息，部分司法辖区可能会要求您提供隐私权政策，以说明您如何使用或存储这类数据。因此，遵循安全最佳做法（即尽可能减少对用户数据的访问）也有助于简化合规工作。</p>
<p>此外，您还应考虑自己的应用是否会在无意之中将个人信息泄露给其他方，如广告使用的第三方组件或应用使用的第三方服务。如果不知道某个组件或服务为什么需要个人信息，就不要提供个人信息。通常，减少您的应用对个人信息的访问，可以降低引发这方面问题的可能性。</p>
<p>如果必须访问敏感数据，请判断这些信息是必须传输至服务器，还是可以在客户端上执行相应操作。建议您在客户端上运行所有需要使用敏感数据的代码，以避免传输用户数据。</p>
<p>此外，请务必不要使用权限过于宽松的 IPC、完全没有写入限制的文件或网络套接字，避免在无意之中将用户数据泄露给设备上的其他应用。这属于一种造成受权限保护的数据遭泄露的特殊情况，我们已在请求权限部分讨论过。</p>
<p>如果需要 GUI(Globally Unique Identifier) ，请创建一个较长的具有唯一性的编号并加以存储。请勿使用可能与个人信息关联的电话标识符，如电话号码或 IMEI。</p>
<p>GUI:</p>
<ul>
<li><p>Mac Address<br>It may be possible to retrieve a Mac address from a device’s WiFi or Bluetooth hardware. We do not recommend using this as a unique identifier. To start with, not all devices have WiFi. Also, if the WiFi is not turned on, the hardware may not report the Mac address.</p>
</li>
<li><p>Serial Number<br>Since Android 2.3 (“Gingerbread”) this is available via android.os.Build.SERIAL. Devices without telephony are required to report a unique device ID here; some phones may do so also.</p>
</li>
<li><p>ANDROID_ID<br>More specifically, Settings.Secure.ANDROID_ID. This is a 64-bit quantity that is generated and stored when the device first boots. It is reset when the device is wiped.</p>
</li>
<li><p>ANDROID_ID seems a good choice for a unique device identifier. There are downsides: First, it is not 100% reliable on releases of Android prior to 2.2 (“Froyo”). Also, there has been at least one widely-observed bug in a popular handset from a major manufacturer, where every instance has the same ANDROID_ID.</p>
</li>
<li><p>Conclusion<br>For the vast majority of applications, the requirement is to identify a particular installation, not a physical device. Fortunately, doing so is straightforward.</p>
</li>
</ul>
<p>向设备上的日志写入内容时，请务必谨慎小心。在 Android 中，日志是共享资源，拥有 READ_LOGS 权限的所有应用均可访问。即使电话日志数据是临时数据并会在重新启动时清空，不当记录用户信息也可能在无意之中将用户数据泄露给其他应用。</p>
<h3 id="使用-WebView"><a href="#使用-WebView" class="headerlink" title="使用 WebView"></a>使用 WebView</h3><p>由于 WebView 使用的网络内容可能包含 HTML 和 JavaScript，当的使用可能引入常见的网络安全问题，例如跨站脚本攻击（JavaScript 注入）。Android 内置了多种机制，可将 WebView 的功能限制为您应用所需的最低功能，以缩小这些潜在问题的影响范围。</p>
<p>如果您的应用不直接使用 WebView 中的 JavaScript，请勿调用 setJavaScriptEnabled()。部分示例代码会使用这种方法，不过您可能需要在实际应用时根据具体情况进行调整。因此，如果不需要使用这种调用方法，请将其移除。默认情况下，WebView 不会执行 JavaScript，因此不可能出现跨站脚本攻击这样的安全问题。</p>
<p>addJavaScriptInterface() 允许 JavaScript 调用正常情况下是为 Android 应用预留的操作，因此在使用时请格外小心。如果要使用，请仅将 addJavaScriptInterface() 用于所有输入内容都可信的网页。如果您接受不受信任的输入内容，那么不受信任的 JavaScript 可能会调用您应用中的 Android 方法。一般情况下，我们建议您仅将 addJavaScriptInterface() 用于应用 APK 内含的 JavaScript。</p>
<p>如果您的应用通过 WebView 访问敏感数据，您可能需要使用 clearCache() 方法来删除本地存储的所有文件。您也可以使用服务器端标头（例如 no-cache）来指示应用不应缓存特定内容。</p>
<p>在 Android 4.4（API 级别 19）之前平台上运行的设备使用的 webkit 版本存在多个安全问题。如果您的应用在这些设备上运行，解决方法是确认 WebView 对象只显示值得信任的内容。还应使用可更新的安全 Provider 对象确保您的应用在 SSL 中不会暴露给潜在的漏洞，如更新您的安全提供程序以防范 SSL 攻击中所述。如果您的应用必须从开放网络渲染内容，请考虑提供您自己的渲染程序，以便使用最新的安全补丁程序保持其处于最新状态。</p>
<h3 id="处理凭据"><a href="#处理凭据" class="headerlink" title="处理凭据"></a>处理凭据</h3><p>一般情况下，我们建议您尽量降低要求用户凭据的频率；这样会让钓鱼攻击显得比较可疑，从而能够降低其成功率。作为替代方法，您可以使用授权令牌并根据需要刷新。</p>
<p>请尽量避免将用户名和密码存储在设备上。您可以使用用户提供的用户名和密码进行初始身份验证，然后使用针对特定服务的短时效授权令牌。</p>
<p>可供多个应用访问的服务应使用 AccountManager 进行访问。如果可行，请使用 AccountManager 类来调用基于云的服务；此外，请勿将密码存储在设备上。</p>
<p>使用 AccountManager 检索 Account 后，请先确认 CREATOR 再传送凭据，以免无意中将凭据传送给错误的应用。</p>
<p>如果凭据仅供您创建的应用使用，那么您可以使用 checkSignature() 验证访问 AccountManager 的应用。另外，如果只有一个应用使用该凭据，那么您可以使用 KeyStore 存储凭据。</p>
<h3 id="使用加密"><a href="#使用加密" class="headerlink" title="使用加密"></a>使用加密</h3><p>Android 不仅提供数据隔离机制、支持完整文件系统加密并提供安全通信通道，还提供大量使用加密来保护数据的算法。</p>
<p>一般情况下，请尝试根据您的具体情况使用已经实现的最高级别的框架。如果您需要从某个已知位置安全地检索文件，使用简单的 HTTPS URI 即可满足需要，无需具备加密知识。如果您需要一个安全通道，不妨考虑使用 HttpsURLConnection 或 SSLSocket，而无需自行编写协议。</p>
<h3 id="使用进程间通信"><a href="#使用进程间通信" class="headerlink" title="使用进程间通信"></a>使用进程间通信</h3><p>部分应用会尝试使用传统 Linux 技术（如网络套接字和共享文件）来实现 IPC。强烈建议您改为使用 Android 针对 IPC 提供的系统功能，例如使用 Service 的 Intent、Binder 或 Messenger，以及 BroadcastReceiver。Android IPC 机制让您验证连接至 IPC 的应用的身份，并为每种 IPC 机制设置安全策略。</p>
<p>许多安全元素在各种 IPC 机制之间是共享的。如果您的 IPC 机制并不打算让其他应用使用，请在该组件的清单元素（例如 <service> 元素）中将 android:exported 属性设置为 “false”。对于同一 UID 中包含多项进程的应用，这种做法非常有用；当您在以后的开发过程中决定不以 IPC 的形式提供功能但又不想重新编写代码时，这样做也会有所助益。</service></p>
<p>如果您的 IPC 预期供其他应用访问，您可以使用 <permission> 元素应用安全策略。如果 IPC 是在您自己的不同应用（以同一密钥登录）之间使用，建议您在 android:protectionLevel 中使用 “signature” 级别权限。</permission></p>
<h3 id="动态加载代码"><a href="#动态加载代码" class="headerlink" title="动态加载代码"></a>动态加载代码</h3><p>我们强烈建议您不要从应用 APK 外部加载代码。这样做不仅会明显加大应用因代码注入或代码篡改产生问题的可能性，还会增加版本管理和应用测试的难度。这最终会导致无法验证应用的行为，因此，某些环境中可能会禁止采用此做法。</p>
<p>如果您的应用会动态加载代码，您务必谨记，运行动态加载的代码需要拥有与应用 APK 相同的安全权限。用户是因为您才决定安装您的应用的，因此他们希望您提供的是在您的应用内运行的代码，包括动态加载的代码。</p>
<p>与动态加载代码相关的主要安全风险与这样的代码需要来自可验证的来源有关。如果这些模块已直接纳入您的 APK 中，那么其他应用就无法对其进行修改；无论代码是原生库代码还是使用 DexClassLoader 加载的类，均是如此。我们见过很多应用尝试从不安全的位置（例如，通过未加密的协议从网络上进行下载）或任何人都可写入内容的位置（如外部存储设备）加载代码的例子；对于前一种位置，网络上的用户将可以修改正在传输的内容，对于后一种位置，用户设备上的其他应用将可以修改设备上的内容。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-单元测试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/03/单元测试/" class="article-date">
  	<time datetime="2017-03-02T16:00:00.000Z" itemprop="datePublished">2017-03-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/03/单元测试/">
        单元测试
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。单元测试只是测试一个方法单元，它不是测试一整个流程。</p>
<p>一个类的方法可以分为两种，一种是有返回值的，另一种是没有返回值的。对于有返回值的方法，我们要测起来比较容易，就跟上面的Calculator例子那样，输入相应的参数，得到相应的返回值，然后验证得到的返回值跟我们预期的值一样，就好了。另外一种就是返回值为void的，我们只关注某些方法是否被调用了以及调用的次数，这时候就要用到mock技术来模拟这些操作。</p>
<h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><p>mock对象就是在调试期间用来作为真实对象的替代品。Mockito是Java中常见的Mock框架。</p>
<p>所谓的mock就是创建一个类的虚假的对象，在测试环境中，用来替换掉真实的对象.</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li><p>验证这个对象的某些方法的调用情况，调用了多少次，参数是什么等等</p>
</li>
<li><p>指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作</p>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>引入 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile 'org.mockito:mockito-core:version'</span><br></pre></td></tr></table></figure>
<h4 id="验证行为"><a href="#验证行为" class="headerlink" title="验证行为"></a>验证行为</h4><p>method</p>
<ul>
<li>Mockito.verify() ：验证Mock对象的方法是否被调用。</li>
<li>Mockito.times() ：调用Mock对象的方法次数。</li>
<li>Mockito.atMost(count) , Mockito.atLeast(count) , Mockito.never() ：最多次数，最少次数，永远调用。</li>
<li>Mockito.anyInt() , Mockito.anyLong() , Mockito.anyDouble()等等 ： 参数设置-任意的Int类型，任意的Long类型。。。等。</li>
</ul>
<h4 id="验证方法的调用"><a href="#验证方法的调用" class="headerlink" title="验证方法的调用"></a>验证方法的调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.verify(mockUserManager,Mockito.times(<span class="number">2</span>)).performLogin(<span class="string">"shenyonghe"</span>, <span class="string">"123423423"</span>);</span><br></pre></td></tr></table></figure>
<p>其实更准确的说法是，这行代码验证的是，mockUserManager的performLogin()方法得到了两次调用。</p>
<h4 id="指定mock对象的某些方法的行为"><a href="#指定mock对象的某些方法的行为" class="headerlink" title="指定mock对象的某些方法的行为"></a>指定mock对象的某些方法的行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当调用mockValidator的verifyPassword方法，同时传入"xiaochuang_is_handsome"时，返回true</span></span><br><span class="line">Mockito.when(mockValidator.verifyPassword(<span class="string">"xiaochuang_is_handsome"</span>)).thenReturn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当调用mockValidator的verifyPassword方法，同时传入"xiaochuang_is_not_handsome"时，返回false</span></span><br><span class="line">Mockito.when(validator.verifyPassword(<span class="string">"xiaochuang_is_not_handsome"</span>)).thenReturn(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>同样的，你可以用any系列方法来指定”无论传入任何参数值，都返回xxx”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当调用mockValidator的verifyPassword方法时，返回true，无论参数是什么</span></span><br><span class="line">Mockito.when(validator.verifyPassword(anyString())).thenReturn(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>假设登录代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginCallbackVersion</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//假设我们对密码强度有一定要求，使用一个专门的validator来验证密码的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (mPasswordValidator.verifyPassword(password)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//login的结果将通过callback传递回来。</span></span><br><span class="line">    mUserManager.performLogin(username, password, <span class="keyword">new</span> NetworkCallback() &#123;  <span class="comment">//&lt;==</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//update view with data</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//show error msg</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mock实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Mockito.doAnswer(desiredAnswer).when(mockObject).targetMethod(args);</span><br><span class="line"></span><br><span class="line">传给doAnswer()的是一个Answer对象，我们想要执行什么样的动作，就在这里面实现。结合上面的例子解释：</span><br><span class="line"></span><br><span class="line">Mockito.doAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//这里可以获得传给performLogin的参数</span></span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//callback是第三个参数</span></span><br><span class="line">        NetworkCallback callback = (NetworkCallback) arguments[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        callback.onFailure(<span class="number">500</span>, <span class="string">"Server error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).when(mockUserManager).performLogin(anyString(), anyString(), any(NetworkCallback.class));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### spy </span><br><span class="line"></span><br><span class="line">指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作</span><br><span class="line"></span><br><span class="line">最后介绍一个Spy的东西。前面我们讲了mock对象的两大功能，对于第二大功能: 指定方法的特定行为，不知道你会不会好奇，如果我不指定的话，它会怎么样呢？那么现在补充一下，如果不指定的话，一个mock对象的所有非<span class="keyword">void</span>方法都将返回默认值：<span class="keyword">int</span>、<span class="keyword">long</span>类型方法将返回<span class="number">0</span>，<span class="keyword">boolean</span>方法将返回<span class="keyword">false</span>，对象方法将返回<span class="keyword">null</span>等等；而<span class="keyword">void</span>方法将什么都不做。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">//假设目标类的实现是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordValidator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"xiaochuang_is_handsome"</span>.equals(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//跟创建mock类似，只不过调用的是spy方法，而不是mock方法。spy的用法</span></span><br><span class="line">    PasswordValidator spyValidator = Mockito.spy(PasswordValidator.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在默认情况下，spy对象会调用这个类的真实逻辑，并返回相应的返回值，这可以对照上面的真实逻辑</span></span><br><span class="line">    spyValidator.verifyPassword(<span class="string">"xiaochuang_is_handsome"</span>); <span class="comment">//true</span></span><br><span class="line">    spyValidator.verifyPassword(<span class="string">"xiaochuang_is_not_handsome"</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//spy对象的方法也可以指定特定的行为</span></span><br><span class="line">    Mockito.when(spyValidator.verifyPassword(anyString())).thenReturn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样的，可以验证spy对象的方法调用情况</span></span><br><span class="line">    spyValidator.verifyPassword(<span class="string">"xiaochuang_is_handsome"</span>);</span><br><span class="line">    Mockito.verify(spyValidator).verifyPassword(<span class="string">"xiaochuang_is_handsome"</span>); <span class="comment">//pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，spy与mock的唯一区别就是默认行为不一样：spy对象的方法默认调用真实的逻辑，mock对象的方法默认什么都不做，或直接返回默认值。</p>
<h3 id="方法详情"><a href="#方法详情" class="headerlink" title="方法详情"></a>方法详情</h3><h4 id="after"><a href="#after" class="headerlink" title="after"></a>after</h4><p>after()等待整个周期的特点不同于timeout()，而timeout()一旦验证通过就尽快停止，例如：当使用times(2)可以产生不同的行为方式，可能通过后过会又失败。这种情况下，timeout只要times(2)通过就会通过，然后after执行完整个周期时间，可能会失败，也意味着times(2)也失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mock, after(<span class="number">100</span>)).someMethod()</span><br></pre></td></tr></table></figure>
<h4 id="atLeast"><a href="#atLeast" class="headerlink" title="atLeast"></a>atLeast</h4><p>允许至少进行x次验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mock, atLeast(<span class="number">3</span>)).someMethod(<span class="string">"some arg"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="atLeastOnce"><a href="#atLeastOnce" class="headerlink" title="atLeastOnce"></a>atLeastOnce</h4><p>至少进行一次一次验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mock, atLeastOnce()).someMethod(<span class="string">"some arg"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="atMost"><a href="#atMost" class="headerlink" title="atMost"></a>atMost</h4><p>至多进行x次验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mock, atMost(<span class="number">3</span>)).someMethod(<span class="string">"some arg"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="calls"><a href="#calls" class="headerlink" title="calls"></a>calls</h4><p>允许顺序进行non-greedy验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inOrder.verify( mock, calls( <span class="number">2</span> )).someMethod( <span class="string">"some arg"</span> );</span><br></pre></td></tr></table></figure>
<h4 id="Matchers的方法"><a href="#Matchers的方法" class="headerlink" title="Matchers的方法"></a>Matchers的方法</h4><ul>
<li>anyBoolean</li>
<li>anyByte</li>
<li>anyChar</li>
<li>anyCollection</li>
<li>anyCollectionOf</li>
<li>anyDouble</li>
<li>anyFloat</li>
<li>anyInt</li>
<li>anyList</li>
<li>anyListOf</li>
<li>anyLong</li>
<li>anyMap</li>
<li>anyMapOf</li>
<li>anyObject</li>
<li>anySet**</li>
<li>anySetOf</li>
<li>anyShort</li>
<li>anyString</li>
<li>anyVararg</li>
</ul>
<h4 id="description函数"><a href="#description函数" class="headerlink" title="description函数"></a>description函数</h4><p>添加验证失败时要输出的文字内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mock, description(<span class="string">"This will print on failure"</span>)).someMethod(<span class="string">"some arg"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="doAnswer函数"><a href="#doAnswer函数" class="headerlink" title="doAnswer函数"></a>doAnswer函数</h4><p>当你想要测试一个无返回值的函数时，可以使用一个含有泛型类Answer参数的doAnswer()函数。为无返回值的函数做测试桩与when(Objecy)方法不同，因为编译器不喜欢在大括号内使用void函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</span><br><span class="line">          Object[] args = invocation.getArguments();</span><br><span class="line">          Mock mock = invocation.getMock();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;&#125;)</span><br><span class="line">  .when(mock).someMethod();</span><br></pre></td></tr></table></figure>
<h4 id="doCallRealMethod函数"><a href="#doCallRealMethod函数" class="headerlink" title="doCallRealMethod函数"></a>doCallRealMethod函数</h4><p>如果你想调用某一个方法的真实实现请使用doCallRealMethod()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo mock = mock(Foo.class);</span><br><span class="line">doCallRealMethod().when(mock).someVoidMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will call the real implementation of Foo.someVoidMethod()</span></span><br><span class="line"><span class="comment">// 调用Foo.someVoidMethod()的真实现</span></span><br><span class="line">mock.someVoidMethod();</span><br></pre></td></tr></table></figure>
<h4 id="doNothing函数"><a href="#doNothing函数" class="headerlink" title="doNothing函数"></a>doNothing函数</h4><p>使用doNothing()函数是为了设置void函数什么也不做。需要注意的是默认情况下返回值为void的函数在mocks中是什么也不做的但是，也会有一些特殊情况。</p>
<h4 id="doReturn函数"><a href="#doReturn函数" class="headerlink" title="doReturn函数"></a>doReturn函数</h4><p>在某些特殊情况下如果你无法使用when(Object)可以使用doReturn()函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能完成的：真实方法被调用所以spy.get(0)抛出   IndexOutOfBoundsException(list仍是空的)</span></span><br><span class="line">   when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//You have to use doReturn() for stubbing:</span></span><br><span class="line">   <span class="comment">//你应用使用doReturn()函数</span></span><br><span class="line">   doReturn(<span class="string">"foo"</span>).when(spy).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="doThrow函数"><a href="#doThrow函数" class="headerlink" title="doThrow函数"></a>doThrow函数</h4><p>当你想测试void函数中指定类的抛出异常时使用doThrow()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doThrow(RuntimeException.class).when(mock).someVoidMethod();</span><br></pre></td></tr></table></figure>
<h4 id="inOrder函数"><a href="#inOrder函数" class="headerlink" title="inOrder函数"></a>inOrder函数</h4><p>验证in order是很灵活的。你可以只验证你感兴趣的，并不需要一个一个验证所有的交互。同样你也可以创建InOrder对象只在相关in-order的验证中进行传值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InOrder inOrder = inOrder(firstMock, secondMock);</span><br><span class="line">inOrder.verify(firstMock).add(<span class="string">"was called first"</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="mock函数"><a href="#mock函数" class="headerlink" title="mock函数"></a>mock函数</h4><p>对给定的类或接口创建mock对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mock(Class, Answer)</span><br></pre></td></tr></table></figure>
<h4 id="never-函数"><a href="#never-函数" class="headerlink" title="never()函数"></a>never()函数</h4><p>相当于times(0),可参见 times(int) </p>
<h4 id="only-函数"><a href="#only-函数" class="headerlink" title="only()函数"></a>only()函数</h4><p>如果当前mock的方法只被调用一次，则允许被检验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verify(mock, only()).someMethod();</span><br><span class="line"><span class="comment">//上面这行代码是下面这两行代码的简写</span></span><br><span class="line">verify(mock).someMethod();</span><br><span class="line">verifyNoMoreInvocations(mock);</span><br></pre></td></tr></table></figure>
<h4 id="reset-T…-mocks-函数"><a href="#reset-T…-mocks-函数" class="headerlink" title="reset(T… mocks)函数"></a>reset(T… mocks)函数</h4><p>你可以考虑写一些简单的、精悍的、聚焦的测试方法来代替reset()这个方法。当你在在测试方法的中间部分用到reset()这个方法时，说明你的测试方法太庞大了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List mock = mock(List.class);</span><br><span class="line">when(mock.size()).thenReturn(<span class="number">10</span>);</span><br><span class="line">mock.add(<span class="number">1</span>);</span><br><span class="line">reset(mock);</span><br><span class="line"><span class="comment">//此时会清除你之前所有的交互以及测试</span></span><br></pre></td></tr></table></figure>
<h4 id="spy-Class-classToSpy-函数"><a href="#spy-Class-classToSpy-函数" class="headerlink" title="spy(Class classToSpy)函数"></a>spy(Class classToSpy)函数</h4><h4 id="timesout-long-millis-函数"><a href="#timesout-long-millis-函数" class="headerlink" title="timesout(long millis)函数"></a>timesout(long millis)函数</h4><p>允许验证时使用timeout。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在超时之前，`someMethod()`通过了2次调用</span></span><br><span class="line">verify(mock, timeout(<span class="number">100</span>).times(<span class="number">2</span>)).someMethod();</span><br></pre></td></tr></table></figure>
<h4 id="time-int-wantedNumberOfInvocations-函数"><a href="#time-int-wantedNumberOfInvocations-函数" class="headerlink" title="time(int wantedNumberOfInvocations)函数"></a>time(int wantedNumberOfInvocations)函数</h4><p>允许验证调用方法的精确次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verify(mock, times(<span class="number">2</span>)).someMethod(<span class="string">"some arg"</span>);</span><br><span class="line"><span class="comment">//连续调用该方法两次</span></span><br></pre></td></tr></table></figure>
<h4 id="verify-T-mock-函数"><a href="#verify-T-mock-函数" class="headerlink" title="verify(T mock)函数"></a>verify(T mock)函数</h4><p>验证发生的某些行为 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mock).someMethod(<span class="string">"some arg"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="verifyNoMoreInteractions-Object…-mocks-函数"><a href="#verifyNoMoreInteractions-Object…-mocks-函数" class="headerlink" title="verifyNoMoreInteractions(Object… mocks)函数"></a>verifyNoMoreInteractions(Object… mocks)函数</h4><p>检查入参的mocks是否有任何未经验证的交互,你可以在验证你的mocks之后使用这个方法，用以确保你的mocks没有其它地方会被调用.<br>测试柱的调用也被看成是交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mock.doSomething();</span><br><span class="line">mock.doSomethingUnexpected();</span><br><span class="line"><span class="comment">//验证</span></span><br><span class="line">verify(mock).doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为'doSomethingUnexpected()'是未被期望的，所以下面将会失败</span></span><br><span class="line">verifyNoMoreInteractions(mock);</span><br></pre></td></tr></table></figure>
<h3 id="Robolectric"><a href="#Robolectric" class="headerlink" title="Robolectric"></a>Robolectric</h3><p><a href="http://robolectric.org/getting-started/" target="_blank" rel="noopener">Robolectric</a>是为android上的TDD开发而产生的一款第三方测试框架.</p>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>gradle导入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile "org.robolectric:robolectric:3.3.2"</span><br></pre></td></tr></table></figure>
<p>Building with Android Studio</p>
<p>将runconfig的working directory设置成：$MODULE_DIR$，不然会提示资源找不到错误。</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobolectricTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体使用见<a href="http://www.jianshu.com/p/9d988a2f8ff7" target="_blank" rel="noopener">用例</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 ShenYonghe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>