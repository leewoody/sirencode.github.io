<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Diablo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Diablo">
<meta property="og:url" content="https://github.com/sirencode/page/13/index.html">
<meta property="og:site_name" content="Diablo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Diablo">
  
    <link rel="alternative" href="/atom.xml" title="Diablo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ShenYonghe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ShenYonghe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ShenYonghe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-react-native" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/19/react-native/" class="article-date">
  	<time datetime="2016-08-18T16:00:00.000Z" itemprop="datePublished">2016-08-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/19/react-native/">
        react-native android使用入门
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Facebook 在2015.9.15发布了 React Native for Android，把JavaScript 开发技术扩展到了Android平台。React Native 让开发者使用 JavaScript 和 React 编写应用，利用相同的核心代码就可以创建 基于Web，iOS 和 Android 平台的原生应用。</p>
<p>与 WebView 不同，React Native 运行的界面，最终会被解释映射为原生的 View，可以直接使用布局边界或者 Hierarchy Viewer 看出层级（js 文件会打包为一个bundle，位于assets下面，RN引擎会加载并进行解释映射）。</p>
<p>本文将浅析Android React的架构及相关基础知识。</p>
<h4 id="环境搭建（mac）"><a href="#环境搭建（mac）" class="headerlink" title="环境搭建（mac）"></a>环境搭建（mac）</h4><p>1.安装Homebrew (osx的包管理工具):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>2.安装node.js :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R $(whoami) /usr/<span class="built_in">local</span>/share/systemtap</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew link node</span><br></pre></td></tr></table></figure>
<p>3.安装watchman :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install watchman</span><br></pre></td></tr></table></figure>
<p>4.安装flow :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install flow</span><br></pre></td></tr></table></figure>
<p>5.设置npm淘宝镜像: (也可参考<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a>)</p>
<ul>
<li>1 创建 .npmrc 文件(在用户主目录下)</li>
<li>2 加入以下配置信息:<br>registry = <a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a></li>
</ul>
<p>6.安装React-Native :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>7.创建React-Native项目HelloWorld:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  react-native init HelloWorld</span><br></pre></td></tr></table></figure>
<p>8.运行Android应用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> AwesomeProject</span><br><span class="line">$ react-native run-android</span><br></pre></td></tr></table></figure>
<p>9.版本查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ react-native --version</span><br></pre></td></tr></table></figure>
<p>10.真机测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb reverse tcp:8081 tcp:8081（5.0以上）</span><br></pre></td></tr></table></figure>
<p>11.react-native 升级以及版本管理</p>
<p>  npm install</p>
<p>  1 查询react-native的npm包得最新版本:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm info react-native</span><br></pre></td></tr></table></figure>
<p>  2 安装react-native的指定版本(可以是升级或者降级):</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save react-native@0.22.2</span><br></pre></td></tr></table></figure>
<p>  3 更新项目配置:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ react-native upgrade</span><br></pre></td></tr></table></figure>
<p>12.离线调试</p>
<ul>
<li>1 离线文件下载地址:<a href="http://localhost:8081/index.android.bundle?platform=android" target="_blank" rel="noopener">http://localhost:8081/index.android.bundle?platform=android</a></li>
<li>2 将代码拷贝到Android的assets目录的index.android.bundle.js文件下</li>
</ul>
<h4 id="RN实现原理"><a href="#RN实现原理" class="headerlink" title="RN实现原理"></a>RN实现原理</h4><p>RN需要一个JS的运行环境， 在IOS上直接使用内置的javascriptcore， 在Android 则使用webkit.org官方开源的jsc.so。 此外还集成了其他开源组件，如fresco图片组件，okhttp网络组件等。</p>
<p>RN 会把应用的JS代码（包括依赖的framework）编译成一个js文件（一般命名为index.android.bundle),RN的整体框架目标就是为了解释运行这个js 脚本文件，如果是js 扩展的API， 则直接通过bridge调用native方法; 如果是UI界面， 则映射到virtual DOM这个虚拟的JS数据结构中，通过bridge 传递到native ， 然后根据数据属性设置各个对应的真实native的View。 bridge是一种JS 和 JAVA代码通信的机制， 用bridge函数传入对方module 和 method即可得到异步回调的结果。</p>
<p>对于 Android 开发者来说， RN是一个普通的安卓程序加上一堆事件响应， 事件来源主要是JS的命令。主要有二个线程，UI main thread, JS thread。 UI thread创建一个APP的事件循环后，就挂在looper等待事件 , 事件驱动各自的对象执行命令。 JS thread 运行的脚本相当于底层数据采集器， 不断上传数据，转化成UI 事件， 通过bridge转发到UI thread, 从而改变真实的View。 后面再深一层发现， UI main thread 跟 JS thread更像是CS 模型，JS thread更像服务端， UI main thread是客户端， UI main thread 不断询问JS thread并且请求数据，如果数据有变，则更新UI界面。</p>
<h4 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h4><h4 id="js开发者角度"><a href="#js开发者角度" class="headerlink" title="js开发者角度"></a>js开发者角度</h4><p>对于JS开发者来说， 整个RN APP就只有一个JS文件， 而开发者需要编写的有主要是四个部分：</p>
<p>1 require 所有依赖到的组件， 相当于java中的import 或者 c++ 中的include。</p>
<p>2 var AwesomeProject = React.createClass 创建APP， 并且在render函数中返回UI界面结构（采用JSX ), 实际经过编译， 都会变成JS 代码， 比如 变成 React.createElement(View,{style:{flex:1}},</p>
<p>3 var styles = StyleSheet.create({， 创建CSS 样式，实际上会直接当做参数直接反馈到上面的React.createElement</p>
<p>4 AppRegistry.registerComponent(‘AwesomeProject’, () =&gt; AwesomeProject); 以上三个更像是参数，这个才是JS 程序的入口。即把当前APP的对象注册到AppRegistry组件中， AppRegistry组件是js module。<br>接着就等待Native事件驱动渲染JS端定义的APP组件。</p>
<h4 id="android开发者角度"><a href="#android开发者角度" class="headerlink" title="android开发者角度"></a>android开发者角度</h4><p>对于Android 开发者， 普通安卓程序入口是Activity.onCreate()方法 ， 主要有三个对象</p>
<p>1 ReactRootView, Android 标准的FrameLayout对象，另外一个功能是提供react 世界的入口，函数startReactApplication实际调用attachMeasuredRootView触发react世界的初始化。</p>
<p>2 MyReactPackage， 配置当前APP 需要加载的模块，RN 的JS框架会在初始化阶段就会把native的模块按照配置加载到JS数据结构中（MessageQueue), 从而才能在JS 层即可直接判断native是否支持某个模块。支持三种类型模块配置， native module(实际就是不需要操作View结构的API), view managers(实际是映射到virtual DOM中的View组件)， JS module 。</p>
<p>3 ReactInstanceManager， 构建React世界的运行环境，发送事件到JS世界， 驱动整个React世界运转。 通过builder可以创建不同的React环境， 比如内置js 路径， 开发环境dev的js名字，是否支持调试等。doInBackground会加载指定的JS文件, onPostExecute会调用runApplication接口运行JS APP。</p>
<h4 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h4><p>RN框架最主要的就是实现了一套JAVA和 JS通信的方案，该方案可以做到比较简便的互调对方的接口。一般的JS运行环境是直接扩展JS接口，然后JS通过扩展接口发送信息到主线程。但RN的通信的实现机制是单向调用，Native线程定期向JS线程拉取数据， 然后转成JS的调用预期，最后转交给Native对应的调用模块。这样最终同样也可以达到Java和 JS 定义的Module互相调用的目的。</p>
<h4 id="自定义原生模块"><a href="#自定义原生模块" class="headerlink" title="自定义原生模块"></a>自定义原生模块</h4><p>1 首先编写一个自定义模块的类，该类需要继承ReactContextBaseJavaModule, 并需要实现getName()方法返回一个模块名称，在本实例中，该自定义模块将实现Android的Toast功能，所以定义了一个show()方法，并加上了ReactMethod注解，这个注解可以将show(String msg, int duration)中的Java参数类型映射成Js中对应的数据类型，具体映射关系如下:</p>
<pre><code>Boolean -&gt; Bool
Integer -&gt; Number
Double -&gt; Number
Float -&gt; Number
String -&gt; String
Callback -&gt; function
ReadableMap -&gt; Object
ReadableArray -&gt; Array
</code></pre><h4 id="以Toast为例："><a href="#以Toast为例：" class="headerlink" title="以Toast为例："></a>以Toast为例：</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>public class ToastAndroidModule extends    ReactContextBaseJavaModule {

private static final String DURATION_SHORT_KEY = &quot;SHORT&quot;;
private static final String DURATION_LONG_KEY = &quot;LONG&quot;;

public ToastAndroidModule(ReactApplicationContext reactContext) {
    super(reactContext);
}

/**
 * 定义模块名称
 * @return
 */
@Override
public String getName() {
    return &quot;MyToastAndroid&quot;;
}

/**
 * 可以设置一些常量，能够在js层调用，本例中在JS代码中调用如&quot;MyToastAndroid.LONG&quot;
 * @return
 */
@Nullable
@Override
public Map&lt;String, Object&gt; getConstants() {
    final Map&lt;String, Object&gt; constants = new HashMap&lt;&gt;(2);
    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);
    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);
    return constants;
}

/**
 * 自定义方法，通过ReactMethod注解可以把一些Java常量类型映射成js类型
 * @param msg
 * @param duration
 */
@ReactMethod
public void show(String msg, int duration) {
    Toast.makeText(getReactApplicationContext(), msg, duration).show();
}
}
</code></pre><h4 id="注册模块"><a href="#注册模块" class="headerlink" title="注册模块"></a>注册模块</h4><p>在目前0.20版本上，我们自定义原生模块(NativeModule)是需要注册才能生效的，所以编写好模块之后需要重新打包安装到手机上。</p>
<h4 id="编写Package"><a href="#编写Package" class="headerlink" title="编写Package"></a>编写Package</h4><p>注册模块首先可以先写个自定义的Package，顾名思义，就是一个可以包含你自己写的模块的一个包，然后把包在MainActivity(本例中的类)中注册下，通过已有工程引入React组件的可以根据实际情况修改，也不难。<br>本例中新建一个MyPackage类，通过实现ReactPackage的三个接口来完成模块的绑定，其中createNativeModules方法是我们本例需要用到的，其他两个之后再说，要注意三个方法均不能返回null类型，不需要用到的请传入一个空集合！</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code>public class MyPackage implements ReactPackage {
@Override
public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) {
    List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;(1);
    // 将我们自定义模块添加一个集合中，这样React组件就会在合适的时机将我们引用的模块加载进去，这样后面才能愉快地玩耍~
    modules.add(new ToastAndroidModule(reactContext));
    return modules;
}

@Override
public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() {
    //现在不需要用到，不要传null，否则报错
    return Collections.emptyList();
}

@Override
public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) {
    //现在不需要用到，不要传null，否则报错
    return Collections.emptyList();
}
}
</code></pre><h4 id="注册Package"><a href="#注册Package" class="headerlink" title="注册Package"></a>注册Package</h4><p>写好Package之后，就可以愉快将Package加入到MainActivity(本例)类里，方法很简单，直接贴部分源代码</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code>public class MainActivity extends ReactActivity {

/**
 * Returns the name of the main component registered from JavaScript.
 * This is used to schedule rendering of the component.
 */
@Override
protected String getMainComponentName() {
    return &quot;AwesomeProject&quot;;
}

/**
 * Returns whether dev mode should be enabled.
 * This enables e.g. the dev menu.
 */
@Override
protected boolean getUseDeveloperSupport() {
    return BuildConfig.DEBUG;
}

/**
 * A list of packages used by the app. If the app uses additional views
 * or modules besides the default ones, add more packages here.
 */
@Override
protected List&lt;ReactPackage&gt; getPackages() {
    return Arrays.&lt;ReactPackage&gt;asList(
            new MainReactPackage(),
            //加入我们自己写的Package
            new MyPackage()
    );
}
}
</code></pre><h4 id="JS调用"><a href="#JS调用" class="headerlink" title="JS调用"></a>JS调用</h4><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code>import React, {
AppRegistry,
Component,
StyleSheet,
Text,
View,
NativeModules
} from &apos;react-native&apos;;

class AwesomeProject extends Component {
constructor(props) {
    super(props);
}

componentDidMount() {
    var MyToastAndroid = NativeModules.MyToastAndroid;
    MyToastAndroid.show(&apos;This is from MyToastAndroid Native Module&apos;, MyToastAndroid.LONG)
}

render() {
    return (
        &lt;View style={styles.container}&gt;
            &lt;Text&gt;
                NativeModule Test by BogerChan
            &lt;/Text&gt;
        &lt;/View&gt;
    );
}
};
var styles = StyleSheet.create({
container: {
    flex: 1,
    flexDirection: &apos;row&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    backgroundColor: &apos;#F5FCFF&apos;,
},
});
AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; AwesomeProject);
</code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>1 体验 web 开发的便捷，不再需要编译，重新加载一下 js 就行了</li>
<li>2 可以直接使用 Chrome 或者 Nuclide 调试</li>
<li>3 Android / iOS 两端可以共享很大一部分代码（RN 还在进行 Windows, MacOS, Node-webkit 等平台的支持）</li>
<li>4 热更新，JS bundle 下发一下新的就行了（当然也有一定局限性，如果是 hybrid，则 native 的 RN module 部分不能更新）</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>1 前端开发不会原生做不了 React Native（除非你能真只用自带的那些东西），而且理解那些 RN 提供的组件也会很头晕（需要同时了解 Android 和 iOS）。</li>
<li>2 原生开发需要一定成本的学习实践才能掌握 React Native。毕竟 ES6 不像过去的 JS 那么傻瓜式了。</li>
<li>3 React Native 目前仍然处于快速迭代开发的阶段，你永远也不知道下个版本自己升级需要修改多少原来的代码。</li>
<li>4 React Native 的资料较少，尤其是国内的，更尤其是 hybrid 开发的（GitHub 上的开源项目大多是纯 RN 的）。</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>因为bridge,  JS和 JAVA是异步互通，如果实现复杂多API的逻辑，可能会导致部分效率损耗在多线程通信。JS 异步的编程方式多多少少带来一些不便。</li>
<li>因为bridge,  可能某些场景做不到及时响应。比如帧动画的实时控制。</li>
<li>Android版本刚推出不完善，并且目前RN版本还在不停的更新中， 可能存在暗坑。</li>
<li>加入JS引擎， 内存的控制比较麻烦，会比普通native增加不少。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-android 6.0 permission" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/18/android 6.0 permission/" class="article-date">
  	<time datetime="2016-08-17T16:00:00.000Z" itemprop="datePublished">2016-08-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/android 6.0 permission/">
        Android 6.0权限处理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>6.0的改动较大的集中在了权限这一块，和以往不同，最新的权限（高危和特殊）是必须动态的申请才可以使用的，如果不动态申请直接使用会导致程序崩溃掉。
</code></pre><p>现在开源的写的比较好的有以下两个框架：</p>
<p><a href="https://github.com/tbruyelle/RxPermissions">RxPermissions</a>：主要可以实现通过链式的方式调用。</p>
<p><a href="https://github.com/googlesamples/easypermissions">easypermissions</a>:这是google官方的一个例子，考虑的相对全面。</p>
<p>以上两个框架虽然写的都很好，但是在项目的使用中还会遇到很多实质性的问题需要解决，下面我们就根据在项目中的具体使用来分析一下。</p>
<h2 id="6-0权限介绍"><a href="#6-0权限介绍" class="headerlink" title="6.0权限介绍"></a>6.0权限介绍</h2><h3 id="1-一般权限，声明即可使用，无需做特殊处理。"><a href="#1-一般权限，声明即可使用，无需做特殊处理。" class="headerlink" title="1 一般权限，声明即可使用，无需做特殊处理。"></a>1 一般权限，声明即可使用，无需做特殊处理。</h3><p>一般权限的使用和6.0前使用方式相同，在Manifest声明一下即可使用。<br>一般权限列表：</p>
<pre><code>ACCESS_LOCATION_EXTRA_COMMANDS
ACCESS_NETWORK_STATE
ACCESS_NOTIFICATION_POLICY
ACCESS_WIFI_STATE
BLUETOOTH
BLUETOOTH_ADMIN
BROADCAST_STICKY
CHANGE_NETWORK_STATE
CHANGE_WIFI_MULTICAST_STATE
CHANGE_WIFI_STATE
DISABLE_KEYGUARD
EXPAND_STATUS_BAR
GET_PACKAGE_SIZE
INSTALL_SHORTCUT
INTERNET
KILL_BACKGROUND_PROCESSES
MODIFY_AUDIO_SETTINGS
NFC
READ_SYNC_SETTINGS
READ_SYNC_STATS
RECEIVE_BOOT_COMPLETED
REORDER_TASKS
REQUEST_INSTALL_PACKAGES
SET_ALARM
SET_TIME_ZONE
SET_WALLPAPER
SET_WALLPAPER_HINTS
TRANSMIT_IR
UNINSTALL_SHORTCUT
USE_FINGERPRINT
VIBRATE
WAKE_LOCK
WRITE_SYNC_SETTINGS
</code></pre><h3 id="2-危险权限，也成运行时权限，需要动态的在使用时授权，如果未授权直接使用会导致崩溃。"><a href="#2-危险权限，也成运行时权限，需要动态的在使用时授权，如果未授权直接使用会导致崩溃。" class="headerlink" title="2 危险权限，也成运行时权限，需要动态的在使用时授权，如果未授权直接使用会导致崩溃。"></a>2 危险权限，也成运行时权限，需要动态的在使用时授权，如果未授权直接使用会导致崩溃。</h3><p>危险权限，在6.0中又被称之为运行时权限，顾名思义就是要在使用的时候动态的申请相关的权限。</p>
<h4 id="危险权限的使用过程"><a href="#危险权限的使用过程" class="headerlink" title="危险权限的使用过程"></a>危险权限的使用过程</h4><p>首先要在Manifest里面声明。（此处有坑，如果不声明你动态去申请的时候，直接返回失败，我在测试的时候犯过这个错误，排查了好久）</p>
<p>有使用相关权限前先判断当前API是否大于等于6.0，如果大于就走动态授权的流程，不然直接使用相关权限。</p>
<p>如果在6.0以上，去判断对应权限是否已经授权了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED</span><br></pre></td></tr></table></figure>
<p>如果未授权，先去走授权的流程</p>
<p>判断未授权的权限是否被勾选为不在提示，一旦相关权限被拒绝一次，下一次再弹出授权的窗口时就会带上不再提示的复选框，这个是系统级别的无法修改，而用户要是勾选了不再提示的按钮，下次我们再发起动态权限申请流程，就不会弹出提示框授权。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.shouldShowRequestPermissionRationale(permission)</span><br></pre></td></tr></table></figure>
<p>如果被勾选了不再提示，我们就要跳到对应APP的详细信息页面，去叫用户手动的授权。</p>
<p>如果只是单纯的未授权但是没有勾选不再提示的权限，那我们就发起权限申请的流程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.requestPermissions(permissions)</span><br></pre></td></tr></table></figure>
<p>之后会通过activity.onRequestPermissionsResult进行回调处理。</p>
<h4 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h4><pre><code>坑一：
我们这里把危险权限的使用分为两种情况
第一种被称为主动调用：举个例子就像我们点击相机按钮去打开相机这种调用，这种调用是可控的，走授权流程后再点击一下就生效了，也是不叫常用的授权方式。

第二种被称为被动调用：例如初始化的时候要用到deviceId这个参数，而这个参数是需要读取手机状态&quot;危险权限&quot;的，所以就要动态去申请，但是这个参数是在我们的APP初始化的时候要调用的，没有点击事件，我们称这种情况为被动调用。被动调用的缺点就是，我们发起权限后不知道什么时候授权情况如何，之后重新调用相关方法。因此在这种情况的时候就要产品给出合理的选择了，如果未授权相关功能，我们的APP是放弃相关功能而继续运行还是直接强制他授权才能使用（不授权就一直提示，直到授权成功才继续运行）。

坑二：
我们项目中的运行时权限一般分为我们自己写的功能使用到相关权限，还有就是第三方的SDK使用到了运行时权限。自己使用权限的地方我们可以自己去控制什么时候申请权限以及权限申请的使用流程控制。第三方的东西控制起来就相对麻烦的多了，比如数据埋点的友盟talkingdata等的试用地方极多，控制起来就相对麻烦的多了。
我的建议是，将第三方的sdk进行封装使用，这样我们就可以控制对应参数的传入时机以及容错处理了。

坑三：缓存一些读值型的数据，如deviceId。因为这种被动式的授权模式有一个缺点就是当我们的APP切到后台后，用户手动的把权限关掉了的情况下（这用户得有多二逼啊），会崩溃的。因为这些权限是被动权限初始化后就自动使用的。
建议就是读值型的，全局缓存，每次初始化的时候更新，非读值型的，初始化后，每次使用的时候还是要做授权判断。
坑四：
尽量把需要运行是权限的东西放到activity或者fragment里面处理，因为申请授权的流程只能在有UI的情况进行。当然有一些情况必须要在Application里面初始化，因为APP可能通过推送直接跳过这个初始化的activity跳到直接使用的页面。
解决办法就是，授权放到四次启动的ui里面，第一次的初始化也放到这个UI里面处理。然后在application里面判断是否授权，已授权就初始化，未授权做好处理。
</code></pre><h4 id="运行时权限列表"><a href="#运行时权限列表" class="headerlink" title="运行时权限列表"></a>运行时权限列表</h4><pre><code>Permission Group    Permissions

CALENDAR
                    READ_CALENDAR
                    WRITE_CALENDAR
CAMERA
                    CAMERA
CONTACTS
                    READ_CONTACTS
                    WRITE_CONTACTS
                    GET_ACCOUNTS
LOCATION
                    ACCESS_FINE_LOCATION
                    ACCESS_COARSE_LOCATION
MICROPHONE
                    RECORD_AUDIO
PHONE
                    READ_PHONE_STATE
                    CALL_PHONE
                    READ_CALL_LOG
                    WRITE_CALL_LOG
                    ADD_VOICEMAIL
                    USE_SIP
                    PROCESS_OUTGOING_CALLS
SENSORS
                    BODY_SENSORS
SMS
                    SEND_SMS
                    RECEIVE_SMS
                    READ_SMS
                    RECEIVE_WAP_PUSH
                    RECEIVE_MMS
STORAGE
                    READ_EXTERNAL_STORAGE
                    WRITE_EXTERNAL_STORAGE
</code></pre><h3 id="3-特殊权限"><a href="#3-特殊权限" class="headerlink" title="3 特殊权限"></a>3 特殊权限</h3><pre><code>SYSTEM_ALERT_WINDOW，设置悬浮窗，进行一些黑科技
WRITE_SETTINGS 修改系统设置
</code></pre><h4 id="权限使用"><a href="#权限使用" class="headerlink" title="权限使用"></a>权限使用</h4><pre><code>private static final int REQUEST_CODE = 1;
private  void requestAlertWindowPermission() {
Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
intent.setData(Uri.parse(&quot;package:&quot; + getPackageName()));
startActivityForResult(intent, REQUEST_CODE);
}

@Override
 protected void onActivityResult(int requestCode, int resultCode, Intent data) {
super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE) {
    if (Settings.canDrawOverlays(this)) {
      Log.i(LOGTAG, &quot;onActivityResult granted&quot;);
    }
}
}
</code></pre><h3 id="做好缓冲工作"><a href="#做好缓冲工作" class="headerlink" title="做好缓冲工作"></a>做好缓冲工作</h3><p>我们的APP中难免会有一些权限不授权就无法使用的情况，例如我们要读deviceId,但是这个权限所在组是打电话的权限组，也就是会提示要打电话的权限，这样很多用户可能直接就拒绝了。为了避免这种情况发生，我们做一个缓冲，也就是先弹出我们自己定义的比较和谐的提示，同意后在弹出系统生硬的提示，这样一来可以很多程度上避免用户的流失。</p>
<p>###结语<br>适配是一个烦人的过程，会有各种各样的问题，我在这里列出了一些我自己遇到的问题及解决方案，希望对大家有所帮助，另外如果你遇到了一些我没有提到的问题希望帮我补充，大家互相完善，最后希望对你们有所帮助。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-rxjava" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/17/rxjava/" class="article-date">
  	<time datetime="2016-08-16T16:00:00.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/rxjava/">
        RxJava RxAndroid
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="rxjava-原理"><a href="#rxjava-原理" class="headerlink" title="rxjava 原理"></a>rxjava 原理</h3><p>RxJava的一部实现，是通过一种扩展的观察者模式实现的。</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。</p>
<p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<h4 id="观察者模式角色介绍："><a href="#观察者模式角色介绍：" class="headerlink" title="观察者模式角色介绍："></a>观察者模式角色介绍：</h4><ul>
<li>抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</li>
<li>具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</li>
<li>抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</li>
<li>具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</li>
</ul>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。</p>
<ul>
<li>onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的onNext() 发出时，需要触发 onCompleted() 方法作为标志。</li>
<li>onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。</li>
</ul>
<p>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<h4 id="为什么要用rxjava"><a href="#为什么要用rxjava" class="headerlink" title="为什么要用rxjava"></a>为什么要用rxjava</h4><p>首先介绍一下我们在项目里面哪些地方用到了rxjava?</p>
<p>在用到异步处理相关，以及子线程主线程之间数据传递等等。</p>
<p>传统的实现方式较rxjava要复杂的多：</p>
<p>传统方式：</p>
<p>异步处理并回调数据：thread+handler或者AsyncTask等方式，写起来代码量很高也很麻烦。</p>
<p>rxjava方式：</p>
<pre><code>Observable.from(folders)
.flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() {
    @Override
    public Observable&lt;File&gt; call(File file) {
        return Observable.from(file.listFiles());
    }
})
.filter(new Func1&lt;File, Boolean&gt;() {
    @Override
    public Boolean call(File file) {
        return file.getName().endsWith(&quot;.png&quot;);
    }
})
.map(new Func1&lt;File, Bitmap&gt;() {
    @Override
    public Bitmap call(File file) {
        return getBitmapFromFile(file);
    }
})
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Action1&lt;Bitmap&gt;() {
    @Override
    public void call(Bitmap bitmap) {
        imageCollectorView.addImage(bitmap);
    }
});
</code></pre><p> rxjava主要提供链式调用，并按顺序执行，还可以切换每一步所在的线程。<br> 说到底就是因为简单，开发使用简便。原来很复杂的代码几句话就可以搞定了，大大加快了开发速度。</p>
<h3 id="rxjava使用"><a href="#rxjava使用" class="headerlink" title="rxjava使用"></a>rxjava使用</h3><h4 id="1-创建-Observer"><a href="#1-创建-Observer" class="headerlink" title="1 创建 Observer"></a>1 创建 Observer</h4><p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：</p>
<pre><code>Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
@Override
public void onNext(String s) {
    Log.d(tag, &quot;Item: &quot; + s);
}

@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}

@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}
};
</code></pre><p>除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>
<pre><code>Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {
@Override
public void onNext(String s) {
    Log.d(tag, &quot;Item: &quot; + s);
}

@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}

@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}
};
</code></pre><h4 id="2-创建-Observable"><a href="#2-创建-Observable" class="headerlink" title="2 创建 Observable"></a>2 创建 Observable</h4><p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则：</p>
<pre><code>Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
@Override
public void call(Subscriber&lt;? super String&gt; subscriber) {
    subscriber.onNext(&quot;Hello&quot;);
    subscriber.onNext(&quot;Hi&quot;);
    subscriber.onNext(&quot;Aloha&quot;);
    subscriber.onCompleted();
}
});
</code></pre><p>可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<p>create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如：</p>
<ul>
<li><p>just(T…): 将传入的参数依次发送出来。</p>
<pre><code>Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
</code></pre></li>
<li><p>from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</p>
<pre><code>String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};
Observable observable = Observable.from(words);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
</code></pre></li>
</ul>
<h4 id="3-Subscribe-订阅"><a href="#3-Subscribe-订阅" class="headerlink" title="3 Subscribe (订阅)"></a>3 Subscribe (订阅)</h4><p>创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>
<pre><code>observable.subscribe(observer);
// 或者：
observable.subscribe(subscriber);
</code></pre><h3 id="线程控制-——-Scheduler"><a href="#线程控制-——-Scheduler" class="headerlink" title="线程控制 —— Scheduler"></a>线程控制 —— Scheduler</h3><ul>
<li>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>
<li>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>
<li>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li><p>另外， Android 还有一个专用的AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>
<pre><code>Observable.just(1, 2, 3, 4)
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Action1&lt;Integer&gt;() {
@Override
public void call(Integer number) {
    Log.d(tag, &quot;number:&quot; + number);
}
});
</code></pre></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-build_blog" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/17/build_blog/" class="article-date">
  	<time datetime="2016-08-16T16:00:00.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/build_blog/">
        Mac上 Github 博客搭建
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文章来自[他人博客]（<a href="http://www.jianshu.com/p/13e64c9e2295）" target="_blank" rel="noopener">http://www.jianshu.com/p/13e64c9e2295）</a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="1-安装-node"><a href="#1-安装-node" class="headerlink" title="1 安装 node"></a>1 安装 node</h3><p>用来生成静态页面。移步<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>，下载v5.5.0 Stable 一路安装即可。</p>
<h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2 安装 Git"></a>2 安装 Git</h3><p>作用：把本地的hexo内容提交到github上去. </p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Git</a></p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>当Node.js和Git都安装好后就可以正式安装Hexo了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令  -g:全局安装)</p>
<pre><code>注意坑一：[Hexo官网](https://hexo.io/docs)上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。
</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>终端cd到一个你选定的目录，执行hexo init命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure>
<p>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>执行如下命令，开启hexo服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>此时，浏览器中打开网址<a href="http://localhost:4000查看本地效果" target="_blank" rel="noopener">http://localhost:4000查看本地效果</a></p>
<p>本地设置好后，接下来开始关联Github。</p>
<h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1 创建仓库"></a>1 创建仓库</h3><p>登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如sirencode</p>
<p>本地的blog文件夹下内容为：</p>
<pre><code>_config.yml  
db.json 
node_modules 
package.json
scaffolds
source
themes
</code></pre><p>终端cd到blog文件夹下，vim打开_config.yml，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure>
<p>打开后往下滑到最后，修改成下边的样子：</p>
<pre><code>deploy:
  type: git
  repository: https://github.com/sirencode/sirencode.github.io.git
  branch: master
</code></pre><p>你需要将repository后sirencode换成你自己的用户名hexo 3.1.1版本后type:值为git。</p>
<pre><code>注意坑二：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记
</code></pre><p>在blog文件夹目录下执行生成静态页面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate        或者：hexo g</span><br></pre></td></tr></table></figure>
<pre><code>此时若出现如下报错：
ERROR Local hexo not found in ~/blog
ERROR Try runing: &apos;npm install hexo --save&apos;
则执行命令：
npm install hexo --save
若无报错，自行忽略此步骤。
</code></pre><p>再执行配置命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy            或者：hexo d</span><br></pre></td></tr></table></figure>
<pre><code>注意坑三：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：
 $ npm install hexo-deployer-git --save
</code></pre><p> 再次执行hexo generate和hexo deploy命令。</p>
<p> 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p>
<pre><code>Username for &apos;https://github.com&apos;:
Password for &apos;https://github.com&apos;:
</code></pre><p>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://sirencode.github.io（将sirencode换成你的用户名）能看到和打开http://localhost:4000时一样的页面。" target="_blank" rel="noopener">http://sirencode.github.io（将sirencode换成你的用户名）能看到和打开http://localhost:4000时一样的页面。</a></p>
<p>为避免每次输入Github用户名和密码的麻烦，添加ssh key到Github</p>
<p>####1 检查SSH keys是否存在Github<br>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>
<p>####2 生成新的ssh key<br>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure>
<p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p>
<p>####3 将ssh key添加到Github中<br>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>
<p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>
<p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p>
<h3 id="2-发布文章"><a href="#2-发布文章" class="headerlink" title="2 发布文章"></a>2 发布文章</h3><p>终端cd到blog文件夹下，执行如下命令新建文章：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span></span><br></pre></td></tr></table></figure>
<p>名为postName.md的文件会建在目录/blog/source/_posts下。你当然可以用vim来编辑文章。我在用Mou编辑器，支持预览，虽然其预览主题并非我喜欢，如果你有好用的markdown编辑器请推荐给我，感激不尽！</p>
<p>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate             //生成静态页面</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy            //将文章部署到Github</span><br></pre></td></tr></table></figure>
<p>文章的发布环节已经完成，就是编辑，（clean）generate,deploy循环。</p>
<h3 id="3-安装Theme博客模板"><a href="#3-安装Theme博客模板" class="headerlink" title="3 安装Theme博客模板"></a>3 安装Theme博客模板</h3><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题页</a>去搜寻自己喜欢的theme。这里以<a href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next</a>为例</p>
<p>终端cd到 blog 目录下执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>将blog目录下_config.yml里theme的名称landscape修改为next</p>
<p>终端cd到blog目录下执行如下命令(每次部署文章的步骤)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean     //清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g             //生成缓存和静态文件</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d             //重新部署到服务器</span><br></pre></td></tr></table></figure>
<p>至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 使用文档里有极详细的介绍。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-binder" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/06/binder/" class="article-date">
  	<time datetime="2016-07-05T16:00:00.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/binder/">
        Binder 进程间通信
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Binder是一种进程间通信机制。在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了。</p>
<p>关系图：</p>
<p><img src="http://img.my.csdn.net/uploads/201107/19/0_13110996490rZN.gif" alt="ipc"></p>
<h3 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h3><ol>
<li><p>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中</p>
</li>
<li><p>Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</p>
</li>
<li><p>Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信</p>
</li>
<li><p>Client和Server之间的进程间通信通过Binder驱动程序间接实现</p>
</li>
<li><p>Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力</p>
</li>
</ol>
<h4 id="Service-Manager"><a href="#Service-Manager" class="headerlink" title="Service Manager"></a>Service Manager</h4><p>Service Manager是成为Android进程间通信（IPC）机制Binder守护进程的过程是这样的：</p>
<ul>
<li><ol>
<li>打开/dev/binder文件：open(“/dev/binder”, O_RDWR);</li>
</ol>
</li>
<li><ol>
<li>建立128K内存映射：mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);</li>
</ol>
</li>
<li><ol>
<li>通知Binder驱动程序它是守护进程：binder_become_context_manager(bs);</li>
</ol>
</li>
<li><ol>
<li>进入循环等待请求的到来：binder_loop(bs, svcmgr_handler);</li>
</ol>
</li>
</ul>
<h4 id="client-service-获取service-manager接口"><a href="#client-service-获取service-manager接口" class="headerlink" title="client service 获取service manager接口"></a>client service 获取service manager接口</h4><p>我们知道，Service Manager在Binder机制中既充当守护进程的角色，同时它也充当着Server角色，然而它又与一般的Server不一样。对于普通的Server来说，Client如果想要获得Server的远程接口，那么必须通过Service Manager远程接口提供的getService接口来获得，这本身就是一个使用Binder机制来进行进程间通信的过程。而对于Service Manager这个Server来说，Client如果想要获得Service Manager远程接口，却不必通过进程间通信机制来获得，因为Service Manager远程接口是一个特殊的Binder引用，它的引用句柄一定是0。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-工作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/01/工作/" class="article-date">
  	<time datetime="2016-05-31T16:00:00.000Z" itemprop="datePublished">2016-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/01/工作/">
        工作
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1 UI编写，自定义view,list等等。</p>
<p>2 逻辑编写。</p>
<p>3 多套UI显示逻辑处理，（AB，后端区分）。</p>
<p>4 APP性能优化，启动速度优化，内存检查，代码格式化并review，lint，子线程绘制UI，矢量图使用。</p>
<p>5 通讯，http,socket长连接。</p>
<p>6 MVP,ui模块化（尽量少用fragment）。</p>
<p>7 容错，时刻记住前端要显示的就要有容错处理，一切获取到的资源都是不可靠的。</p>
<p>8 自定义APP框架梳理，网络通信框架，数据解析框架，各种UI（轮播，引导页等），数据加载框架数据列表相关，异步图片缓存处理框架，事件总线，本地数据存储方式选择，webview相关使用，app跨进程通信处理，链式编程Rxjava,表格处理相关，直播sdk,客服SDK，环境切换,便以相关，自动升级工具，自定义log，数据采集，APP性能分析，AB测试，灰度。APP开发中的架构调整，哪里用ctivity哪里用fragment，mvp在哪里使用，目录结构，项目层次等等。</p>
<p>9 加速编译-freeline</p>
<p>10 coding Dojo - 代码道场</p>
<p>11 辅助功能实现自动化操作</p>
<p>12 TDD </p>
<p>13 Espresso 自动化测试</p>
<p>14 scrummaster，敏捷特训</p>
<ul>
<li>有问题，会议讨论一定要记录澄清(凡是留记录)。</li>
<li>关于业务价值要有数学家思维，先去搞，结论看市场反馈。</li>
<li>planmeeting 问题讨论时，将问题分成三个方面讨论，解决问题的业务方案-产品说了算，具体的技术实现-开发说了算，可行性问题-市场测试决定。</li>
<li>PM决定产品走向，市场方向问题，不要将精力过多放到产品本身的讨论上来。</li>
<li>理想团队人数7(+-)2,5-9人.(前提大家都是全栈开发)</li>
<li>早会不是形式，是用来解决问题的，没问题不需要参加。</li>
<li>接口的设计是由使用者决定的，一般前端决定。</li>
<li>版本回收，做好强制升级，不能一直兼容很老的版本。</li>
<li>产品前期不要将一些极端化的问题讨论进来，这样需求会一直讨论个没完没了，等问题出现再去解决。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-搜索技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/01/搜索技巧/" class="article-date">
  	<time datetime="2016-05-31T16:00:00.000Z" itemprop="datePublished">2016-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/01/搜索技巧/">
        搜索技巧
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络允许请用google"><a href="#网络允许请用google" class="headerlink" title="网络允许请用google"></a>网络允许请用google</h4><h4 id="精确搜索"><a href="#精确搜索" class="headerlink" title="精确搜索"></a>精确搜索</h4><p>如果你明确想搜某一名词，而不想包含诸如“程先生”、“小卖部”、“先生”、“卖部”等零散的关键字命中结果，就把你的搜索关键字用引号括起来。”程先生的小卖部”</p>
<h4 id="内容筛选"><a href="#内容筛选" class="headerlink" title="内容筛选"></a>内容筛选</h4><p>如果你想搜索包含关键字A，但不包含关键字B的内容，例如，搜索包含张柏芝但不包含陈冠希的网页，就这么设定搜索关键词：张柏芝 -陈冠希，也即“A -B”，A与-之间需要有空格。</p>
<h4 id="指定格式"><a href="#指定格式" class="headerlink" title="指定格式"></a>指定格式</h4><p>如果你想搜诸如txt、pdf、mobi、mp3等特定格式的内容，不要只再“认真的雪 mp3”了，这么搜结果更惊艳：“认真的雪 filetype:mp3”，filetype即是用来指定特定的文件格式。</p>
<h4 id="限定网站"><a href="#限定网站" class="headerlink" title="限定网站"></a>限定网站</h4><p>如果你想在某个网站搜索内容，但可悲的是那个网站不提供搜索功能，那么你要做的不是跺脚或者挠头，而是在关键字后面加上“site:xxx.xxx.com”，site即是用来指定你所要搜索的站点，可以是一级或者二级域名，注意不要包含 http:// 以及第三个/及之后的路径。<br>搜素技巧 site:jianshu.com。</p>
<h4 id="inurl：在指定url中搜索内容"><a href="#inurl：在指定url中搜索内容" class="headerlink" title="inurl：在指定url中搜索内容"></a>inurl：在指定url中搜索内容</h4><p>这个和上面的「site」有点像。不过「site」是需要指定网站的完整网址，而「inurl」只需要指定网址的一部分就行了。</p>
<p>格式如下：<br>yy inurl:xx<br>含义：在包含xx的url中搜索内容yy。其中，xx可以是中文。</p>
<h4 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h4><p>通配符 <em> ？，</em>表示 不限制字符匹配数量， ？表示匹配单个字符，二者适用于模糊搜索</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 ShenYonghe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>