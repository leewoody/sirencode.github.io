<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Diablo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Diablo">
<meta property="og:url" content="https://github.com/sirencode/index.html">
<meta property="og:site_name" content="Diablo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Diablo">
  
    <link rel="alternative" href="/atom.xml" title="Diablo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ShenYonghe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ShenYonghe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ShenYonghe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-android 模块化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/07/android 模块化/" class="article-date">
  	<time datetime="2018-09-06T16:00:00.000Z" itemprop="datePublished">2018-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/07/android 模块化/">
        Android 模块化
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-模块化"><a href="#Android-模块化" class="headerlink" title="Android 模块化"></a>Android 模块化</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>将功能相对独立的模块从主项目中解耦出来，方便独立打包，降低全量编译的时间。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="新建独立模块-MY"><a href="#新建独立模块-MY" class="headerlink" title="新建独立模块(MY)"></a>新建独立模块(MY)</h3><ul>
<li>1 将MY相关的功能所有代码抽离到该模块。</li>
<li>2 资源和源码的转移</li>
<li>3 替换主项目的依赖</li>
<li>4 回归所有功能</li>
<li><p>5 删除原项目中的对应代码</p>
</li>
<li><p>注意：从主项目转移到对应模块的时候可能会涉及一些修改，包括butterknife替换，以及资源从常量变为变量的一些处理。</p>
</li>
</ul>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>解耦的主要问题在于在子module有些必不可免的去访问主项目的一些方法。解法：</p>
<ul>
<li>1 第一种就是将公共的代码抽离到公共的以来模块(可能设计到很多文件的替换)</li>
<li>2 第二种就是做一个<a href="https://sirencode.github.io/2018/02/26/%E5%AD%90%E6%A8%A1%E5%9D%97%E8%AE%BF%E9%97%AEapp%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">bridge</a>去动态的获取主项目的一些方法。</li>
</ul>
<p>两种方法各有利弊，第一种的好处再去可以在独立模块中独立运行不需要依赖主项目或其他模块的功能。而第二种方法是相对改动较少，但依赖于其他模块或者主项目的代码。</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ul>
<li>1 少用butterknife和databinding，在资源的转移的时候容易出错。</li>
<li>2 资源转移的时候记得重命名，防止冲突。</li>
<li>3 有些公共的数据集必去抽离到公共的依赖，不然会出现，数据类型不匹配的情况。</li>
<li>4 跨模块ARouter的时候注意group问题。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-LiveDataBus" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/22/LiveDataBus/" class="article-date">
  	<time datetime="2018-08-21T16:00:00.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/22/LiveDataBus/">
        LiveDataBus
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="LiveDataBus"><a href="#LiveDataBus" class="headerlink" title="LiveDataBus"></a>LiveDataBus</h1><h2 id="Android-Architecture-Components"><a href="#Android-Architecture-Components" class="headerlink" title="Android Architecture Components"></a>Android Architecture Components</h2><p>Android Architecture Components是谷歌在Google I/O 2017发布一套帮助开发者解决Android架构设计的方案。里面包含了两大块内容：</p>
<ol>
<li>生命周期相关的Lifecycle-aware Components</li>
<li>数据库解决方案Room</li>
</ol>
<p>这是一个帮助构建稳定，易于测试和易于维护的App架构的库。</p>
<h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p>Lifecycle 是一个类，它持有关于组件（如 Activity 或 Fragment）生命周期状态的信息，并且允许其他对象观察此状态。</p>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>LiveData是一种持有可被观察数据的类。和其他可被观察的类不同的是，LiveData是有生命周期感知能力的，这意味着它可以在activities, fragments, 或者 services生命周期是活跃状态时更新这些组件。</p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel设计的目的就是存放和处理和UI相关的数据，并且这些数据不受配置变化（Configuration Changes，例如：旋转屏幕，组件被系统回收）的影响。</p>
<h3 id="room"><a href="#room" class="headerlink" title="room"></a>room</h3><p>Room在SQLite上提供了一个方便访问的抽象层。</p>
<h3 id="Paging-Library"><a href="#Paging-Library" class="headerlink" title="Paging Library"></a>Paging Library</h3><p>Paging Library（分页加载库）用于逐步从数据源加载信息，而不会耗费过多的设备资源或者等待太长的时间。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>基于Livedata的实现的主要原因就是Livedata是生命周期感知的，不需要手动管理，又避免了内存泄露以及UI显示的问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android 控件系统" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/23/Android 控件系统/" class="article-date">
  	<time datetime="2018-07-22T16:00:00.000Z" itemprop="datePublished">2018-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/Android 控件系统/">
        Android 控件系统
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-控件系统"><a href="#Android-控件系统" class="headerlink" title="Android 控件系统"></a>Android 控件系统</h1><p>Android中的UI组成的一个Activity中包含了多个window,一个window包含多个View。</p>
<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>分类:</p>
<ul>
<li>应用层Window：activity-&gt;PhoneWindow 1 - 99</li>
<li>子Window：Dialog、PopupWindow 1000-1999</li>
<li>系统Window：Toast、System Alert SystemWindow 2000 - 2999</li>
</ul>
<h2 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h2><p>简单的说Surface对应了一块屏幕缓冲区，每个window对应一个Surface，任何View都要画在Surface的Canvas上。但是由于SurfaceView的特殊绘制的机制，SurfaceView也拥有独立的Surface，并在对应的window上留出一块透明区域，Surface的z-order为负数。</p>
<h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>WM主要的功能就是提供简单的API使得使用者可以方便地将一个控件作为一个窗口添加到系统中。</p>
<h3 id="WM继承VM类似ViewGroup"><a href="#WM继承VM类似ViewGroup" class="headerlink" title="WM继承VM类似ViewGroup"></a>WM继承VM类似ViewGroup</h3><p>ViewManager定义了三个函数，分别用于添加、删除一个控件，以及更新控件的布局。ViewGrop也实现了ViewManager，VG管理的是子view而WM管理的是子窗口。</p>
<p>WM新增了两个新接口：getDefaultDisplay()得知这个WM的实例会将窗口添加到哪个屏幕上。removeViewImmediate()要求WM必须在这个调用返回前完成所有销毁工作。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="1-初始化WM"><a href="#1-初始化WM" class="headerlink" title="1 初始化WM"></a>1 初始化WM</h4><p>WindowManagerImpl：WM的实现者，保存mDisplay和mParentWidnow两个成员变量，具体的WM接口实现交由WindowManagerGlobal完成。</p>
<p>WindowManagerGlobal：进程单例</p>
<p>Context.getSystemService()-&gt;获取Display对象(如果Context没保存就取系统主屏幕对应的Display)-&gt;使用Display作为参数构造一个WindowManagerImpl对象并返回</p>
<h4 id="2-初始化WMI"><a href="#2-初始化WMI" class="headerlink" title="2 初始化WMI"></a>2 初始化WMI</h4><p>在WMI初始化的时候，初始化了mDisplay和mParentWidnow两个成员变量</p>
<h4 id="3-WMG添加窗口"><a href="#3-WMG添加窗口" class="headerlink" title="3 WMG添加窗口"></a>3 WMG添加窗口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// 1 如果当前窗口需要被添加为另一个窗口的附属矿口(子窗口)，则需要让父窗口视自己的情况对当前窗口的布局参数进行一些修改</span></span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                        + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is a panel window, then find the window it is being</span></span><br><span class="line">        <span class="comment">// attached to for future reference.</span></span><br><span class="line">        <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                    panelParentView = mViews.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 创建一个ViewRootImpl对象并保存在root</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">// 3 将作为窗口的控件，布局参数以及新建的ViewRootImpl以相同的索引值保存在三个数组中</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4 将作为窗口的控件设置给ViewRootImpl。这个动作将导致ViewRootImpl向WMS添加新的窗口，申请surface以及托管控件surface上的重绘动作。</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-20%20%E4%B8%8B%E5%8D%881.39.53.png" alt=""></p>
<ul>
<li>1 父窗口修改新窗口的布局参数。LayoutParams.token和LayoutParams.mTitle.</li>
<li>2 为新窗口创建一个ViewRootImpl对象。负责与WMS直接通信，负责管理Surface,触发控件的测量与布局和绘制，同时也是输入事件的中转站。</li>
<li>3 控件，布局参数与ViewRootImpl三者共同组成了一个窗口。</li>
<li>4 ViewRootImpl.setView(),将view托管给ViewRootImpl。</li>
</ul>
<h4 id="4-更新窗口布局"><a href="#4-更新窗口布局" class="headerlink" title="4 更新窗口布局"></a>4 更新窗口布局</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 获取窗口的三个索引</span></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        ViewRootImpl root = mRoots.get(index);</span><br><span class="line">        <span class="comment">// 更新布局参数</span></span><br><span class="line">        mParams.remove(index);</span><br><span class="line">        mParams.add(index, wparams);</span><br><span class="line">        <span class="comment">// 刷新布局</span></span><br><span class="line">        root.setLayoutParams(wparams, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-删除窗口"><a href="#5-删除窗口" class="headerlink" title="5 删除窗口"></a>5 删除窗口</h4><ul>
<li>1 删除三个数组中对应的元素。</li>
<li>2 要求ViewRootImpl从WMS中删除对应的窗口，并释放一切需要回收的资源。</li>
</ul>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><p>ViewRootImpl实现了ViewParent接口，作为整个控件树根部，控制整个控件树的测量布局绘制，以及输入事件的派发。</p>
<h3 id="1-ViewRootImpl的创建及其重要成员"><a href="#1-ViewRootImpl的创建及其重要成员" class="headerlink" title="1 ViewRootImpl的创建及其重要成员"></a>1 ViewRootImpl的创建及其重要成员</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">//1 从WindowManagerGlobal中获取一个IWindowSession的实例。它是ViewRoot和WMS进行通信的代理</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    <span class="comment">//2 保存参数display，在后面setView()调用中将会把窗口添加到这个Display上</span></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    mBasePackageName = context.getBasePackageName();</span><br><span class="line">    <span class="comment">//3 保存当前线程到mThread，这个赋值操作体现了创建ViewRootImpl的线程如何成为UI主线程。在ViewRootImp处理来自控件树的请求时，会检查发起请求的thread与这个mThread是否相同。倘若不同则会拒绝这个请求并抛出一个异常。</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">    mLocation = <span class="keyword">new</span> WindowLeaked(<span class="keyword">null</span>);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line">    mWidth = -<span class="number">1</span>;</span><br><span class="line">    mHeight = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//4 mDirty用于收集窗口中的无效(需要重绘的)区域。</span></span><br><span class="line">    mDirty = <span class="keyword">new</span> Rect();</span><br><span class="line">    mTempRect = <span class="keyword">new</span> Rect();</span><br><span class="line">    mVisRect = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="comment">//5 mWinFrame描述了当前窗口的位置和尺寸。</span></span><br><span class="line">    mWinFrame = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="comment">//6 创建一个W类型的实例，W是IWindow.Stub的子类。</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">    mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line">    mViewVisibility = View.GONE;</span><br><span class="line">    mTransparentRegion = <span class="keyword">new</span> Region();</span><br><span class="line">    mPreviousTransparentRegion = <span class="keyword">new</span> Region();</span><br><span class="line">    mFirst = <span class="keyword">true</span>; <span class="comment">// true for the first time the view is added</span></span><br><span class="line">    mAdded = <span class="keyword">false</span>;</span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>,</span><br><span class="line">            context);</span><br><span class="line">    mAccessibilityManager = AccessibilityManager.getInstance(context);</span><br><span class="line">    mAccessibilityManager.addAccessibilityStateChangeListener(</span><br><span class="line">            mAccessibilityInteractionConnectionManager, mHandler);</span><br><span class="line">    mHighContrastTextManager = <span class="keyword">new</span> HighContrastTextManager();</span><br><span class="line">    mAccessibilityManager.addHighTextContrastStateChangeListener(</span><br><span class="line">            mHighContrastTextManager, mHandler);</span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line">    mDensity = context.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">    mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi;</span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line">    <span class="comment">// VSYNC特性安排重绘行为</span></span><br><span class="line">    mChoreographer = Choreographer.getInstance();</span><br><span class="line">    mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sCompatibilityDone) &#123;</span><br><span class="line">        sAlwaysAssignFocus = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        sCompatibilityDone = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadSystemProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1 mChoreographer来自VSYNC重绘重绘，mHandler实时性高，将发生在其他线程上的事件安排在主线程上。</li>
</ul>
<h3 id="2-ViewRootImpl-setVeiw"><a href="#2-ViewRootImpl-setVeiw" class="headerlink" title="2 ViewRootImpl.setVeiw()"></a>2 ViewRootImpl.setVeiw()</h3><p>setView()创建了窗口，建立输入事件接收机制的场所。</p>
<h3 id="3-控件系统刷新：performTraversals"><a href="#3-控件系统刷新：performTraversals" class="headerlink" title="3 控件系统刷新：performTraversals()"></a>3 控件系统刷新：performTraversals()</h3><p>ViewRootImpl通过requestLayout()向主线程发送一条触发遍历操作的消息，遍历指:performTraversals方法。ViewRootImpl在接收到WMS窗口变化，来自view的尺寸变化以及重绘申请等重绘请求触发。</p>
<p>performTraversals：</p>
<ul>
<li>1 预测量阶段：此阶段将会计算出控件树为显示其内容所需的尺寸，即期望的窗口尺寸，view及其子类的onMeasure一次调用。</li>
<li>2 布局窗口阶段：根据预测结果，通过向WMS请求调整布局参数并重新布局，将布局结果返回给ViewRootImpl。</li>
<li>3 最终测量阶段：预测量的是期望的尺寸，WMS不一定会将窗口准确地布局所要求的尺寸，view及其子类的onMeasure一次调用。</li>
<li>4 布局控件树阶段：测量确定尺寸，布局确定位置，View及其子类的onLayout被回调。</li>
<li>5 绘制阶段：View及其子类的onDraw方法将会被回调。</li>
</ul>
<p>MeasureSpec：MeasureSpec是复合整型变量，用于指导控件对自身进行测量，它有两个分量，SPEC_MODE，SPEC_SIZE。</p>
<p>SPEC_MODE:</p>
<ul>
<li>1 MeasureSpec.UNSPECIFIED(0)：表示控件在进行测量时，可以无视SPEC_SIZE的值，控件可以是它期望的任何尺寸。</li>
<li>2 MeasureSpec.EXACTLY(1)：表示子控件必须为SPEC_SIZE，当控件宽高为确定值或MATCH_PARENT时，使用这个参数。</li>
<li>3 MeasureSpec.AT_MOST(2)：子控件可以是它期望的尺寸，但不得大于SPEC_SIZE，用于WRAP_CONTENT时。</li>
</ul>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.00.10.png" alt=""></p>
<h2 id="控件树的绘制"><a href="#控件树的绘制" class="headerlink" title="控件树的绘制"></a>控件树的绘制</h2><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas是一个绘图工具类，其API提供了一系列绘图指令。根据绘制加速模式不同分为软件Canvas和硬件Canvas。</p>
<p>绘制指令分类：</p>
<ul>
<li>1 绘制指令，drawXXX()方法。</li>
<li>2 辅助指令，设置变换，裁剪区域。</li>
</ul>
<h4 id="Canvas-的绘制目标"><a href="#Canvas-的绘制目标" class="headerlink" title="Canvas 的绘制目标"></a>Canvas 的绘制目标</h4><p>对于软件Canvas来说，其绘制目标是一个建立在Surface之上的位图Bitmap。<br>Canvas-&gt;bitmap-&gt;添加到surface上的Buffer</p>
<p>硬件canvas目标有两种：</p>
<ul>
<li>1 HardwareLayer,理解为GL Texture(纹理)，或者简单的认为是一个硬件加速的Bitmap。</li>
<li>2 Display,Display是一个指令序列。Display会将Canvas的绘制指令编译并优化为硬件绘制指令，并且可以在需要时将这些指令回放到一个HardwareLayer上，而不需要重新使用Canvas进行绘制。</li>
</ul>
<p>HardwareLayer和Bitmap十分相似，区别在于使用时采用了硬件加速还是软件加速。Display并不像Bitmap存储了绘制的结果，而是存储了绘制过程。</p>
<h3 id="脏区域"><a href="#脏区域" class="headerlink" title="脏区域"></a>脏区域</h3><p>为了保证绘制的效率，控件树仅对需要重绘的区域进行绘制，这部分区域成为”脏区域”即Dirty Area.</p>
<p>当一个控件的内容变化而需要重绘时，它会通知View.invalidate()方法将需要重绘的区域沿着控件树提交给ViewRootImpl，并保存在ViewRootImpl的mDirty成员中，最后通过scheduleTraversals()引发一次遍历，ViewRootImpl会保证仅位于mDirty描述的区域得到重绘。另外，View.invalidate()在回溯到ViewRootImpl的过程中会将沿途的控件标记为脏的。</p>
<h3 id="软件绘制与硬件加速绘制"><a href="#软件绘制与硬件加速绘制" class="headerlink" title="软件绘制与硬件加速绘制"></a>软件绘制与硬件加速绘制</h3><p>控件绘制过程：</p>
<ul>
<li>1 绘制背景</li>
<li>2 绘制控件自身</li>
<li>3 绘制子控件</li>
<li>4 绘制控件的装饰，即滚动条</li>
</ul>
<p>软件绘制流程：</p>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.50.21.png" alt=""></p>
<p>硬件加速绘制与软件绘制在前两步是完全相同的，区别在于第三部，View.draw()的流程上。硬件加速希望在canvas上绘制子控件的DisplayList，而不是直接View.onDraw直接绘制。</p>
<p>硬件加速绘制流程：</p>
<p><img src="http://oc4zuck5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-23%20%E4%B8%8A%E5%8D%8811.55.39.png" alt=""></p>
<p>控件内容不再通过Canvas直接绘制到Surface,而是绘制到DisplayList。同时子控件的DisplayList会被绘制到父控件的DisplayList。最终整个控件树的内容被集合在根控件的DisplayList，并且这个DisplayList通过HardwareCanvas绘制到Surface之上。</p>
<h2 id="绘图缓存"><a href="#绘图缓存" class="headerlink" title="绘图缓存"></a>绘图缓存</h2><p>绘图缓存有两种类型，即软件缓存(bitmap)和硬件缓存(HardwareLayer)。保存了控件及其子控件的一个快照。当控件的父控件需要重绘时，可以考虑将其绘图绘制canvas上。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>1 不要为十分轻量级的控件启用缓存，因为缓存的开销可能大于此控件的重绘开销。</li>
<li>2 为黑哨发生变化的控件启用绘图缓存。</li>
<li>3 当父控件需要频发改变子控件的位置的时候启用缓存。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android 投屏" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/13/Android 投屏/" class="article-date">
  	<time datetime="2018-07-12T16:00:00.000Z" itemprop="datePublished">2018-07-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/13/Android 投屏/">
        Android 投屏
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-投屏"><a href="#Android-投屏" class="headerlink" title="Android 投屏"></a>Android 投屏</h1><h2 id="Vysor"><a href="#Vysor" class="headerlink" title="Vysor"></a>Vysor</h2><p><a href="https://chrome.google.com/webstore/detail/vysorcom/kdphpklacmlhmooodiekhpbepcdlaghl?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">vysor</a></p>
<p>可以通过修改配置文件的形式进行破解，但是破解后投放的影像还是有些模糊，且在一些UI细节上面存在一些瑕疵，比如有些线显示不出来。</p>
<h2 id="Scrcpy"><a href="#Scrcpy" class="headerlink" title="Scrcpy"></a>Scrcpy</h2><p>Scrcpy本身就是免费的，且默认传输速率为8M，最高支持32M,画面相对来说非常清晰。</p>
<h3 id="安装Scrcpy"><a href="#安装Scrcpy" class="headerlink" title="安装Scrcpy"></a>安装Scrcpy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew install scrcpy</span><br><span class="line"><span class="comment"># adb</span></span><br><span class="line">$ brew cask install android-platform-tools</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>启动-scrcpy</li>
<li>scrcpy –help ：Scrcpy 内建的帮助模式，里面也列举了 Scrcpy 的所有的附加命令。</li>
<li>scrcpy -b Xm ：强制提升/下降 Scrcpy 的传输速率，默认速率为 8Mbps，“X” 的值小于 8 表示限制速率，大于 8 表示强制提高传输速率，速率越高代表传输的质量越高。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>部分手机需要在开发者选项里面打开允许「模拟位置点击」</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android 模块化 " class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/06/Android 模块化 /" class="article-date">
  	<time datetime="2018-07-05T16:00:00.000Z" itemprop="datePublished">2018-07-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/06/Android 模块化 /">
        Android 模块化
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-模块化"><a href="#Android-模块化" class="headerlink" title="Android 模块化"></a>Android 模块化</h1><p>背景，当我们的项目的业务随着时间的推移越来越多越来越复杂，有时候只是想测试一下或者修改一下相对简单的功能，也需要等待相对漫长的编译时间，以及各种跳转依赖的处理。为了使相对独立的模块相对快速的开发，我们决定事实模块化，可以单独打包对应的模块。</p>
<h2 id="整体的思路"><a href="#整体的思路" class="headerlink" title="整体的思路"></a>整体的思路</h2><p>主项目全量打包，包含所有的功能以及连贯的前后业务逻辑。实现模块化后的独立模块可以实现单独打包开发对应的功能。</p>
<h2 id="模块化的流程"><a href="#模块化的流程" class="headerlink" title="模块化的流程"></a>模块化的流程</h2><p>首先模块化的目的确定了，在模块化的过程中的原则就是尽量不要修改主项目的代码。首先将模块的代码从主项目中抽离出来，并进行全功能测试以及主项目的集成测试，最后删除主项目中移除的对应的代码。</p>
<h3 id="第一步新建独立模块的app引导"><a href="#第一步新建独立模块的app引导" class="headerlink" title="第一步新建独立模块的app引导"></a>第一步新建独立模块的app引导</h3><p>MyModuleAPP模块：我的模块的引导程序。</p>
<p>new- &gt;android lib -&gt; build配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(myAsApp.toBoolean()) &#123;</span><br><span class="line">    apply plugin: 'com.android.application'</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    apply plugin: 'com.android.library'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置全局的myAsApp变量控制MyModuleAPP是作为lib还是app编译：</p>
<p>gradle.properties:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myAsApp=true</span><br></pre></td></tr></table></figure>
<h3 id="将主项目中的所有“MY”相关的代码抽离到独立的模块NMyModule"><a href="#将主项目中的所有“MY”相关的代码抽离到独立的模块NMyModule" class="headerlink" title="将主项目中的所有“MY”相关的代码抽离到独立的模块NMyModule"></a>将主项目中的所有“MY”相关的代码抽离到独立的模块NMyModule</h3><p>注意：</p>
<ul>
<li>1 在抽离相关代码的时候记得重命名抽离的资源文件，防止主项目依赖的时候资源冲突。</li>
<li>2 尽量少使用butterknife,因为在lib依赖的时候会有很多bug。</li>
<li>3 当将代码从app抽离出到lib，资源会从常量变为变量。</li>
</ul>
<h3 id="公共代码抽离"><a href="#公共代码抽离" class="headerlink" title="公共代码抽离"></a>公共代码抽离</h3><ul>
<li>1 登录相关的代码抽离出来供所有独立模块使用。</li>
<li>2 api相关抽离。</li>
<li>3 公共库依赖。</li>
</ul>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><ul>
<li>1 配置文件放到公共库。</li>
<li>2 lib访问app数据的时候时候使用<a href="https://sirencode.github.io/2018/02/26/%E5%AD%90%E6%A8%A1%E5%9D%97%E8%AE%BF%E9%97%AEapp%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">bridge</a></li>
<li>3 lib跳转app使用apt路由ARouter。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-dir505 科学上网" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/16/dir505 科学上网/" class="article-date">
  	<time datetime="2018-06-15T16:00:00.000Z" itemprop="datePublished">2018-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/16/dir505 科学上网/">
        dir505 科学上网
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="dir505-科学上网"><a href="#dir505-科学上网" class="headerlink" title="dir505 科学上网"></a>dir505 科学上网</h1><h2 id="dir505-升级国际版固件"><a href="#dir505-升级国际版固件" class="headerlink" title="dir505 升级国际版固件"></a>dir505 升级国际版固件</h2><p><a href="http://support.dlink.com.au/download/download.aspx?product=DIR-505" target="_blank" rel="noopener">国际版固件地址</a></p>
<p>利用16进制编辑器将‘DEF’替换为‘CN’,之后通过路由器的固件升级升级固件。</p>
<h2 id="刷openwrt"><a href="#刷openwrt" class="headerlink" title="刷openwrt"></a>刷openwrt</h2><p><a href="https://archive.openwrt.org/releases/" target="_blank" rel="noopener">openwrt</a> 之后找到dir-505的固件下载(包含factory的那个),通过固件升级的方式刷。</p>
<h2 id="配置openwrt"><a href="#配置openwrt" class="headerlink" title="配置openwrt"></a>配置openwrt</h2><ul>
<li><p>注意安装完openwrt在WiFi中将找不到对应的路由信号，这是因为openwrt默认没有开启无线功能，这时候不要慌，网线连接电脑进行配置即可。</p>
</li>
<li><p>1 首先向电脑的本地网卡设置为固定ip:192.168.1.x,子网掩码：255.255.0.0</p>
</li>
<li>2 telnet 192.168.1.1</li>
<li>3 设置root密码</li>
<li>4 mac ssh win putty 192.168.1.1</li>
</ul>
<h3 id="开启wifi"><a href="#开启wifi" class="headerlink" title="开启wifi"></a>开启wifi</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uci set wireless.@wifi-device[0].disabled=0</span><br><span class="line">uci set wireless.@wifi-iface[0].ssid='wifiname'</span><br><span class="line">uci set wireless.@wifi-iface[0].encryption='psk2'</span><br><span class="line">uci set wireless.@wifi-iface[0].key='password'</span><br><span class="line">uci commit wireless</span><br></pre></td></tr></table></figure>
<h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uci set system.@system[0].zonename='Asia/Shanghai'</span><br><span class="line">uci set system.@system[0].timezone='CST-8'</span><br><span class="line">uci commit system</span><br></pre></td></tr></table></figure>
<h3 id="中继路由设置"><a href="#中继路由设置" class="headerlink" title="中继路由设置"></a>中继路由设置</h3><p>如果你需要将你的路由作为二级路由使用请设置中继192.168.0.x，因为192.168.1.1已经被一级路由占用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uci delete network.lan.ifname</span><br><span class="line">uci delete network.lan.type</span><br><span class="line">uci add network interface</span><br><span class="line">uci rename network.@interface[-1]='wan'</span><br><span class="line">uci set network.@interface[-1].ifname='eth1'</span><br><span class="line">uci set network.wan.proto=static</span><br><span class="line">uci set network.wan.ipaddr=192.168.1.123</span><br><span class="line">uci set network.wan.netmask=255.255.255.0</span><br><span class="line">uci set network.wan.gateway=192.168.1.1</span><br><span class="line">uci set network.wan.dns='114.114.114.114 114.114.115.115'</span><br><span class="line">uci set network.lan.ipaddr=192.168.0.1</span><br><span class="line">uci set network.lan.dns='114.114.114.114 114.114.115.115'</span><br><span class="line">uci commit network</span><br></pre></td></tr></table></figure>
<h3 id="重启network"><a href="#重启network" class="headerlink" title="重启network"></a>重启network</h3><p>/etc/init.d/network restart</p>
<h2 id="安装ss"><a href="#安装ss" class="headerlink" title="安装ss"></a>安装ss</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">//中文后台</span><br><span class="line">opkg install install luci-i18n-base-zh-cn</span><br><span class="line">opkg install luci-app-shadowsocks-libev</span><br><span class="line">opkg install luci-i18n-shadowsocks-libev-zh-cn</span><br><span class="line">opkg install shadowsocks-libev</span><br></pre></td></tr></table></figure>
<p>注意安装顺序：最后安装shadowsocks-libev,安装完这个就默认设置一个本地代理导致网络无法访问了。</p>
<h2 id="刷成砖恢复"><a href="#刷成砖恢复" class="headerlink" title="刷成砖恢复"></a>刷成砖恢复</h2><p>dir-505号称刷不坏的神机：</p>
<p>恢复模式设置：</p>
<ul>
<li>1 将电脑的本地网卡设置为固定IP：192.168.0.x 子网掩码:255.255.0.0</li>
<li>2 断电情况按住路由的reset之后通电等到红灯闪烁松开reset</li>
<li>3 电脑打开192.168.1.1便可上传固件了</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android 输入系统" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/11/Android 输入系统/" class="article-date">
  	<time datetime="2018-06-10T16:00:00.000Z" itemprop="datePublished">2018-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/11/Android 输入系统/">
        Android 输入系统
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-输入系统"><a href="#Android-输入系统" class="headerlink" title="Android 输入系统"></a>Android 输入系统</h1><h2 id="输入系统的框架"><a href="#输入系统的框架" class="headerlink" title="输入系统的框架"></a>输入系统的框架</h2><p><img src="http://oc4zuck5v.bkt.clouddn.com/android_input.png" alt=""></p>
<ul>
<li>Linux内核-接受输入设备的中断，并将原始事件的数据写入设备节点中。</li>
<li>设备节点，作为内核与IMS的桥梁，它将原始事件的数据暴露给用户空间，以便IMS可以从中读取事件。</li>
<li>IMS,一个Android系统服务，它分为Java层和native层两部分。java层负责与WMS通信，而native层则是InputReader和InputDispatcher两个输入系统关键组件的运行容器。</li>
<li>EventHub,直接访问所有设备节点。通过getEvents()的函数将所有输入系统相关的待处理的底层事件返回给使用者。包括设备节点的增删。</li>
<li>InputReader，它运行于一个独立的线程中，负责管理输入设备的列表于配置，以及进行输入事件的加工处理。它通过其他线程循环不断地通过getEvents函数从EventHub中将事件取出并进行处理。对于设备节点的增删事件，它会更新输入设备列表与配置。对于原始输入事件，InputReader对其进行翻译，组装，封装为包含更多信息，更具可读性的输入事件，然后交给InputDispatcher进行派发。</li>
<li>InputReaderPolicy,它为InputReader的事件加工处理提供一些策略配置，例如键盘布局信息等。</li>
<li>InputDispatcher，它运行于独立线程中，InputDispatcher中保管了来自WMS的所有窗口的信息，其收到来自InputReader的输入事件后，会在其保管的窗口中寻找合适的窗口，并将事件派发给他们。</li>
<li>InputDispatcherPolicy，它为InputDispatcher的派发过程提供策略控制。例如截取某些特定的输入事件用作特殊用途，或者阻止将某些事件派发给目标窗口。一个典型的例子就是Home键被InputDispatcherPolicy截取到PhoneWindowManager中进行处理，并阻止窗口收到Home键的事件。</li>
<li>WMS, 当新建窗口时，WMS为新窗口和IMS创建了事件传递所用的通道。另外WMS还将所有窗口的信息，包括窗口的可点击区域，焦点窗口等信息，实时的更新到IMS的InputDispatcher中，使得InputDispatcher可以正确地将事件派发到指定窗口。</li>
<li>ViewRootImpl，对某些窗口，如壁纸窗口，surfaceview窗口来说，窗口就是输入事件派发的终点。而对其他activity，对话框等使用了Android控件系统的窗口来说，输入事件的终点是view。ViewRootImpl将窗口所接收的输入事件沿着控件数将事件派发给感兴趣的控件。</li>
</ul>
<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>输入设备和输入事件</p>
<p>输入设备：触摸屏，键盘以及外接设备。当输入设备可用的时，Linux就会在/dev/input/ 下创建对应的名为event0~n，当输入设备不可用时，则会将对应的节点删除。用户空间可以通过ioctl的方式从这些设备节点中获取其对应的输入涉笔的类型，厂商，描述等信息。</p>
<h4 id="getevent-与-sendevent"><a href="#getevent-与-sendevent" class="headerlink" title="getevent 与 sendevent"></a>getevent 与 sendevent</h4><p>Android 系统提供了getevent和setevent两个工具共开发者从设备节点中直接读取输入事件或写入事件。</p>
<p>原始事件的四项基本元素：</p>
<ul>
<li>时间戳</li>
<li>类型</li>
<li>代码</li>
<li>值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell getevent[-选项] [device_path]</span><br><span class="line">$ adb shell sendevent &lt;节点路径&gt; &lt;类型&gt; &lt;代码&gt; &lt;值&gt;</span><br></pre></td></tr></table></figure>
<h4 id="模拟输入事件"><a href="#模拟输入事件" class="headerlink" title="模拟输入事件"></a>模拟输入事件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell input keyevent XX</span><br></pre></td></tr></table></figure>
<pre><code>•    0 --&gt;  &quot;KEYCODE_UNKNOWN&quot;
•    1 --&gt;  &quot;KEYCODE_MENU&quot;
•    2 --&gt;  &quot;KEYCODE_SOFT_RIGHT&quot;
•    3 --&gt;  &quot;KEYCODE_HOME&quot;
•    4 --&gt;  &quot;KEYCODE_BACK&quot;
•    5 --&gt;  &quot;KEYCODE_CALL&quot;
•    6 --&gt;  &quot;KEYCODE_ENDCALL&quot;
•    7 --&gt;  &quot;KEYCODE_0&quot;
•    8 --&gt;  &quot;KEYCODE_1&quot;
•    9 --&gt;  &quot;KEYCODE_2&quot;
•    10 --&gt;  &quot;KEYCODE_3&quot;
•    11 --&gt;  &quot;KEYCODE_4&quot;
•    12 --&gt;  &quot;KEYCODE_5&quot;
•    13 --&gt;  &quot;KEYCODE_6&quot;
•    14 --&gt;  &quot;KEYCODE_7&quot;
•    15 --&gt;  &quot;KEYCODE_8&quot;
•    16 --&gt;  &quot;KEYCODE_9&quot;
•    17 --&gt;  &quot;KEYCODE_STAR&quot;
•    18 --&gt;  &quot;KEYCODE_POUND&quot;
•    19 --&gt;  &quot;KEYCODE_DPAD_UP&quot;
•    20 --&gt;  &quot;KEYCODE_DPAD_DOWN&quot;
•    21 --&gt;  &quot;KEYCODE_DPAD_LEFT&quot;
•    22 --&gt;  &quot;KEYCODE_DPAD_RIGHT&quot;
•    23 --&gt;  &quot;KEYCODE_DPAD_CENTER&quot;
•    24 --&gt;  &quot;KEYCODE_VOLUME_UP&quot;
•    25 --&gt;  &quot;KEYCODE_VOLUME_DOWN&quot;
•    26 --&gt;  &quot;KEYCODE_POWER&quot;
•    27 --&gt;  &quot;KEYCODE_CAMERA&quot;
•    28 --&gt;  &quot;KEYCODE_CLEAR&quot;
•    29 --&gt;  &quot;KEYCODE_A&quot;
•    30 --&gt;  &quot;KEYCODE_B&quot;
•    31 --&gt;  &quot;KEYCODE_C&quot;
•    32 --&gt;  &quot;KEYCODE_D&quot;
•    33 --&gt;  &quot;KEYCODE_E&quot;
•    34 --&gt;  &quot;KEYCODE_F&quot;
•    35 --&gt;  &quot;KEYCODE_G&quot;
•    36 --&gt;  &quot;KEYCODE_H&quot;
•    37 --&gt;  &quot;KEYCODE_I&quot;
•    38 --&gt;  &quot;KEYCODE_J&quot;
•    39 --&gt;  &quot;KEYCODE_K&quot;
•    40 --&gt;  &quot;KEYCODE_L&quot;
•    41 --&gt;  &quot;KEYCODE_M&quot;
•    42 --&gt;  &quot;KEYCODE_N&quot;
•    43 --&gt;  &quot;KEYCODE_O&quot;
•    44 --&gt;  &quot;KEYCODE_P&quot;
•    45 --&gt;  &quot;KEYCODE_Q&quot;
•    46 --&gt;  &quot;KEYCODE_R&quot;
•    47 --&gt;  &quot;KEYCODE_S&quot;
•    48 --&gt;  &quot;KEYCODE_T&quot;
•    49 --&gt;  &quot;KEYCODE_U&quot;
•    50 --&gt;  &quot;KEYCODE_V&quot;
•    51 --&gt;  &quot;KEYCODE_W&quot;
•    52 --&gt;  &quot;KEYCODE_X&quot;
•    53 --&gt;  &quot;KEYCODE_Y&quot;
•    54 --&gt;  &quot;KEYCODE_Z&quot;
•    55 --&gt;  &quot;KEYCODE_COMMA&quot;
•    56 --&gt;  &quot;KEYCODE_PERIOD&quot;
•    57 --&gt;  &quot;KEYCODE_ALT_LEFT&quot;
•    58 --&gt;  &quot;KEYCODE_ALT_RIGHT&quot;
•    59 --&gt;  &quot;KEYCODE_SHIFT_LEFT&quot;
•    60 --&gt;  &quot;KEYCODE_SHIFT_RIGHT&quot;
•    61 --&gt;  &quot;KEYCODE_TAB&quot;
•    62 --&gt;  &quot;KEYCODE_SPACE&quot;
•    63 --&gt;  &quot;KEYCODE_SYM&quot;
•    64 --&gt;  &quot;KEYCODE_EXPLORER&quot;
•    65 --&gt;  &quot;KEYCODE_ENVELOPE&quot;
•    66 --&gt;  &quot;KEYCODE_ENTER&quot;
•    67 --&gt;  &quot;KEYCODE_DEL&quot;
•    68 --&gt;  &quot;KEYCODE_GRAVE&quot;
•    69 --&gt;  &quot;KEYCODE_MINUS&quot;
•    70 --&gt;  &quot;KEYCODE_EQUALS&quot;
•    71 --&gt;  &quot;KEYCODE_LEFT_BRACKET&quot;
•    72 --&gt;  &quot;KEYCODE_RIGHT_BRACKET&quot;
•    73 --&gt;  &quot;KEYCODE_BACKSLASH&quot;
•    74 --&gt;  &quot;KEYCODE_SEMICOLON&quot;
•    75 --&gt;  &quot;KEYCODE_APOSTROPHE&quot;
•    76 --&gt;  &quot;KEYCODE_SLASH&quot;
•    77 --&gt;  &quot;KEYCODE_AT&quot;
•    78 --&gt;  &quot;KEYCODE_NUM&quot;
•    79 --&gt;  &quot;KEYCODE_HEADSETHOOK&quot;
•    80 --&gt;  &quot;KEYCODE_FOCUS&quot;
•    81 --&gt;  &quot;KEYCODE_PLUS&quot;
•    82 --&gt;  &quot;KEYCODE_MENU&quot;
•    83 --&gt;  &quot;KEYCODE_NOTIFICATION&quot;
•    84 --&gt;  &quot;KEYCODE_SEARCH&quot;
•    85 --&gt;  &quot;TAG_LAST_KEYCODE&quot;
</code></pre><h2 id="Android输入系统的工作原理"><a href="#Android输入系统的工作原理" class="headerlink" title="Android输入系统的工作原理"></a>Android输入系统的工作原理</h2><p>就是监控/dev/input/下所有设备节点，当某个节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中寻找合适的事件接受者，并派发给它。</p>
<h2 id="INotify-与-Epoll"><a href="#INotify-与-Epoll" class="headerlink" title="INotify 与 Epoll"></a>INotify 与 Epoll</h2><h3 id="INotify"><a href="#INotify" class="headerlink" title="INotify"></a>INotify</h3><p>INotify是linux提供的一种文件系统变化通知机制。INotify机制有两个对象，分别为inotif对象和watch对象。watch监听文件的删除创建读写等，inotify对象是通过主动轮询读取的。</p>
<h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><p>Epoll可以使用一次等待监听多个描述符的可读/可写状态。等待返回时携带了可读的描述符或自定义的数据，使用者据此读取所需的数据后可以再次进入等待。因此不需要为每个描述符创建独立的线程进行阻塞读取，避免了资源浪费同时获得更快的响应速度。</p>
<p>使用:</p>
<ul>
<li>通过epoll_create()创建一个epoll对象</li>
<li>为需要监听的描述符填充epoll_events结构体,并使用epoll_ctl()注册到epoll对象中。</li>
<li>epoll_wait等待事件发生</li>
<li>epoll_wait返回epoll_events结构体数组判断事件的类型与来源并进行处理。</li>
<li>epoll_wait等待新事件</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当有新的设备可用的时候，现在/dev/input下，当input下新增或者删除设备的时候，INotify会通知到EventHub去读取对应的设备信息，并将对应的信息发送给对应的window。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/24/正则表达式/" class="article-date">
  	<time datetime="2018-05-23T16:00:00.000Z" itemprop="datePublished">2018-05-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/24/正则表达式/">
        正则表达式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="号代表前面的字符必须至少出现一次"><a href="#号代表前面的字符必须至少出现一次" class="headerlink" title="+号代表前面的字符必须至少出现一次"></a>+号代表前面的字符必须至少出现一次</h3><ul>
<li>sh+e = she,shhhe</li>
</ul>
<h3 id="号代表前一个字符可以出现任意次（0次、或1次、或多次）。"><a href="#号代表前一个字符可以出现任意次（0次、或1次、或多次）。" class="headerlink" title="*号代表前一个字符可以出现任意次（0次、或1次、或多次）。"></a>*号代表前一个字符可以出现任意次（0次、或1次、或多次）。</h3><ul>
<li>shh+e = she,shhhe…</li>
</ul>
<h3 id="问号代表前面的字符最多只可以出现一次（0次、或1次）"><a href="#问号代表前面的字符最多只可以出现一次（0次、或1次）" class="headerlink" title="? 问号代表前面的字符最多只可以出现一次（0次、或1次）"></a>? 问号代表前面的字符最多只可以出现一次（0次、或1次）</h3><ul>
<li>shh?e = she,shhe</li>
</ul>
<h3 id="将下一个字符标记为一个特殊字符"><a href="#将下一个字符标记为一个特殊字符" class="headerlink" title="\将下一个字符标记为一个特殊字符"></a>\将下一个字符标记为一个特殊字符</h3><ul>
<li>为了逐字表达，你必须在”^.$()¦*+?{\”这些字符前加上转移字符’\’</li>
</ul>
<h3 id="和-一个字符串的开始和结束"><a href="#和-一个字符串的开始和结束" class="headerlink" title="^和$一个字符串的开始和结束"></a>^和$一个字符串的开始和结束</h3><ul>
<li>^The = There…</li>
<li>$end = the end</li>
<li>^abc$ = abc</li>
</ul>
<h3 id="n"><a href="#n" class="headerlink" title="{n}"></a>{n}</h3><ul>
<li>ab{2}：表示一个字符串有一个a跟着2个b</li>
<li>ab{2,}：表示一个字符串有一个a跟着至少2个b</li>
<li>ab{3,5}：表示一个字符串有一个a跟着3到5个b</li>
</ul>
<h3 id="或"><a href="#或" class="headerlink" title="或 |"></a>或 |</h3><ul>
<li>(b|cd)ef = bef或cdef</li>
</ul>
<h3 id="可以表示任何字符"><a href="#可以表示任何字符" class="headerlink" title=".可以表示任何字符"></a>.可以表示任何字符</h3><ul>
<li>A.=A后面跟着任意一个字符</li>
</ul>
<h3 id="特定字符"><a href="#特定字符" class="headerlink" title="[]特定字符"></a>[]特定字符</h3><p>[a-zA-Z]=任意字母</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Android DataBinding" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/18/Android DataBinding/" class="article-date">
  	<time datetime="2018-05-17T16:00:00.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/Android DataBinding/">
        Android DataBinding
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-DataBinding"><a href="#Android-DataBinding" class="headerlink" title="Android DataBinding"></a>Android DataBinding</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>实现view和data的双向绑定。</p>
<h2 id="好处与不足"><a href="#好处与不足" class="headerlink" title="好处与不足"></a>好处与不足</h2><ul>
<li>减少findviewbyid的繁琐代码</li>
<li>减少setview数据的繁琐代码</li>
<li>包名修改时不能自动修改引用路径</li>
<li>早起版本不问题，问题较多</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>以XML注入的方式对view和数据进行绑定，并通过set数据时去更新UI的原理，以观察者模式形式实现。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>app/build<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用模板：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;!--此处定义该布局要用到的数据的名称及类型--&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;跟布局 /&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.lastName&#125;&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-布局文件处理"><a href="#1-布局文件处理" class="headerlink" title="1 布局文件处理"></a>1 布局文件处理</h3><p>首先，DataBinding会对根元素为<layout>的布局文件进行预处理，使用了binding表达式的view都被设置了Tag，而原有的<layout>标签、data标签以及里面的variable标签，还有各个view中的binding表达式都不见了</layout></layout></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>     &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/firstname"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:tag</span>=<span class="string">"binding_1"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-生成数据以及view的关系映射文件：activity-main-layout-xml（在build-intermediates-data-binding-info文件夹中）"><a href="#2-生成数据以及view的关系映射文件：activity-main-layout-xml（在build-intermediates-data-binding-info文件夹中）" class="headerlink" title="2 生成数据以及view的关系映射文件：activity_main-layout.xml（在build/intermediates/data-binding-info文件夹中）"></a>2 生成数据以及view的关系映射文件：activity_main-layout.xml（在build/intermediates/data-binding-info文件夹中）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> standalone=<span class="string">"yes"</span>?&gt;</span><br><span class="line">&lt;Layout layout=<span class="string">"activity_main"</span> </span><br><span class="line">modulePackage=<span class="string">"XXX"</span> &gt;</span><br><span class="line"></span><br><span class="line">&lt;Variables declared=<span class="string">"true"</span> type=<span class="string">"XXX.User"</span> name=<span class="string">"user"</span>&gt;</span><br><span class="line">&lt;/Variables&gt;</span><br><span class="line"></span><br><span class="line">&lt;Targets&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Target tag=<span class="string">"layout/activity_main_0"</span> view=<span class="string">"LinearLayout"</span>&gt;</span><br><span class="line">    &lt;/Target&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Target id=<span class="string">"@+id/firstname"</span> tag=<span class="string">"binding_1"</span> view=<span class="string">"TextView"</span>&gt;      </span><br><span class="line">            &lt;Expression text=<span class="string">"user.firstName"</span> attribute=<span class="string">"android:text"</span>/&gt;</span><br><span class="line">    &lt;/Target&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/Targets&gt;</span><br><span class="line">&lt;/Layout&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-生成activitybinding和BR"><a href="#3-生成activitybinding和BR" class="headerlink" title="3 生成activitybinding和BR"></a>3 生成activitybinding和BR</h3><p>AS会自动识别databinding的view的布局格式并产生成对应的activitybinding(该对象持有Activity要展示的数据和布局中的各个view的引用)对象和BR(BR文件是一个对应modle属性的Map表)对象。binding对象记录对应的data数据以及data和view的绑定关系。</p>
<h3 id="实时更新设置"><a href="#实时更新设置" class="headerlink" title="实时更新设置"></a>实时更新设置</h3><p>以上实现了数据的binding，但是不会实时刷新，要实现实时刷新需要对数据进行监听：<br>无论哪种模式，最终的目的都是当数据变化时，对应的ActivityDataBinding对象回去动态更新对应view的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-生成activitybinding实例并绑定"><a href="#4-生成activitybinding实例并绑定" class="headerlink" title="4 生成activitybinding实例并绑定"></a>4 生成activitybinding实例并绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">   <span class="comment">//获取bind并设置data</span></span><br><span class="line">   MainActivityBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br><span class="line">   User user = <span class="keyword">new</span> User(<span class="string">"Test"</span>, <span class="string">"User"</span>);</span><br><span class="line">   binding.setUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="当数据发生变化时"><a href="#当数据发生变化时" class="headerlink" title="当数据发生变化时"></a>当数据发生变化时</h3><p>会以消息队列的方式发送给对应的activitybinding实例去更新对应的view的值，并进行重新绑定。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-逆向-small语法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/05/逆向-small语法/" class="article-date">
  	<time datetime="2018-05-04T16:00:00.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/逆向-small语法/">
        逆向-small语法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="逆向-small语法"><a href="#逆向-small语法" class="headerlink" title="逆向-small语法"></a>逆向-small语法</h1><p>Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Dalvik的字节码中拥有两个主要的类型：基类和引用类型。引用类型是对象和数组，其他的一切都是基类。</p>
<h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><p>基类对照：</p>
<ul>
<li>V        空类型—仅仅可以用来作为返回类型</li>
<li>Z        Boolean 布尔型</li>
<li>B        Byte字节型</li>
<li>S        Short短整型（16位）</li>
<li>C        Char字符型</li>
<li>I        Int 整形</li>
<li>J        long (64 bits)长整型（64位）</li>
<li>F        Float浮点型</li>
<li>D        double (64 bits)双精度型（64位）</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象采用这样的形式Lpackage/name/ObjectName—开始的L表明这是一个对象类型，package/name/就是该对象，对象名是是对象的名称，并且分号表明对象名的结束。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.class &lt; 访问权限&gt; [ 修饰关键字] &lt; 类名&gt;  </span><br><span class="line">.<span class="keyword">super</span> &lt; 父类名&gt;  </span><br><span class="line">.source &lt;源文件名&gt;  </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">.class <span class="keyword">public</span> La/b/a/a;</span><br><span class="line">.<span class="keyword">super</span> Ljava/lang/Object;</span><br><span class="line">.source <span class="string">"SourceFile"</span></span><br></pre></td></tr></table></figure>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># static fields  </span><br><span class="line">.field &lt; 访问权限&gt; <span class="keyword">static</span> [ 修饰关键字] &lt; 字段名&gt;:&lt; 字段类型&gt;  </span><br><span class="line"># instance fields  </span><br><span class="line">.field &lt; 访问权限&gt; [ 修饰关键字] &lt; 字段名&gt;:&lt; 字段类型&gt;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># direct methods                //添加的注释  </span><br><span class="line">.method &lt;访问权限&gt; [ 修饰关键字] &lt; 方法原型&gt;  </span><br><span class="line">    &lt;.locals&gt;                 <span class="comment">//指定了使用的局部变量的个数  </span></span><br><span class="line"> [.parameter]                   <span class="comment">//指定了方法的参数  </span></span><br><span class="line"> [.prologue]                    <span class="comment">//指定了代码的开始处，混淆过的代码可能去掉了该指令  </span></span><br><span class="line"> [.line]                    <span class="comment">//指定了该处指令在源代码中的行号  </span></span><br><span class="line">&lt;代码体&gt;  </span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>Java虚方法你可以理解为java里所有被overriding的方法都是virtual的,所有重写的方法都是override的。虚方法的声明与直接方法相同，只是起始处的注释为“virtual methods”。</p>
<h3 id="方法调用格式："><a href="#方法调用格式：" class="headerlink" title="方法调用格式："></a>方法调用格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;MethodName(III)Z</span><br></pre></td></tr></table></figure>
<p> Lpackage/name/ObjectName; 是一个类， MethodName明显是一个方法名，‘III’在这个例子中是三个整形参数，Z是表示返回一个布尔类型的返回值。</p>
<p>数组：“[I = int[]   [[I = int[][]”</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器总是32位可以存放任何类型的值，2个寄存器可以用来存放64位类型（长整形和双精度型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-virtual &#123;v0, p1, p2, p3&#125;, Ljava/beans/PropertyChangeSupport;-&gt;firePropertyChange(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure>
<p>对于寄存器这里有两种命名方案—标准的V命名方案和对于参数寄存器的P命名方案。</p>
<p>以p命名的第一个寄存器就是方法中的第一个参数寄存器，所以让我们回到之前的总共拥有5个寄存器其中3个参数的例子。下表中显示了为每个寄存器的标准v命名，紧接着是为参数寄存器的p命名</p>
<ul>
<li>v0                 the first local register       第一个本地寄存器</li>
<li>v1                 the second local register  第二个本地寄存器</li>
<li>v2        p0        the first parameter register   第一个参数寄存器</li>
<li>v3        p1        the second parameter register   第二个参数寄存器</li>
<li>v4        p2        the third parameter register   第三个参数寄存器</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 ShenYonghe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>