<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>ANR 分析 [ Diablo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

</head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/home.png"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">Home</a>
        
          
          
          
          
          
          
          <a href="/archives">Archives</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">ANR 分析</h1>
<article class="post markdown-style">
  <h1 id="WatchDog"><a href="#WatchDog" class="headerlink" title="WatchDog"></a>WatchDog</h1><p>现在的CPU基本上都带有WatchDog功能，这种硬件的WatchDog可以在系统死掉(死锁或者程序跑飞)后重启系统，让系统回到可以工作的状态。WatchDog不能防止系统死掉，但是它能够起死回生，从而提高系统的可用性。Android系统中，有硬件WatchDog用于定时检测关键硬件是否正常工作，类似地，在framework层有一个软件WatchDog用于定期检测关键系统服务是否发生死锁事件。WatchDog功能主要是分析系统核心服务和重要线程是否处于Blocked状态。</p>
<p>Watchdog是一个运行在system_server进程的名为”watchdog”的线程。Watchdog运作过程，当阻塞时间超过1分钟则触发一次watchdog，会杀死system_server,触发上层重启。mHandlerCheckers记录所有的HandlerChecker对象的列表，包括foreground, main, ui, i/o, display线程的handler。mHandlerChecker.mMonitors记录所有Watchdog目前正在监控Monitor，所有的这些monitors都运行在foreground线程。</p>
<p><img src="https://img-blog.csdn.net/20150618210217230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluemh1b2p1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>1 在SystemServer初始化的时候调用startOtherServices初始化WatchDog对象，注册reboot广播，调用start开始工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SystemServer.startOtherServices</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();</span><br><span class="line">    watchdog.init(context, mActivityManagerService);</span><br><span class="line">    ...</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">    ...</span><br><span class="line">    mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mSystemServiceManager.startBootPhase(</span><br><span class="line">                   SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">           ...</span><br><span class="line">                   Watchdog.getInstance().start();</span><br><span class="line">                   mSystemServiceManager.startBootPhase(</span><br><span class="line">                   SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 WatchDog分析，Watchdog继承于Thread，创建的线程名为”watchdog”。mHandlerCheckers队列包括、 主线程，fg, ui, io, display线程的HandlerChecker对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Watchdog <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sWatchdog == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sWatchdog = <span class="keyword">new</span> Watchdog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sWatchdog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Watchdog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"watchdog"</span>);</span><br><span class="line">    <span class="comment">// Initialize handler checkers for each common thread we want to check.  Note</span></span><br><span class="line">    <span class="comment">// that we are not currently checking the background thread, since it can</span></span><br><span class="line">    <span class="comment">// potentially hold longer running operations with no guarantees about the timeliness</span></span><br><span class="line">    <span class="comment">// of operations there.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The shared foreground thread is the main checker.  It is where we</span></span><br><span class="line">    <span class="comment">// will also dispatch monitor checks and do other work.</span></span><br><span class="line">    mMonitorChecker = <span class="keyword">new</span> HandlerChecker(FgThread.getHandler(),</span><br><span class="line">            <span class="string">"foreground thread"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">    mHandlerCheckers.add(mMonitorChecker);</span><br><span class="line">    <span class="comment">// Add checker for main thread.  We only do a quick check since there</span></span><br><span class="line">    <span class="comment">// can be UI running on the thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(<span class="keyword">new</span> Handler(Looper.getMainLooper()),</span><br><span class="line">            <span class="string">"main thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    <span class="comment">// Add checker for shared UI thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(UiThread.getHandler(),</span><br><span class="line">            <span class="string">"ui thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    <span class="comment">// And also check IO thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(IoThread.getHandler(),</span><br><span class="line">            <span class="string">"i/o thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    <span class="comment">// And the display thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(DisplayThread.getHandler(),</span><br><span class="line">            <span class="string">"display thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize monitor for Binder threads.</span></span><br><span class="line">    addMonitor(<span class="keyword">new</span> BinderThreadMonitor());</span><br><span class="line"></span><br><span class="line">    mOpenFdMonitor = OpenFdMonitor.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See the notes on DEFAULT_TIMEOUT.</span></span><br><span class="line">    <span class="keyword">assert</span> DB ||</span><br><span class="line">            DEFAULT_TIMEOUT &gt; ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 addMonitor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler; <span class="comment">//Handler对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName; <span class="comment">//线程描述名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mWaitMax; <span class="comment">//最长等待时间</span></span><br><span class="line">    <span class="comment">//记录着监控的服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Monitor&gt; mMonitors = <span class="keyword">new</span> ArrayList&lt;Monitor&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mCompleted; <span class="comment">//开始检查时先设置成false</span></span><br><span class="line">    <span class="keyword">private</span> Monitor mCurrentMonitor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mStartTime; <span class="comment">//开始准备检查的时间点</span></span><br><span class="line"></span><br><span class="line">    HandlerChecker(Handler handler, String name, <span class="keyword">long</span> waitMaxMillis) &#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">        mName = name;</span><br><span class="line">        mWaitMax = waitMaxMillis;</span><br><span class="line">        mCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//addMonitor 监控Binder线程, 将monitor添加到HandlerChecker的成员变量mMonitors列表中。 在这里是将BinderThreadMonitor对象加入该线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watchdog</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMonitor</span><span class="params">(Monitor monitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//此处mMonitorChecker数据类型为HandlerChecker</span></span><br><span class="line">            mMonitorChecker.addMonitor(monitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Monitor&gt; mMonitors = <span class="keyword">new</span> ArrayList&lt;Monitor&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMonitor</span><span class="params">(Monitor monitor)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将上面的BinderThreadMonitor添加到mMonitors队列</span></span><br><span class="line">            mMonitors.add(monitor);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderThreadMonitor</span> <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Binder.blockUntilThreadAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IPCThreadState blockUntilThreadAvailable最终调用的是IPCThreadState，等待有空闲的binder线程,可见addMonitor(new BinderThreadMonitor())是将Binder线程添加到android.fg线程的handler(mMonitorChecker)来检查是否工作正常</span></span><br><span class="line"><span class="keyword">void</span> IPCThreadState::blockUntilThreadAvailable()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    <span class="keyword">while</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads) &#123;</span><br><span class="line">        <span class="comment">//等待正在执行的binder线程小于进程最大binder线程上限(16个)</span></span><br><span class="line">        pthread_cond_wait(&amp;mProcess-&gt;mThreadCountDecrement, &amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, ActivityManagerService activity)</span> </span>&#123;</span><br><span class="line">    mResolver = context.getContentResolver();</span><br><span class="line">    mActivity = activity;</span><br><span class="line">    <span class="comment">//注册reboot广播接收者</span></span><br><span class="line">    context.registerReceiver(<span class="keyword">new</span> RebootRequestReceiver(),</span><br><span class="line">            <span class="keyword">new</span> IntentFilter(Intent.ACTION_REBOOT),</span><br><span class="line">            android.Manifest.permission.REBOOT, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RebootRequestReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context c, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intent.getIntExtra(<span class="string">"nowait"</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            rebootSystem(<span class="string">"Received ACTION_REBOOT broadcast"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Unsupported ACTION_REBOOT broadcast: "</span> + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebootSystem</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    Slog.i(TAG, <span class="string">"Rebooting system because: "</span> + reason);</span><br><span class="line">    IPowerManager pms = (IPowerManager)ServiceManager.getService(Context.POWER_SERVICE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过PowerManager执行reboot操作</span></span><br><span class="line">        pms.reboot(<span class="keyword">false</span>, reason, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检测机制"><a href="#检测机制" class="headerlink" title="检测机制"></a>检测机制</h2><p>当调用Watchdog.getInstance().start()时，则进入线程“watchdog”的run()方法。</p>
<p>1 执行所有的Checker的监控方法scheduleCheckLocked()<br>2 等待30s后, 再调用evaluateCheckerCompletionLocked来评估Checker状态<br>3 根据waitState状态来执行不同的操作:当COMPLETED或WAITING,则相安无事,当WAITED_HALF(超过30s)且为首次, 则输出system_server和3个Native进程的traces,当OVERDUE, 则输出更多信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Watchdog.run()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;HandlerChecker&gt; blockedCheckers;</span><br><span class="line">        <span class="keyword">final</span> String subject;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> allowRestart;</span><br><span class="line">        <span class="keyword">int</span> debuggerWasConnected = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeout = CHECK_INTERVAL;</span><br><span class="line">            <span class="comment">// Make sure we (re)spin the checkers that have become idle within</span></span><br><span class="line">            <span class="comment">// this wait-and-check interval</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">                HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">                hc.scheduleCheckLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (debuggerWasConnected &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                debuggerWasConnected--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> We use uptimeMillis() here because we do not want to increment the time we</span></span><br><span class="line">            <span class="comment">// wait while asleep. If the device is asleep then the thing that we are waiting</span></span><br><span class="line">            <span class="comment">// to timeout on is asleep as well and won't have a chance to run, causing a false</span></span><br><span class="line">            <span class="comment">// positive on when to kill things.</span></span><br><span class="line">            <span class="keyword">long</span> start = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//通过循环,保证执行30s才会继续往下执行</span></span><br><span class="line">            <span class="keyword">while</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Debug.isDebuggerConnected()) &#123;</span><br><span class="line">                    debuggerWasConnected = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait(timeout); <span class="comment">//触发中断,直接捕获异常,继续等待.</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Log.wtf(TAG, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Debug.isDebuggerConnected()) &#123;</span><br><span class="line">                    debuggerWasConnected = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> fdLimitTriggered = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mOpenFdMonitor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fdLimitTriggered = mOpenFdMonitor.monitor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!fdLimitTriggered) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> waitState = evaluateCheckerCompletionLocked();</span><br><span class="line">                <span class="keyword">if</span> (waitState == COMPLETED) &#123;</span><br><span class="line">                    <span class="comment">// The monitors have returned; reset</span></span><br><span class="line">                    waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITING) &#123;</span><br><span class="line">                    <span class="comment">// still waiting but within their configured intervals; back off and recheck</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITED_HALF) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!waitedHalf) &#123;</span><br><span class="line">                        <span class="comment">// We've waited half the deadlock-detection interval.  Pull a stack</span></span><br><span class="line">                        <span class="comment">// trace and wait another half.</span></span><br><span class="line">                        ArrayList&lt;Integer&gt; pids = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                        pids.add(Process.myPid());</span><br><span class="line">                        ActivityManagerService.dumpStackTraces(<span class="keyword">true</span>, pids, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                            getInterestingNativePids());</span><br><span class="line">                        waitedHalf = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// something is overdue!</span></span><br><span class="line">                <span class="comment">//获取被阻塞的checkers</span></span><br><span class="line">                blockedCheckers = getBlockedCheckersLocked();</span><br><span class="line">                <span class="comment">// 获取描述信息</span></span><br><span class="line">                subject = describeCheckersLocked(blockedCheckers);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                blockedCheckers = Collections.emptyList();</span><br><span class="line">                subject = <span class="string">"Open FD high water mark reached"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allowRestart = mAllowRestart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we got here, that means that the system is most likely hung.</span></span><br><span class="line">        <span class="comment">// First collect stack traces from all threads of the system process.</span></span><br><span class="line">        <span class="comment">// Then kill this process so that the system will restart.</span></span><br><span class="line">        EventLog.writeEvent(EventLogTags.WATCHDOG, subject);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; pids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        pids.add(Process.myPid());</span><br><span class="line">        <span class="keyword">if</span> (mPhonePid &gt; <span class="number">0</span>) pids.add(mPhonePid);</span><br><span class="line">        <span class="comment">// Pass !waitedHalf so that just in case we somehow wind up here without having</span></span><br><span class="line">        <span class="comment">// dumped the halfway stacks, we properly re-initialize the trace file.</span></span><br><span class="line">        <span class="keyword">final</span> File stack = ActivityManagerService.dumpStackTraces(</span><br><span class="line">                !waitedHalf, pids, <span class="keyword">null</span>, <span class="keyword">null</span>, getInterestingNativePids());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give some extra time to make sure the stack traces get written.</span></span><br><span class="line">        <span class="comment">// The system's been hanging for a minute, another second or two won't hurt much.</span></span><br><span class="line">        <span class="comment">//系统已被阻塞1分钟，也不在乎多等待2s，来确保stack trace信息输出</span></span><br><span class="line">        SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger the kernel to dump all blocked threads, and backtraces on all CPUs to the kernel log</span></span><br><span class="line">        doSysRq(<span class="string">'w'</span>);</span><br><span class="line">        doSysRq(<span class="string">'l'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to add the error to the dropbox, but assuming that the ActivityManager</span></span><br><span class="line">        <span class="comment">// itself may be deadlocked.  (which has happened, causing this statement to</span></span><br><span class="line">        <span class="comment">// deadlock and the watchdog as a whole to be ineffective)</span></span><br><span class="line">        Thread dropboxThread = <span class="keyword">new</span> Thread(<span class="string">"watchdogWriteToDropbox"</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mActivity.addErrorToDropBox(</span><br><span class="line">                            <span class="string">"watchdog"</span>, <span class="keyword">null</span>, <span class="string">"system_server"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                            subject, <span class="keyword">null</span>, stack, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        dropboxThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dropboxThread.join(<span class="number">2000</span>);  <span class="comment">// wait up to 2 seconds for it to return.</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        IActivityController controller;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            controller = mController;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (controller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Reporting stuck state to activity controller"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Binder.setDumpDisabled(<span class="string">"Service dumps disabled due to hung system process."</span>);</span><br><span class="line">                <span class="comment">// 1 = keep waiting, -1 = kill system</span></span><br><span class="line">                <span class="keyword">int</span> res = controller.systemNotResponding(subject);</span><br><span class="line">                <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">"Activity controller requested to coninue to wait"</span>);</span><br><span class="line">                    waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only kill the process if the debugger is not attached.</span></span><br><span class="line">        <span class="keyword">if</span> (Debug.isDebuggerConnected()) &#123;</span><br><span class="line">            debuggerWasConnected = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (debuggerWasConnected &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Debugger connected: Watchdog is *not* killing the system process"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (debuggerWasConnected &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Debugger was connected: Watchdog is *not* killing the system process"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowRestart) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Restart not allowed: Watchdog is *not* killing the system process"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"*** WATCHDOG KILLING SYSTEM PROCESS: "</span> + subject);</span><br><span class="line">            WatchdogDiagnostics.diagnoseCheckers(blockedCheckers);</span><br><span class="line">            Slog.w(TAG, <span class="string">"*** GOODBYE!"</span>);</span><br><span class="line">            <span class="comment">//杀死进程system_server</span></span><br><span class="line">            Process.killProcess(Process.myPid());</span><br><span class="line">            System.exit(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scheduleCheckLocked:该方法主要功能: 向Watchdog的监控线程的Looper池的最头部执行该HandlerChecker.run()方法, 在该方法中调用monitor(),执行完成后会设置mCompleted = true. 那么当handler消息池当前的消息, 导致迟迟没有机会执行monitor()方法, 则会触发watchdog。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleCheckLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMonitors.size() == <span class="number">0</span> &amp;&amp; mHandler.getLooper().getQueue().isPolling()) &#123;</span><br><span class="line">            mCompleted = <span class="keyword">true</span>; <span class="comment">//当目标looper正在轮询状态则返回。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mCompleted) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//有一个check正在处理中，则无需重复发送</span></span><br><span class="line">        &#125;</span><br><span class="line">        mCompleted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        mCurrentMonitor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 记录当下的时间</span></span><br><span class="line">        mStartTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//发送消息，插入消息队列最开头， 见下方的run()方法</span></span><br><span class="line">        mHandler.postAtFrontOfQueue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mMonitors.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Watchdog.<span class="keyword">this</span>) &#123;</span><br><span class="line">                mCurrentMonitor = mMonitors.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回调具体服务的monitor方法</span></span><br><span class="line">            mCurrentMonitor.monitor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Watchdog.<span class="keyword">this</span>) &#123;</span><br><span class="line">            mCompleted = <span class="keyword">true</span>;</span><br><span class="line">            mCurrentMonitor = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取mHandlerCheckers列表中等待状态值最大的state</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">evaluateCheckerCompletionLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state = COMPLETED;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">        HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">        state = Math.max(state, hc.getCompletionStateLocked());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	COMPLETED = 0：等待完成；</span></span><br><span class="line"><span class="comment">//	WAITING = 1：等待时间小于DEFAULT_TIMEOUT的一半，即30s；</span></span><br><span class="line"><span class="comment">//WAITED_HALF = 2：等待时间处于30s~60s之间；</span></span><br><span class="line"><span class="comment">//OVERDUE = 3：等待时间大于或等于60s。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCompletionStateLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCompleted) &#123;</span><br><span class="line">        <span class="keyword">return</span> COMPLETED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> latency = SystemClock.uptimeMillis() - mStartTime;</span><br><span class="line">        <span class="comment">// mWaitMax默认是60s</span></span><br><span class="line">        <span class="keyword">if</span> (latency &lt; mWaitMax/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> WAITING;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (latency &lt; mWaitMax) &#123;</span><br><span class="line">            <span class="keyword">return</span> WAITED_HALF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OVERDUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WatchDog异常处理"><a href="#WatchDog异常处理" class="headerlink" title="WatchDog异常处理"></a>WatchDog异常处理</h2><p>收集完信息后便会杀死system_server进程。此处allowRestart默认值为true, 当执行am hang操作则设置不允许重启(allowRestart =false), 则不会杀死system_server进程.</p>
<p>1 AMS.dumpStackTraces：输出Java和Native进程的栈信息；<br>2 WD.dumpKernelStackTraces：输出Kernel栈信息；<br>3 doSysRq dropBox</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//获取被阻塞的checkers 【见小节4.1.1】</span></span><br><span class="line">            blockedCheckers = getBlockedCheckersLocked();</span><br><span class="line">            <span class="comment">// 获取描述信息 【见小节4.1.2】</span></span><br><span class="line">            subject = describeCheckersLocked(blockedCheckers);</span><br><span class="line">            allowRestart = mAllowRestart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventLog.writeEvent(EventLogTags.WATCHDOG, subject);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; pids = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        pids.add(Process.myPid());</span><br><span class="line">        <span class="keyword">if</span> (mPhonePid &gt; <span class="number">0</span>) pids.add(mPhonePid);</span><br><span class="line">        <span class="comment">//第二次以追加的方式，输出system_server和3个native进程的栈信息【见小节4.2】</span></span><br><span class="line">        <span class="keyword">final</span> File stack = ActivityManagerService.dumpStackTraces(</span><br><span class="line">                !waitedHalf, pids, <span class="keyword">null</span>, <span class="keyword">null</span>, NATIVE_STACKS_OF_INTEREST);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统已被阻塞1分钟，也不在乎多等待2s，来确保stack trace信息输出</span></span><br><span class="line">        SystemClock.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RECORD_KERNEL_THREADS) &#123;</span><br><span class="line">            <span class="comment">//输出kernel栈信息【见小节4.3】</span></span><br><span class="line">            dumpKernelStackTraces();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发kernel来dump所有阻塞线程【见小节4.4】</span></span><br><span class="line">        doSysRq(<span class="string">'l'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出dropbox信息【见小节4.5】</span></span><br><span class="line">        Thread dropboxThread = <span class="keyword">new</span> Thread(<span class="string">"watchdogWriteToDropbox"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mActivity.addErrorToDropBox(</span><br><span class="line">                        <span class="string">"watchdog"</span>, <span class="keyword">null</span>, <span class="string">"system_server"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                        subject, <span class="keyword">null</span>, stack, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        dropboxThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dropboxThread.join(<span class="number">2000</span>); <span class="comment">//等待dropbox线程工作2s</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IActivityController controller;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            controller = mController;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (controller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将阻塞状态报告给activity controller，</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Binder.setDumpDisabled(<span class="string">"Service dumps disabled due to hung system process."</span>);</span><br><span class="line">                <span class="comment">//返回值为1表示继续等待，-1表示杀死系统</span></span><br><span class="line">                <span class="keyword">int</span> res = controller.systemNotResponding(subject);</span><br><span class="line">                <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//设置ActivityController的某些情况下,可以让发生Watchdog时继续等待</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当debugger没有attach时，才杀死进程</span></span><br><span class="line">        <span class="keyword">if</span> (Debug.isDebuggerConnected()) &#123;</span><br><span class="line">            debuggerWasConnected = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (debuggerWasConnected &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Debugger connected: Watchdog is *not* killing the system process"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (debuggerWasConnected &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Debugger was connected: Watchdog is *not* killing the system process"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowRestart) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Restart not allowed: Watchdog is *not* killing the system process"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"*** WATCHDOG KILLING SYSTEM PROCESS: "</span> + subject);</span><br><span class="line">            <span class="comment">//遍历输出阻塞线程的栈信息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;blockedCheckers.size(); i++) &#123;</span><br><span class="line">                Slog.w(TAG, blockedCheckers.get(i).getName() + <span class="string">" stack trace:"</span>);</span><br><span class="line">                StackTraceElement[] stackTrace</span><br><span class="line">                        = blockedCheckers.get(i).getThread().getStackTrace();</span><br><span class="line">                <span class="keyword">for</span> (StackTraceElement element: stackTrace) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"    at "</span> + element);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Slog.w(TAG, <span class="string">"*** GOODBYE!"</span>);</span><br><span class="line">            <span class="comment">//杀死进程system_server【见小节4.6】</span></span><br><span class="line">            Process.killProcess(Process.myPid());</span><br><span class="line">            System.exit(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将所有执行时间超过1分钟的handler线程或者monitor都记录下来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;HandlerChecker&gt; <span class="title">getBlockedCheckersLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;HandlerChecker&gt; checkers = <span class="keyword">new</span> ArrayList&lt;HandlerChecker&gt;();</span><br><span class="line">    <span class="comment">//遍历所有的Checker</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">        HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">        <span class="comment">//将所有没有完成，且超时的checker加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (hc.isOverdueLocked()) &#123;</span><br><span class="line">            checkers.add(hc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">describeCheckersLocked</span><span class="params">(ArrayList&lt;HandlerChecker&gt; checkers)</span> </span>&#123;</span><br><span class="line">     StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;checkers.size(); i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (builder.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             builder.append(<span class="string">", "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 输出所有的checker信息</span></span><br><span class="line">         builder.append(checkers.get(i).describeBlockedStateLocked());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> builder.toString();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">describeBlockedStateLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//非前台线程进入该分支</span></span><br><span class="line">     <span class="keyword">if</span> (mCurrentMonitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Blocked in handler on "</span> + mName + <span class="string">" ("</span> + getThread().getName() + <span class="string">")"</span>;</span><br><span class="line">     <span class="comment">//前台线程进入该分支</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Blocked in monitor "</span> + mCurrentMonitor.getClass().getName()</span><br><span class="line">                 + <span class="string">" on "</span> + mName + <span class="string">" ("</span> + getThread().getName() + <span class="string">")"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>AMS.dumpStackTraces输出system_server和mediaserver,/sdcard,surfaceflinger这3个native进程的traces信息.之后调用killProcess，当杀死system_server进程，从而导致zygote进程自杀，进而触发init执行重启Zygote进程，这便出现了手机framework重启的现象。</p>
<h2 id="以下情况触发watchdog也不会重启"><a href="#以下情况触发watchdog也不会重启" class="headerlink" title="以下情况触发watchdog也不会重启"></a>以下情况触发watchdog也不会重启</h2><p>1 monkey:设置IActivityController,拦截systemNotResponding事件, 比如monkey<br>2 hang: 执行am hang命令,不重启<br>3 debugger: 连接debugger的情况, 不重启</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>WatchDog一旦启动(俗称“开门放狗”)，就会导致一个一定时间的定时器。在时间段内向设备(linux /dev/watchdog)写入数据(俗称“定期喂狗”)，每次写操作会导致重新设定定时器。如果超时没有写入就会触发reboot操作(俗称”狗咬人了”)。</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2018/12/11/ANR分析/">prev</a>
    

    
    <p>last update time 2018-12-12</p>
    
    
        <a class="extend next post-next" href="/2018/12/10/Android 输入系统/">next</a>
    
    </div>

    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:shenyonghe525@gmail.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/sirencode" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © ShenYonghe 2016 - 2018
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a href="https://hexo.io">Hexo</a> & <a href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
