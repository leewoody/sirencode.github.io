<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>javascript 学习笔记 [ Diablo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

</head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/home.png"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">Home</a>
        
          
          
          
          
          
          
          <a href="/archives">Archives</a>
        
          
          
          
          
          
          
          <a href="/about">About</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">javascript 学习笔记</h1>
<article class="post markdown-style">
  <h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>JavaScript 有七种内置类型:</p>
<ul>
<li>空值(null)</li>
<li>未定义(undefined)</li>
<li>布尔值( boolean)</li>
<li>数字(number)</li>
<li>字符串(string)</li>
<li>对象(object)</li>
<li>符号(symbol，ES6 中新增)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          === <span class="string">"boolean"</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>            === <span class="string">"number"</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"42"</span>          === <span class="string">"string"</span>;</span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">life</span>: <span class="number">42</span> &#125;  === <span class="string">"object"</span>;</span><br><span class="line"><span class="comment">// ES6中新加入的类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">"symbol"</span>;  </span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">"object"</span>; <span class="comment">// true  </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* .. */</span> &#125; === <span class="string">"function"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h4><p>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。</p>
<h5 id="undefined-和-undeclared"><a href="#undefined-和-undeclared" class="headerlink" title="undefined 和 undeclared"></a>undefined 和 undeclared</h5><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明 过的变量，是 undeclared 的。</p>
<p>对于 undeclared(或者 not defined)变量，typeof 照样返回 “undefined”。这是因为typeof有一个特殊的安全防范机制。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">1</span>, <span class="string">"2"</span>, [<span class="number">3</span>] ];a.length;              <span class="comment">// 3</span>a[<span class="number">0</span>] === <span class="number">1</span>;           <span class="comment">// true</span>a[<span class="number">2</span>][<span class="number">0</span>] === <span class="number">3</span>;        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在创建“稀疏”数组(sparse array，即含有空白或空缺单元的数组)时要特别注意:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="number">0</span>] = <span class="number">1</span>;a[<span class="number">1</span>];       <span class="comment">// undefined</span>a.length;   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="string">"foobar"</span>] = <span class="number">2</span>;a.length; /<span class="number">2</span></span><br><span class="line">a[<span class="string">"foobar"</span>]; /<span class="number">2</span>a.foobar; /<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里有个问题需要特别注意，如果字符串键值能够被强制类型转换为十进制数字的话，它 就会被当作数字索引来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];a[<span class="string">"13"</span>] = <span class="number">42</span>;a.length; <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>
<h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><p>有时需要将类数组(一组通过数字索引的值)转换为真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from( <span class="built_in">arguments</span> );</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但<br>JavaScript 中的字符串和字符数组并不是一回事，最多只是看上去相似而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"foo"</span>;<span class="keyword">var</span> b = [<span class="string">"f"</span>,<span class="string">"o"</span>,<span class="string">"o"</span>];</span><br><span class="line"></span><br><span class="line">a.length;                           <span class="comment">// 3</span>b.length;                           <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a.indexOf( <span class="string">"o"</span> );                   <span class="comment">//1</span>b.indexOf( <span class="string">"o"</span> );                   <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.concat( <span class="string">"bar"</span> );</span><br><span class="line"><span class="keyword">var</span> d = b.concat( [<span class="string">"b"</span>,<span class="string">"a"</span>,<span class="string">"r"</span>] );  <span class="comment">// ["f","o","o","b","a","r"]</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>JavaScript 只有一种数值类型:number(数字)，包括“整数”和带小数的十进制数。</p>
<h5 id="数字的语法"><a href="#数字的语法" class="headerlink" title="数字的语法"></a>数字的语法</h5><p>数字前面的 0 可以省略: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 0.42;var b = .42;</span><br></pre></td></tr></table></figure>
<p>特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a * a;b;                  <span class="comment">// 2.5e+21</span><span class="keyword">var</span> c = <span class="number">1</span> / a;c;                  <span class="comment">// 2e-11</span></span><br></pre></td></tr></table></figure>
<h5 id="较小的数值"><a href="#较小的数值" class="headerlink" title="较小的数值"></a>较小的数值</h5><p>二进制浮点数最大的问题(不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此)，是 会出现如下情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>最常见的方法是设置一个误差范围值，通常称为“机器精度”(machine epsilon)，对<br>JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。</p>
<p>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前<br>的版本写 polyfill:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br></pre></td></tr></table></figure>
<h5 id="整数的安全范围"><a href="#整数的安全范围" class="headerlink" title="整数的安全范围"></a>整数的安全范围</h5><p>能够被“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为 Number.MAX_SAFE_INTEGER。 最 小 整 数 是 -9007199254740991， 在 ES6 中 被 定 义 为 Number. MIN_SAFE_INTEGER。</p>
<h5 id="整数检查"><a href="#整数检查" class="headerlink" title="整数检查"></a>整数检查</h5><p>要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42</span> );     <span class="comment">// true</span><span class="built_in">Number</span>.isInteger( <span class="number">42.000</span> ); <span class="comment">// true</span><span class="built_in">Number</span>.isInteger( <span class="number">42.3</span> );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Number</span>.MAX_SAFE_INTEGER );  <span class="comment">// true</span><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) ); <span class="comment">// false</span><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) - <span class="number">1</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="32-位有符号整数"><a href="#32-位有符号整数" class="headerlink" title="32 位有符号整数"></a>32 位有符号整数</h5><p>虽然整数最大能够达到 53 位，但是有些数字操作(如数位操作)只适用于 32 位数字， 所以这些操作中数字的安全范围就要小很多，变成从 Math.pow(-2,31)(-2147483648， 约-21 亿)到 Math.pow(2,31) - 1(2147483647，约 21 亿)。</p>
<h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><h5 id="不是值的值"><a href="#不是值的值" class="headerlink" title="不是值的值"></a>不是值的值</h5><p>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名<br>称既是类型也是值。</p>
<ul>
<li>null 指空值(empty value)</li>
<li>undefined 指没有值(missing value)</li>
</ul>
<p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而<br>undefined 却是一个标识符，可以被当作变量来使用和赋值。</p>
<h5 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h5><p>表达式void ___没有返回值，因此返回结果是undefined。void并不改变表达式的结果， 只是让表达式不返回值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="keyword">void</span> a, a ); <span class="comment">// undefined 42</span></span><br></pre></td></tr></table></figure>
<p>void 0来获得undefined(这主要源自C语言，当然使用void true或其他 void 表达式也是可以的)。void 0、void 1 和 undefined 之间并没有实质上的区别。</p>
<h5 id="特殊的数字NaN"><a href="#特殊的数字NaN" class="headerlink" title="特殊的数字NaN"></a>特殊的数字NaN</h5><p>如果数学运算的操作数不是数字类型(或者无法解析为常规的十进制或十六进制数字)， 就无法返回一个有效的数字，这种情况下返回值为 NaN。不是数字的数字”仍然是数字类型。NaN 是一个“警戒值”(sentinel value，有特殊用途的常规值)，用于指出数字类型中的错误 情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">"foo"</span>;       <span class="comment">// NaN</span><span class="keyword">typeof</span> a === <span class="string">"number"</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="无穷数"><a href="#无穷数" class="headerlink" title="无穷数"></a>无穷数</h5><p>计算结果一旦溢出为无穷数(infinity)就无法再得到有穷数。换句话说，就是你可以从有 穷走向无穷，但无法从无穷回到有穷。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span>;  <span class="comment">// Infinity</span><span class="keyword">var</span> b = <span class="number">-1</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<h5 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h5><p>JavaScript 有一个常规的 0(也叫作 +0)和一个 -0。在解释为什么会有 -0 之前，我们先来看看 JavaScript 是如何来处理它的。加法和减法运算不会得到负零(negative zero)。</p>
<p>有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度)，数字的符号位 (sign)用来代表其他信息(比如移动的方向)。此时如果一个值为 0 的变量失去了它的符<br>号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。</p>
<h5 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h5><p>ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等，可以用来处理 上述所有的特殊情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">"foo"</span>;<span class="keyword">var</span> b = <span class="number">-3</span> * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( a, <span class="literal">NaN</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">-0</span> ); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">0</span> );  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>能使用 == 和 ===时就尽量不要使用 Object.is(..)，因为前者效率更高、<br>更为通用。Object.is(..) 主要用来处理那些特殊的相等比较。</p>
<h4 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h4><p>JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用 / 指向关系。</p>
<p>JavaScript 对值和引用的赋值 / 传递在语法上没有区别，完全根据值的类型来决定。</p>
<h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><h4 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性 [[Class]]"></a>内部属性 [[Class]]</h4><p>所有 typeof 返回值为 “object” 的对象(如数组)都包含一个内部属性 <a href="我们可 以把它看作一个内部的分类，而非传统的面向对象意义上的类">[Class]</a>。这个属性无法直接访问， 一般通过 Object.prototype.toString(..) 来查看。例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ); <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>
<h4 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h4><p>封装对象(object wrapper)扮演着十分重要的角色。由于基本类型值没有 .length 和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为 基本类型值包装(box 或者 wrap)一个封装对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"abc"</span>;a.length; <span class="comment">// 3</span>a.toUpperCase(); <span class="comment">// "ABC"</span></span><br></pre></td></tr></table></figure>
<p>如果需要经常用到这些字符串属性和方法，比如在for循环中使用i &lt; a.length，那么从 一开始就创建一个封装对象也许更为方便，这样 JavaScript 引擎就不用每次都自动创建了。<br>但实际证明这并不是一个好办法，因为浏览器已经为 .length 这样的常见情况做了性能优 化，直接使用封装对象来“提前优化”代码反而会降低执行效率。</p>
<p>如果想要自行封装基本类型值，可以使用 Object(..) 函数(不带 new 关键字):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"abc"</span>;var b = <span class="keyword">new</span> String( a );var c = Object( a );typeof a; <span class="comment">// "string"</span>typeof b; <span class="comment">// "object"</span>typeof c; <span class="comment">// "object"</span>b <span class="keyword">instanceof</span> String; <span class="comment">// true</span>c <span class="keyword">instanceof</span> String; <span class="comment">// true</span>Object.prototype.toString.call( b ); <span class="comment">// "[object String]"</span>Object.prototype.toString.call( c ); <span class="comment">// "[object String]"</span></span><br></pre></td></tr></table></figure>
<h4 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h4><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> String( <span class="string">"abc"</span> );var b = <span class="keyword">new</span> Number( <span class="number">42</span> );var c = <span class="keyword">new</span> Boolean( <span class="keyword">true</span> );a.valueOf(); <span class="comment">// "abc"</span>b.valueOf(); <span class="comment">// 42</span>c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> String( <span class="string">"abc"</span> ); </span><br><span class="line">var b = a + <span class="string">""</span>; <span class="comment">// b的值为"abc"</span>typeof a;       <span class="comment">// "object"</span>typeof b;       <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure>
<h4 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h4><p>关于数组(array)、对象(object)、函数(function)和正则表达式，我们通常喜欢以常 量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的(创建的值都是 通过封装对象来包装)。应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的 结果。</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">a; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">var b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的。</p>
<p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度(length)，而 非只充当数组中的一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">new</span> Array(<span class="number">3</span>);</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h5 id="Object-、Function-和-RegExp"><a href="#Object-、Function-和-RegExp" class="headerlink" title="Object(..)、Function(..) 和 RegExp(..)"></a>Object(..)、Function(..) 和 RegExp(..)</h5><p>同样，除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var c = <span class="keyword">new</span> Object();</span><br><span class="line">c.foo = <span class="string">"bar"</span>;</span><br><span class="line">c; <span class="comment">// &#123; foo: "bar" &#125;</span></span><br><span class="line"></span><br><span class="line">var d = &#123;</span><br><span class="line">  foo: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line">d; <span class="comment">// &#123; foo: "bar" &#125;</span></span><br><span class="line"></span><br><span class="line">var e = <span class="keyword">new</span> Function(<span class="string">"a"</span>, <span class="string">"return a * 2;"</span>);</span><br><span class="line">var f = function (a) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">g</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var h = <span class="keyword">new</span> RegExp(<span class="string">"^a*b+"</span>, <span class="string">"g"</span>);</span><br><span class="line">var i = /^a*b+/g;</span><br></pre></td></tr></table></figure>
<h5 id="Date-和Error"><a href="#Date-和Error" class="headerlink" title="Date()和Error()"></a>Date()和Error()</h5><p>创建日期对象必须使用new Date()。Date(..)可以带参数，用来指定日期和时间，而不带 参数的话则使用当前的日期和时间。</p>
<p>构造函数 Error(..)(与前面的 Array() 类似)带不带 new 关键字都可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"x wasn’t provided"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>符号并非对象，而是一种简单标量基本类型。</p>
<p>符号是具有唯一性的特殊值(并 非绝对)，用它来命名对象属性不容易导致重名。该类型的引入主要源于 ES6 的一些特殊 构造，此外符号也可以自行定义。</p>
<p>我们可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会出错:</p>
<h5 id="原生原型"><a href="#原生原型" class="headerlink" title="原生原型"></a>原生原型</h5><p>原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。<br>根 据 文 档 约 定， 我 们 将 String.prototype.XYZ 简 写 为 String#XYZ， 对 其 他 .prototypes 也同样如此。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">" abc "</span>;</span><br><span class="line">a.indexOf( <span class="string">"c"</span> ); <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase();  <span class="comment">// " ABC "</span></span><br><span class="line">a.trim();         <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 为基本数据类型值提供了封装对象，称为原生函数(如 String、Number、Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如:String#trim() 和 Array#concat(..))。</p>
<p>对于简单标量基本类型值，比如 “abc”，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实 现对这些属性和方法的访问。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h4><p>将值从一种类型转换为另一种类型通常称为类型转换(type casting)，这是显式的情况;隐式的情况称为强制类型转换(coercion)。</p>
<p>JavaScript 中的强制类型转换总是返回标量基本类型值(参见第 2 章)，如字 符串、数字和布尔值，不会返回对象和函数。在第 3 章中，我们介绍过“封 装”，就是为标量基本类型值封装一个相应类型的对象，但这并非严格意义 上的强制类型转换。</p>
<p>也可以这样来区分:类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时(runtime)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = a + <span class="string">""</span>; <span class="comment">// 隐式强制类型转换 </span></span><br><span class="line">var c = String( a ); <span class="comment">// 显式强制类型转换</span></span><br></pre></td></tr></table></figure>
<h4 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h4><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>它负责处理非字符串到字符串的强制类型转换。</p>
<p>基本类型值的字符串化规则为:null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。</p>
<p>对普通对象来说，除非自行定义，否则 toString()(Object.prototype.toString())返回 内部属性 [[Class]] 的值(参见第 3 章)，如 “[object Object]”。</p>
<p>数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接起 来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.toString(); <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure>
<h5 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h5><p>工具函数 JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(<span class="number">42</span>); <span class="comment">// "42"</span></span><br><span class="line">JSON.stringify(<span class="string">"42"</span>); <span class="comment">// ""42""(含有双引号的字符串) JSON.stringify( null ); // "null"</span></span><br><span class="line">JSON.stringify(<span class="keyword">true</span>); <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure>
<p>所有安全的 JSON 值(JSON-safe)都可以使用 JSON.stringify(..) 字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。</p>
<p>undefined、function、symbol (ES6+)和包含循环引用(对象之间相互引用，形成一个无限循环)的对象都不符合 JSON<br>结构标准，支持 JSON 的语言无法处理它们。</p>
<p>JSON.stringify(..) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在<br>数组中则会返回 null(以保证单元位置不变)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(undefined);  <span class="comment">//undefined</span></span><br><span class="line">JSON.stringify(function () &#123;&#125;);  <span class="comment">//undefined</span></span><br><span class="line">JSON.stringify(</span><br><span class="line">  [<span class="number">1</span>, undefined, function () &#123;&#125;, <span class="number">4</span>] <span class="comment">//"[1,null,null,4]"</span></span><br><span class="line">);</span><br><span class="line">JSON.stringify(&#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: function () &#123;&#125;</span><br><span class="line">&#125;);   <span class="comment">//"&#123;"a":2&#125;"</span></span><br></pre></td></tr></table></figure>
<p>我们可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用 来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  b: <span class="number">42</span>,</span><br><span class="line">  c: <span class="string">"42"</span>,</span><br><span class="line">  d: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line">JSON.stringify(a, [<span class="string">"b"</span>, <span class="string">"c"</span>]); <span class="comment">// "&#123;"b":42,"c":"42"&#125;"</span></span><br><span class="line">JSON.stringify(a, function (k, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (k !== <span class="string">"c"</span>) <span class="keyword">return</span> v;</span><br><span class="line">&#125;);<span class="comment">// "&#123;"b":42,"d":[1,2,3]&#125;"</span></span><br></pre></td></tr></table></figure>
<p>JSON.stringify(..) 并不是强制类型转换。在这里介绍是因为它涉及 ToString 强制类型转换，具体表现在以下两点。</p>
<ul>
<li>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。</li>
<li>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</li>
</ul>
<h5 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h5><p>其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>
<p>ToNumber 对字符串的处理基本遵循数字常量的相关规则 / 语法。处理失败 时返回 NaN(处理数字常量失败时会产生语法错误)。不同之处是 ToNumber 对以 0 开头的 十六进制数并不按十六进制处理(而是按十进制)。</p>
<p>对象(包括数组)会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型 值，则再遵循以上规则将其强制转换为数字。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p>
<h5 id="toBoolean"><a href="#toBoolean" class="headerlink" title="toBoolean"></a>toBoolean</h5><p>JavaScript 中的值可以分为以下两类:</p>
<ul>
<li>(1) 可以被强制类型转换为 false 的值</li>
<li>(2) 其他(被强制类型转换为 true 的值)</li>
</ul>
<p>以下这些是假值:</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0 和 NaN</li>
<li>“”</li>
<li>var a = new Boolean( false );</li>
<li>var b = new Number( 0 );</li>
<li>var c = new String( “” );</li>
</ul>
<h4 id="显示强制类型转化"><a href="#显示强制类型转化" class="headerlink" title="显示强制类型转化"></a>显示强制类型转化</h4><p>对显式强制类型转换几乎不存在非议，它类似于静态语言中的类型转换，已被广泛接受， 不会有什么坑。</p>
<h5 id="字符串和数字之间的显式转换"><a href="#字符串和数字之间的显式转换" class="headerlink" title="字符串和数字之间的显式转换"></a>字符串和数字之间的显式转换</h5><p>字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数(原生构造函 数，参见第 3 章)来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。<br>在 JavaScript 开源社区中，一元运算 + 被普遍认为是显式强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = String(a);</span><br><span class="line">var c = <span class="string">"3.14"</span>;</span><br><span class="line">var d = Number(c);</span><br><span class="line"></span><br><span class="line">var c = <span class="string">"3.14"</span>;</span><br><span class="line">var d = <span class="number">5</span> + +c; <span class="comment">//8.14</span></span><br><span class="line">var d = <span class="keyword">new</span> Date(<span class="string">"Mon, 18 Aug 2014 08:53:06 CDT"</span>); +</span><br><span class="line">d; <span class="comment">// 1408369986000</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带 ()。</p>
<h5 id="奇特的-运算符"><a href="#奇特的-运算符" class="headerlink" title="奇特的 ~ 运算符"></a>奇特的 ~ 运算符</h5><p>它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”(对每一个字 位进行反转)。~x 大致等同于 -(x+1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">42</span>; <span class="comment">// -(42+1) ==&gt; -43</span></span><br></pre></td></tr></table></figure>
<h5 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h5><p>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停 止。而转换不允许出现非数字字符，否则会失败并返回 NaN。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"42"</span>;</span><br><span class="line">var b = <span class="string">"42px"</span>;</span><br><span class="line">Number(a); <span class="comment">// 42</span></span><br><span class="line">parseInt(a); <span class="comment">// 42</span></span><br><span class="line">Number(b); <span class="comment">// NaN</span></span><br><span class="line">parseInt(b); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h5 id="显式转换为布尔值"><a href="#显式转换为布尔值" class="headerlink" title="显式转换为布尔值"></a>显式转换为布尔值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"0"</span>;</span><br><span class="line">var b = [];</span><br><span class="line">var c = &#123;&#125;;</span><br><span class="line">var d = <span class="string">""</span>;</span><br><span class="line">var e = <span class="number">0</span>;</span><br><span class="line">var f = <span class="keyword">null</span>;</span><br><span class="line">var g;</span><br><span class="line">Boolean(a); <span class="comment">// true</span></span><br><span class="line">Boolean(b); <span class="comment">// true</span></span><br><span class="line">Boolean(c); <span class="comment">// true</span></span><br><span class="line">Boolean(d); <span class="comment">// false</span></span><br><span class="line">Boolean(e); <span class="comment">// false</span></span><br><span class="line">Boolean(f); <span class="comment">// false</span></span><br><span class="line">Boolean(g); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!a; <span class="comment">// true</span></span><br><span class="line">!!b; <span class="comment">// true</span></span><br><span class="line">!!c; <span class="comment">// true</span></span><br><span class="line">!!d; <span class="comment">// false</span></span><br><span class="line">!!e; <span class="comment">// false</span></span><br><span class="line">!!f; <span class="comment">// false</span></span><br><span class="line">!!g; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>虽然 Boolean(..) 是显式的，但并不常用。所以显式强制类型转换为布尔值最常用的方法是 !!，因为第二个 ! 会将结果反转回原值:</p>
<h4 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h4><h5 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h5><p>&amp;&amp; 和 || 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = <span class="string">"abc"</span>;</span><br><span class="line">var c = <span class="keyword">null</span>;</span><br><span class="line">a || b;<span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b;<span class="comment">// "abc"</span></span><br><span class="line">c || b;<span class="comment">// "abc"</span></span><br><span class="line">c &amp;&amp; b;<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">a || b;</span><br><span class="line"><span class="comment">// 大致相当于(roughly equivalent to): a ? a : b;</span></span><br><span class="line">a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 大致相当于(roughly equivalent to): a ? b : a;</span></span><br></pre></td></tr></table></figure>
<h4 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h4><p>宽松相等(loose equals)== 和严格相等(strict equals)=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。</p>
<p>正确的解释是:“== 允许在相等比较中进行强制类型转换，而 === 不允许。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = <span class="string">"42"</span>;</span><br><span class="line">a === b; <span class="comment">// false</span></span><br><span class="line">a == b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="其他类型和布尔类型之间的相等比较"><a href="#其他类型和布尔类型之间的相等比较" class="headerlink" title="其他类型和布尔类型之间的相等比较"></a>其他类型和布尔类型之间的相等比较</h5><p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果;</p>
<p>(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"42"</span>;</span><br><span class="line">var b = <span class="keyword">true</span>;</span><br><span class="line">a == b; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="null-和-undefined-之间的相等比较"><a href="#null-和-undefined-之间的相等比较" class="headerlink" title="null 和 undefined 之间的相等比较"></a>null 和 undefined 之间的相等比较</h5><p>在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换:</p>
<h5 id="对象和非对象之间的相等比较"><a href="#对象和非对象之间的相等比较" class="headerlink" title="对象和非对象之间的相等比较"></a>对象和非对象之间的相等比较</h5><p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果; </p>
<p>(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">42</span>;</span><br><span class="line">var b = [<span class="number">42</span>];</span><br><span class="line">a == b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h4><p>句子”(sentence)是完整表达某个意思的一组词，由一个或多个“短语”(phrase)组成， 它们之间由标点符号或连接词(and 和 or 等)连接起来。短语可以由更小的短语组成。有 些短语是不完整的，不能独立表达意思;有些短语则相对完整，并且能够独立表达某个意 思。这些规则就是英语的语法。JavaScript 的语法也是如此。语句相当于句子，表达式相当于短语，运算符则相当于标点 符号和连接词。</p>
<h5 id="语句的结果值"><a href="#语句的结果值" class="headerlink" title="语句的结果值"></a>语句的结果值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面方法获取不到值</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a =</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    b = <span class="number">4</span> + <span class="number">38</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a = <span class="built_in">eval</span>(<span class="string">"if (true) &#123; b = 4 + 38; &#125;"</span>);</span><br><span class="line">a; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h5 id="表达式的副作用"><a href="#表达式的副作用" class="headerlink" title="表达式的副作用"></a>表达式的副作用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// 结果值:undefined。副作用:a的值被改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a++;</span><br><span class="line"><span class="comment">//a 43,b 42</span></span><br></pre></td></tr></table></figure>
<h5 id="上下文规则"><a href="#上下文规则" class="headerlink" title="上下文规则"></a>上下文规则</h5><h5 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h5><p>下面两种情况会用到大括号 { .. }</p>
<p>对象常量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  foo: bar()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>标签</p>
<h5 id="else-if-和可选代码块"><a href="#else-if-和可选代码块" class="headerlink" title="else if 和可选代码块"></a>else if 和可选代码块</h5><p>javascript没有elseif，但 if 和 else 只包含单条语句的时候可以省略代码块的 { }。</p>
<p>else if实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123; <span class="comment">// ..</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (b) &#123; <span class="comment">// ..</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// .. &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><h5 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h5><p>对 &amp;&amp; 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数。我们将 这种现象称为“短路”(即执行最短路径)。</p>
<p>以a &amp;&amp; b为例，如果a是一个假值，足以决定&amp;&amp;的结果，就没有必要再判断b的值。同 样对于 a || b，如果 a 是一个真值，也足以决定 || 的结果，也就没有必要再判断 b 的值。</p>
<ul>
<li>&amp;&amp; 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。</li>
</ul>
<h4 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h4><p>因为如果缺失了必要的 ;，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的 ;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>,b</span><br><span class="line">c;<span class="comment">//c会被作为var语句的一部分来处理</span></span><br></pre></td></tr></table></figure>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>JavaScript 不仅有各种类型的运行时错误(TypeError、ReferenceError、SyntaxError 等)，它的语法中也定义了一些编译时错误。</p>
<h4 id="提前使用变量"><a href="#提前使用变量" class="headerlink" title="提前使用变量"></a>提前使用变量</h4><p>ES6 规范定义了一个新概念，叫作 TDZ(Temporal Dead Zone，暂时性死区)。 TDZ 指的是由于代码中的变量还没有初始化而不能被引用的情况。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>在 ES6 中，如果参数被省略或者值为 undefined，则取该参数的默认值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a = <span class="number">42</span>, b = a + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">// 42 43</span></span><br><span class="line">foo(<span class="literal">undefined</span>);<span class="comment">// 42 43</span></span><br><span class="line">foo(<span class="number">5</span>);<span class="comment">// 5 6</span></span><br><span class="line">foo(<span class="keyword">void</span> <span class="number">0</span>, <span class="number">7</span>);<span class="comment">// 42 7</span></span><br><span class="line">foo(<span class="literal">null</span>);<span class="comment">// null 1</span></span><br></pre></td></tr></table></figure>
<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try..finally"></a>try..finally</h4><p>finally 中的代码总是会在 try 之后执行，如果有 catch 的话则在 catch 之后执行。也可以将 finally 中的代码看作一个回调函数，即无论出现什么情况最后一定会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"never runs"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> (a || b == <span class="number">10</span>):</span><br><span class="line">    <span class="comment">// 永远执行不到这里</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 的决议:一种在异步任务中作为两个或更多步骤的流程控制机制，时序上的 this- then-that。</p>
<p>Promise 至多只能有一个决议值(完成或拒绝)。</p>
<p>两个 Promise 固有行为特性:</p>
<ul>
<li>每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来;</li>
<li>不管从then(..) 调用的完成回调(第一个参数)返回的值是什么，它都会被自动设置 为被链接 Promise(第一点中的)的完成。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"B"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = p.then(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="comment">// 用值42填充p2</span></span><br><span class="line">  <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 连接p2</span></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="术语-决议、完成以及拒绝"><a href="#术语-决议、完成以及拒绝" class="headerlink" title="术语:决议、完成以及拒绝"></a>术语:决议、完成以及拒绝</h5><p>对于术语决议(resolve)、完成(fulfill)和拒绝(reject)，在更深入学习 Promise 之前，我们还有一些模糊之处需要澄清。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">X, Y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// X()用于完成</span></span><br><span class="line">  <span class="comment">// Y()用于拒绝 </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数字没有string函数，所以会抛出错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line">).catch(handleErrors);</span><br></pre></td></tr></table></figure>
<p>因为我们没有为 then(..) 传入拒绝处理函数，所以默认的处理函数被替换掉了，而这仅仅是把错误传递给了链中的下一个 promise。因此，进入 p 的错误以及 p 之后进入其决议 (就像 msg.toLowerCase())的错误都会传递到最后的handleErrors(..)。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([ .. ])"></a>Promise.all([ .. ])</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = request(<span class="string">"http://some.url.1/"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = request(<span class="string">"http://some.url.2/"</span>);</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">msgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里，p1和p2完成并把它们的消息传入 return request(</span></span><br><span class="line">    <span class="string">"http://some.url.3/?v="</span> + msgs.join(<span class="string">","</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>从Promise.all([ .. ])返回的主promise在且仅在所有的成员promise都完成后才会完 成。如果这些promise中有任何一个被拒绝的话，主Promise.all([ .. ])promise就会立 即被拒绝，并丢弃来自其他所有 promise 的全部结果。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([ .. ])"></a>Promise.race([ .. ])</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = request(<span class="string">"http://some.url.1/"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = request(<span class="string">"http://some.url.2/"</span>);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p1或者p2将赢得这场竞赛 return request(</span></span><br><span class="line">    <span class="string">"http://some.url.3/?v="</span> + msg</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>因为只有一个 promise 能够取胜，所以完成值是单个消息，而不是像对 Promise.all([ 那样的是一个数组。<br>.. ])</p>
<p>与Promise.all([ .. ])类似，一旦有任何一个Promise决议为完成，Promise.race([ .. ]) 就会完成;一旦有任何一个 Promise 决议为拒绝，它就会拒绝。</p>
<h4 id="Promise-API-概述"><a href="#Promise-API-概述" class="headerlink" title="Promise API 概述"></a>Promise API 概述</h4><h5 id="new-Promise-构造器"><a href="#new-Promise-构造器" class="headerlink" title="new Promise(..) 构造器"></a>new Promise(..) 构造器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve(..)用于决议/完成这个promise</span></span><br><span class="line">  <span class="comment">// reject(..)用于拒绝这个promise</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>reject(..) 就是拒绝这个 promise;但 resolve(..) 既可能完成 promise，也可能拒绝，要 根据传入参数而定。如果传给 resolve(..) 的是一个非 Promise、非 thenable 的立即值，这 个 promise 就会用这个值完成。</p>
<p>但是，如果传给 resolve(..) 的是一个真正的 Promise 或 thenable 值，这个值就会被递归展 开，并且(要构造的)promise 将取用其最终决议值或状态。</p>
<h5 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve(..) 和 Promise.reject(..)"></a>Promise.resolve(..) 和 Promise.reject(..)</h5><p>创建一个已被拒绝的 Promise 的快捷方式是使用 Promise.reject(..)，所以以下两个promise 是等价的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="string">"Oops"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">"Oops"</span>);</span><br></pre></td></tr></table></figure>
<p>Promise.resolve(..) 常用于创建一个已完成的 Promise,但是，Promise.resolve(..) 也会展开 thenable 值在这种情况 下，返回的 Promise 采用传入的这个 thenable 的最终决议值，可能是完成，也可能是拒绝:</p>
<h5 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then(..) 和 catch(..)"></a>then(..) 和 catch(..)</h5><p>每个 Promise 实例(不是 Promise API 命名空间)都有 then(..) 和 catch(..) 方法，通过 这两个方法可以为这个 Promise 注册完成和拒绝处理函数。Promise 决议之后，立即会调用 这两个处理函数之一，但不会两个都调用，而且总是异步调用.</p>
<h5 id="then-接受一个或两个参数"><a href="#then-接受一个或两个参数" class="headerlink" title="then(..) 接受一个或两个参数"></a>then(..) 接受一个或两个参数</h5><p>then(..) 接受一个或两个参数:第一个用于完成回调，第二个用于拒绝回调。如果两者中 的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回 调只是把消息传递下去，而默认拒绝回调则只是重新抛出(传播)其接收到的出错原因。</p>
<p>就像刚刚讨论过的一样，catch(..) 只接受一个拒绝回调作为参数，并自动替换默认完成 回调。换句话说，它等价于 then(null,..):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.then(fulfilled);</span><br><span class="line">p.then(fulfilled, rejected);</span><br><span class="line">p.catch(rejected); <span class="comment">// 或者p.then( null, rejected )</span></span><br></pre></td></tr></table></figure>
<p>then(..) 和 catch(..) 也会创建并返回一个新的 promise，这个 promise 可以用于实现 Promise 链式流程控制。如果完成或拒绝回调中抛出异常，返回的 promise 是被拒绝的。如 果任意一个回调返回非 Promise、非 thenable 的立即值，这个值会被用作返回 promise 的完 成值。如果完成处理函数返回一个 promise 或 thenable，那么这个值会被展开，并作为返回 promise 的决议值。</p>
<h4 id="Promise-局限性"><a href="#Promise-局限性" class="headerlink" title="Promise 局限性"></a>Promise 局限性</h4><h5 id="顺序错误处理"><a href="#顺序错误处理" class="headerlink" title="顺序错误处理"></a>顺序错误处理</h5><p>Promise 的设计局限性(具体来说，就 是它们链接的方式)造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被 无意中默默忽略掉。</p>
<h5 id="单一值"><a href="#单一值" class="headerlink" title="单一值"></a>单一值</h5><p>Promise 只能有一个完成值或一个拒绝理由。</p>
<h5 id="单决议"><a href="#单决议" class="headerlink" title="单决议"></a>单决议</h5><p>Promise 最本质的一个特征是:Promise 只能被决议一次(完成或拒绝)。</p>
<h5 id="无法取消的Promise"><a href="#无法取消的Promise" class="headerlink" title="无法取消的Promise"></a>无法取消的Promise</h5><p>一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。</p>
<h5 id="Promise-性能"><a href="#Promise-性能" class="headerlink" title="Promise 性能"></a>Promise 性能</h5><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="打破完整运行"><a href="#打破完整运行" class="headerlink" title="打破完整运行"></a>打破完整运行</h4><p>下面是实现这样的合作式并发的 ES6 代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// 暂停!</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x:"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个迭代器it来控制这个生成器</span></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"><span class="comment">// 这里启动foo()! </span></span><br><span class="line">it.next();</span><br><span class="line">x; <span class="comment">// 2 </span></span><br><span class="line">bar();</span><br><span class="line">x; <span class="comment">// 3 </span></span><br><span class="line">it.next(); <span class="comment">// x: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>it = foo()运算并没有执行生成器*foo()，而只是构造了一个迭代器(iterator)，这个 迭代器会控制它的执行。后面会介绍迭代器。</li>
<li>第一个 it.next() 启动了生成器 <em>foo()，并运行了 </em>foo() 第一行的 x++。</li>
<li><em>foo() 在 yield 语句处暂停，在这一点上第一个 it.next() 调用结束。此时 </em>foo() 仍在运行并且是活跃的，但处于暂停状态。</li>
<li>我们查看 x 的值，此时为 2。</li>
<li>我们调用 bar()，它通过 x++ 再次递增 x。</li>
<li>我们再次查看 x 的值，此时为 3。</li>
<li>最后的 it.next() 调用从暂停处恢复了生成器 *foo() 的执行，并运行 console.log(..)语句，这条语句使用当前 x 的值 3。</li>
</ul>
<h5 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h5><p>生成器函数是一个特殊的函数，具有前面我们展示的新的执行模式。但是，它仍然是一个 函数，这意味着它仍然有一些基本的特性没有改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line">res.value; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>yield .. 和 next(..) 这一对组合起来，在生成器的执行过程中构成了一个双向消息传递系统。</p>
<h5 id="多个迭代器"><a href="#多个迭代器" class="headerlink" title="多个迭代器"></a>多个迭代器</h5><p>同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  z++;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span>(x * z);</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> it1 = foo();</span><br><span class="line"><span class="keyword">var</span> it2 = foo();</span><br><span class="line"><span class="keyword">var</span> val1 = it1.next().value; <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line"><span class="keyword">var</span> val2 = it2.next().value; <span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line">val1 = it1.next(val2 * <span class="number">10</span>).value; <span class="comment">// 40   &lt;-- x:20,  z:2</span></span><br><span class="line">val2 = it2.next(val1 * <span class="number">5</span>).value; <span class="comment">// 600  &lt;-- x:200, z:3</span></span><br><span class="line">it1.next(val2 / <span class="number">2</span>); <span class="comment">// y:300</span></span><br><span class="line">it2.next(val1 / <span class="number">4</span>); <span class="comment">// y:10</span></span><br></pre></td></tr></table></figure>
</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2017/05/05/lambda 语法/">prev</a>
    

    
    <p>last update time 2017-04-21</p>
    
    
        <a class="extend next post-next" href="/2017/04/17/设计模式/">next</a>
    
    </div>

    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:1178752402@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/CaiChenghan" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://www.jianshu.com/u/565c8e790605" title="jianshu" target="_self">
					<i class="fa fa-jianshu"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © ShenYonghe 2017 - 2018
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a href="https://hexo.io">Hexo</a> & <a href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
